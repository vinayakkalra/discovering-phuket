/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@dfinity/agent/lib/esm/actor.js":
/*!******************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/actor.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: () => (/* binding */ ACTOR_METHOD_WITH_HTTP_DETAILS),
    /* harmony export */   Actor: () => (/* binding */ Actor),
    /* harmony export */   ActorCallError: () => (/* binding */ ActorCallError),
    /* harmony export */   CanisterInstallMode: () => (/* binding */ CanisterInstallMode),
    /* harmony export */   QueryCallRejectedError: () => (/* binding */ QueryCallRejectedError),
    /* harmony export */   UpdateCallRejectedError: () => (/* binding */ UpdateCallRejectedError),
    /* harmony export */   getManagementCanister: () => (/* binding */ getManagementCanister)
    /* harmony export */ });
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ "./node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ "./node_modules/@dfinity/agent/lib/esm/errors.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling */ "./node_modules/@dfinity/agent/lib/esm/polling/index.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    /* harmony import */ var _canisters_management_idl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./canisters/management_idl */ "./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js");
    
    
    
    
    
    
    
    
    class ActorCallError extends _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError {
        constructor(canisterId, methodName, type, props) {
            super([
                `Call failed:`,
                `  Canister: ${canisterId.toText()}`,
                `  Method: ${methodName} (${type})`,
                ...Object.getOwnPropertyNames(props).map(n => `  "${n}": ${JSON.stringify(props[n])}`),
            ].join('\n'));
            this.canisterId = canisterId;
            this.methodName = methodName;
            this.type = type;
            this.props = props;
        }
    }
    class QueryCallRejectedError extends ActorCallError {
        constructor(canisterId, methodName, result) {
            var _a;
            super(canisterId, methodName, 'query', {
                Status: result.status,
                Code: (_a = _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
                Message: result.reject_message,
            });
            this.result = result;
        }
    }
    class UpdateCallRejectedError extends ActorCallError {
        constructor(canisterId, methodName, requestId, response) {
            super(canisterId, methodName, 'update', Object.assign({ 'Request ID': (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_6__.toHex)(requestId) }, (response.body
                ? Object.assign(Object.assign({}, (response.body.error_code
                    ? {
                        'Error code': response.body.error_code,
                    }
                    : {})), { 'Reject code': String(response.body.reject_code), 'Reject message': response.body.reject_message }) : {
                'HTTP status code': response.status.toString(),
                'HTTP status text': response.statusText,
            })));
            this.requestId = requestId;
            this.response = response;
        }
    }
    /**
     * The mode used when installing a canister.
     */
    var CanisterInstallMode;
    (function (CanisterInstallMode) {
        CanisterInstallMode["Install"] = "install";
        CanisterInstallMode["Reinstall"] = "reinstall";
        CanisterInstallMode["Upgrade"] = "upgrade";
    })(CanisterInstallMode || (CanisterInstallMode = {}));
    const metadataSymbol = Symbol.for('ic-agent-metadata');
    /**
     * An actor base class. An actor is an object containing only functions that will
     * return a promise. These functions are derived from the IDL definition.
     */
    class Actor {
        constructor(metadata) {
            this[metadataSymbol] = Object.freeze(metadata);
        }
        /**
         * Get the Agent class this Actor would call, or undefined if the Actor would use
         * the default agent (global.ic.agent).
         * @param actor The actor to get the agent of.
         */
        static agentOf(actor) {
            return actor[metadataSymbol].config.agent;
        }
        /**
         * Get the interface of an actor, in the form of an instance of a Service.
         * @param actor The actor to get the interface of.
         */
        static interfaceOf(actor) {
            return actor[metadataSymbol].service;
        }
        static canisterIdOf(actor) {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(actor[metadataSymbol].config.canisterId);
        }
        static async install(fields, config) {
            const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;
            // Need to transform the arg into a number array.
            const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];
            // Same for module.
            const wasmModule = [...new Uint8Array(fields.module)];
            const canisterId = typeof config.canisterId === 'string'
                ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)
                : config.canisterId;
            await getManagementCanister(config).install_code({
                mode: { [mode]: null },
                arg,
                wasm_module: wasmModule,
                canister_id: canisterId,
            });
        }
        static async createCanister(config) {
            const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
            return canisterId;
        }
        static async createAndInstallCanister(interfaceFactory, fields, config) {
            const canisterId = await this.createCanister(config);
            await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
            return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
        }
        static createActorClass(interfaceFactory, options) {
            const service = interfaceFactory({ IDL: _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL });
            class CanisterActor extends Actor {
                constructor(config) {
                    if (!config.canisterId)
                        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
                    const canisterId = typeof config.canisterId === 'string'
                        ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)
                        : config.canisterId;
                    super({
                        config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
                        service,
                    });
                    for (const [methodName, func] of service._fields) {
                        if (options === null || options === void 0 ? void 0 : options.httpDetails) {
                            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);
                        }
                        this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
                    }
                }
            }
            return CanisterActor;
        }
        static createActor(interfaceFactory, configuration) {
            if (!configuration.canisterId) {
                throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
            }
            return new (this.createActorClass(interfaceFactory))(configuration);
        }
        static createActorWithHttpDetails(interfaceFactory, configuration) {
            return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);
        }
    }
    // IDL functions can have multiple return values, so decoding always
    // produces an array. Ensure that functions with single or zero return
    // values behave as expected.
    function decodeReturnValue(types, msg) {
        const returnValues = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.decode(types, buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(msg));
        switch (returnValues.length) {
            case 0:
                return undefined;
            case 1:
                return returnValues[0];
            default:
                return returnValues;
        }
    }
    const DEFAULT_ACTOR_CONFIG = {
        pollingStrategyFactory: _polling__WEBPACK_IMPORTED_MODULE_4__.strategy.defaultStrategy,
    };
    const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';
    function _createActorMethod(actor, methodName, func, blsVerify) {
        let caller;
        if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {
            caller = async (options, ...args) => {
                var _a, _b;
                // First, if there's a config transformation, call it.
                options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
                const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();
                const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
                const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);
                const result = await agent.query(cid, { methodName, arg });
                switch (result.status) {
                    case "rejected" /* QueryResponseStatus.Rejected */:
                        throw new QueryCallRejectedError(cid, methodName, result);
                    case "replied" /* QueryResponseStatus.Replied */:
                        return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)
                            ? {
                                httpDetails: result.httpDetails,
                                result: decodeReturnValue(func.retTypes, result.reply.arg),
                            }
                            : decodeReturnValue(func.retTypes, result.reply.arg);
                }
            };
        }
        else {
            caller = async (options, ...args) => {
                var _a, _b;
                // First, if there's a config transformation, call it.
                options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
                const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();
                const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
                const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);
                const ecid = effectiveCanisterId !== undefined ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(effectiveCanisterId) : cid;
                const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);
                const { requestId, response } = await agent.call(cid, {
                    methodName,
                    arg,
                    effectiveCanisterId: ecid,
                });
                if (!response.ok || response.body /* IC-1462 */) {
                    throw new UpdateCallRejectedError(cid, methodName, requestId, response);
                }
                const pollStrategy = pollingStrategyFactory();
                const responseBytes = await (0,_polling__WEBPACK_IMPORTED_MODULE_4__.pollForResponse)(agent, ecid, requestId, pollStrategy, blsVerify);
                const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
                if (responseBytes !== undefined) {
                    return shouldIncludeHttpDetails
                        ? {
                            httpDetails: response,
                            result: decodeReturnValue(func.retTypes, responseBytes),
                        }
                        : decodeReturnValue(func.retTypes, responseBytes);
                }
                else if (func.retTypes.length === 0) {
                    return shouldIncludeHttpDetails
                        ? {
                            httpDetails: response,
                            result: undefined,
                        }
                        : undefined;
                }
                else {
                    throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);
                }
            };
        }
        const handler = (...args) => caller({}, ...args);
        handler.withOptions =
            (options) => (...args) => caller(options, ...args);
        return handler;
    }
    /**
     * Create a management canister actor
     * @param config
     */
    function getManagementCanister(config) {
        function transform(_methodName, args, _callConfig) {
            const first = args[0];
            let effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('');
            if (first && typeof first === 'object' && first.canister_id) {
                effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(first.canister_id);
            }
            return { effectiveCanisterId };
        }
        return Actor.createActor(_canisters_management_idl__WEBPACK_IMPORTED_MODULE_7__["default"], Object.assign(Object.assign(Object.assign({}, config), { canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('') }), {
            callTransform: transform,
            queryTransform: transform,
        }));
    }
    //# sourceMappingURL=actor.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/api.js":
    /*!**********************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/api.js ***!
      \**********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ReplicaRejectCode: () => (/* binding */ ReplicaRejectCode)
    /* harmony export */ });
    /**
     * Codes used by the replica for rejecting a message.
     * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.
     */
    var ReplicaRejectCode;
    (function (ReplicaRejectCode) {
        ReplicaRejectCode[ReplicaRejectCode["SysFatal"] = 1] = "SysFatal";
        ReplicaRejectCode[ReplicaRejectCode["SysTransient"] = 2] = "SysTransient";
        ReplicaRejectCode[ReplicaRejectCode["DestinationInvalid"] = 3] = "DestinationInvalid";
        ReplicaRejectCode[ReplicaRejectCode["CanisterReject"] = 4] = "CanisterReject";
        ReplicaRejectCode[ReplicaRejectCode["CanisterError"] = 5] = "CanisterError";
    })(ReplicaRejectCode || (ReplicaRejectCode = {}));
    //# sourceMappingURL=api.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js":
    /*!******************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js ***!
      \******************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   AgentHTTPResponseError: () => (/* binding */ AgentHTTPResponseError)
    /* harmony export */ });
    class AgentHTTPResponseError extends Error {
        constructor(message, response) {
            super(message);
            this.response = response;
            this.name = this.constructor.name;
            Object.setPrototypeOf(this, new.target.prototype);
        }
    }
    //# sourceMappingURL=errors.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/http/index.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/index.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Expiry: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry),
    /* harmony export */   HttpAgent: () => (/* binding */ HttpAgent),
    /* harmony export */   IdentityInvalidError: () => (/* binding */ IdentityInvalidError),
    /* harmony export */   RequestStatusResponseStatus: () => (/* binding */ RequestStatusResponseStatus),
    /* harmony export */   httpHeadersTransform: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform),
    /* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeExpiryTransform),
    /* harmony export */   makeNonce: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_7__.makeNonce),
    /* harmony export */   makeNonceTransform: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors */ "./node_modules/@dfinity/agent/lib/esm/errors.js");
    /* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../auth */ "./node_modules/@dfinity/agent/lib/esm/auth.js");
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cbor */ "./node_modules/@dfinity/agent/lib/esm/cbor.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../request_id */ "./node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    /* harmony import */ var _transforms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transforms */ "./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js");
    /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ "./node_modules/@dfinity/agent/lib/esm/agent/http/types.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errors */ "./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js");
    /* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../canisterStatus */ "./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js");
    /* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../certificate */ "./node_modules/@dfinity/agent/lib/esm/certificate.js");
    /* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/@noble/curves/esm/ed25519.js");
    /* harmony import */ var _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils/expirableMap */ "./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js");
    /* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../public_key */ "./node_modules/@dfinity/agent/lib/esm/public_key.js");
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_verifyQueryResponse;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    var RequestStatusResponseStatus;
    (function (RequestStatusResponseStatus) {
        RequestStatusResponseStatus["Received"] = "received";
        RequestStatusResponseStatus["Processing"] = "processing";
        RequestStatusResponseStatus["Replied"] = "replied";
        RequestStatusResponseStatus["Rejected"] = "rejected";
        RequestStatusResponseStatus["Unknown"] = "unknown";
        RequestStatusResponseStatus["Done"] = "done";
    })(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
    // Default delta for ingress expiry is 5 minutes.
    const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;
    // Root public key for the IC, encoded as hex
    const IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +
        'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +
        '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +
        'b01291091c5f87b98883463f98091a0baaae';
    // IC0 domain info
    const IC0_DOMAIN = 'ic0.app';
    const IC0_SUB_DOMAIN = '.ic0.app';
    const ICP0_DOMAIN = 'icp0.io';
    const ICP0_SUB_DOMAIN = '.icp0.io';
    const ICP_API_DOMAIN = 'icp-api.io';
    const ICP_API_SUB_DOMAIN = '.icp-api.io';
    class HttpDefaultFetchError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {
        constructor(message) {
            super(message);
            this.message = message;
        }
    }
    class IdentityInvalidError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {
        constructor(message) {
            super(message);
            this.message = message;
        }
    }
    function getDefaultFetch() {
        let defaultFetch;
        if (typeof window !== 'undefined') {
            // Browser context
            if (window.fetch) {
                defaultFetch = window.fetch.bind(window);
            }
            else {
                throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');
            }
        }
        else if (typeof __webpack_require__.g !== 'undefined') {
            // Node context
            if (__webpack_require__.g.fetch) {
                defaultFetch = __webpack_require__.g.fetch.bind(__webpack_require__.g);
            }
            else {
                throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');
            }
        }
        else if (typeof self !== 'undefined') {
            if (self.fetch) {
                defaultFetch = self.fetch.bind(self);
            }
        }
        if (defaultFetch) {
            return defaultFetch;
        }
        throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');
    }
    // A HTTP agent allows users to interact with a client of the internet computer
    // using the available methods. It exposes an API that closely follows the
    // public view of the internet computer, and is not intended to be exposed
    // directly to the majority of users due to its low-level interface.
    //
    // There is a pipeline to apply transformations to the request before sending
    // it to the client. This is to decouple signature, nonce generation and
    // other computations so that this class can stay as simple as possible while
    // allowing extensions.
    class HttpAgent {
        constructor(options = {}) {
            this.rootKey = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHex)(IC_ROOT_KEY);
            this._timeDiffMsecs = 0;
            this._rootKeyFetched = false;
            this._isAgent = true;
            _HttpAgent_queryPipeline.set(this, []);
            _HttpAgent_updatePipeline.set(this, []);
            _HttpAgent_subnetKeys.set(this, new _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__.ExpirableMap({
                expirationTime: 5 * 60 * 1000, // 5 minutes
            }));
            _HttpAgent_verifyQuerySignatures.set(this, true);
            /**
             * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation
             * @param queryResponse - The response from the query
             * @param subnetStatus - The subnet status, including all node keys
             * @returns ApiQueryResponse
             */
            _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {
                if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f") === false) {
                    // This should not be called if the user has disabled verification
                    return queryResponse;
                }
                if (!subnetStatus) {
                    throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');
                }
                const { status, signatures = [], requestId } = queryResponse;
                const domainSeparator = new TextEncoder().encode('\x0Bic-response');
                for (const sig of signatures) {
                    const { timestamp, identity } = sig;
                    const nodeId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(identity).toText();
                    let hash;
                    // Hash is constructed differently depending on the status
                    if (status === 'replied') {
                        const { reply } = queryResponse;
                        hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({
                            status: status,
                            reply: reply,
                            timestamp: BigInt(timestamp),
                            request_id: requestId,
                        });
                    }
                    else if (status === 'rejected') {
                        const { reject_code, reject_message, error_code } = queryResponse;
                        hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({
                            status: status,
                            reject_code: reject_code,
                            reject_message: reject_message,
                            error_code: error_code,
                            timestamp: BigInt(timestamp),
                            request_id: requestId,
                        });
                    }
                    else {
                        throw new Error(`Unknown status: ${status}`);
                    }
                    const separatorWithHash = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat)(domainSeparator, new Uint8Array(hash));
                    // FIX: check for match without verifying N times
                    const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);
                    if (!pubKey) {
                        throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');
                    }
                    const rawKey = _public_key__WEBPACK_IMPORTED_MODULE_12__.Ed25519PublicKey.fromDer(pubKey).rawKey;
                    const valid = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));
                    if (valid)
                        return queryResponse;
                    throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);
                }
                return queryResponse;
            });
            if (options.source) {
                if (!(options.source instanceof HttpAgent)) {
                    throw new Error("An Agent's source can only be another HttpAgent");
                }
                this._identity = options.source._identity;
                this._fetch = options.source._fetch;
                this._host = options.source._host;
                this._credentials = options.source._credentials;
            }
            else {
                this._fetch = options.fetch || getDefaultFetch() || fetch.bind(__webpack_require__.g);
                this._fetchOptions = options.fetchOptions;
                this._callOptions = options.callOptions;
            }
            if (options.host !== undefined) {
                if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {
                    this._host = new URL(window.location.protocol + '//' + options.host);
                }
                else {
                    this._host = new URL(options.host);
                }
            }
            else if (options.source !== undefined) {
                // Safe to ignore here.
                this._host = options.source._host;
            }
            else {
                const location = typeof window !== 'undefined' ? window.location : undefined;
                if (!location) {
                    this._host = new URL('https://icp-api.io');
                    console.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');
                }
                // Mainnet, local, and remote environments will have the api route available
                const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];
                const remoteHosts = ['.github.dev', '.gitpod.io'];
                const hostname = location === null || location === void 0 ? void 0 : location.hostname;
                let knownHost;
                if (hostname && typeof hostname === 'string') {
                    if (remoteHosts.some(host => hostname.endsWith(host))) {
                        knownHost = hostname;
                    }
                    else {
                        knownHost = knownHosts.find(host => hostname.endsWith(host));
                    }
                }
                if (location && knownHost) {
                    // If the user is on a boundary-node provided host, we can use the same host for the agent
                    this._host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);
                }
                else {
                    this._host = new URL('https://icp-api.io');
                    console.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');
                }
            }
            if (options.verifyQuerySignatures !== undefined) {
                __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, "f");
            }
            // Default is 3, only set from option if greater or equal to 0
            this._retryTimes =
                options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;
            // Rewrite to avoid redirects
            if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {
                this._host.hostname = IC0_DOMAIN;
            }
            else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
                this._host.hostname = ICP0_DOMAIN;
            }
            else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
                this._host.hostname = ICP_API_DOMAIN;
            }
            if (options.credentials) {
                const { name, password } = options.credentials;
                this._credentials = `${name}${password ? ':' + password : ''}`;
            }
            this._identity = Promise.resolve(options.identity || new _auth__WEBPACK_IMPORTED_MODULE_2__.AnonymousIdentity());
            // Add a nonce transform to ensure calls are unique
            this.addTransform('update', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));
            if (options.useQueryNonces) {
                this.addTransform('query', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));
            }
        }
        isLocal() {
            const hostname = this._host.hostname;
            return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');
        }
        addTransform(type, fn, priority = fn.priority || 0) {
            if (type === 'update') {
                // Keep the pipeline sorted at all time, by priority.
                const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").findIndex(x => (x.priority || 0) < priority);
                __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").length, 0, Object.assign(fn, { priority }));
            }
            else if (type === 'query') {
                // Keep the pipeline sorted at all time, by priority.
                const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").findIndex(x => (x.priority || 0) < priority);
                __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").length, 0, Object.assign(fn, { priority }));
            }
        }
        async getPrincipal() {
            if (!this._identity) {
                throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
            }
            return (await this._identity).getPrincipal();
        }
        async call(canisterId, options, identity) {
            const id = await (identity !== undefined ? await identity : await this._identity);
            if (!id) {
                throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
            }
            const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);
            const ecid = options.effectiveCanisterId
                ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.effectiveCanisterId)
                : canister;
            const sender = id.getPrincipal() || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();
            let ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);
            // If the value is off by more than 30 seconds, reconcile system time with the network
            if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {
                ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);
            }
            const submit = {
                request_type: _types__WEBPACK_IMPORTED_MODULE_7__.SubmitRequestType.Call,
                canister_id: canister,
                method_name: options.methodName,
                arg: options.arg,
                sender,
                ingress_expiry,
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let transformedRequest = (await this._transform({
                request: {
                    body: null,
                    method: 'POST',
                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                },
                endpoint: "call" /* Endpoint.Call */,
                body: submit,
            }));
            // Apply transform for identity.
            transformedRequest = await id.transformRequest(transformedRequest);
            const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);
            // Run both in parallel. The fetch is quite expensive, so we have plenty of time to
            // calculate the requestId locally.
            const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
            const [response, requestId] = await Promise.all([request, (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(submit)]);
            const responseBuffer = await response.arrayBuffer();
            const responseBody = (response.status === 200 && responseBuffer.byteLength > 0 ? _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(responseBuffer) : null);
            return {
                requestId,
                response: {
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    body: responseBody,
                    headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),
                },
            };
        }
        async _requestAndRetry(request, tries = 0) {
            let response;
            try {
                response = await request();
            }
            catch (error) {
                if (this._retryTimes > tries) {
                    console.warn(`Caught exception while attempting to make request:\n` +
                        `  ${error}\n` +
                        `  Retrying request.`);
                    return await this._requestAndRetry(request, tries + 1);
                }
                throw error;
            }
            if (response.ok) {
                return response;
            }
            const responseText = await response.clone().text();
            const errorMessage = `Server returned an error:\n` +
                `  Code: ${response.status} (${response.statusText})\n` +
                `  Body: ${responseText}\n`;
            if (this._retryTimes > tries) {
                console.warn(errorMessage + `  Retrying request.`);
                return await this._requestAndRetry(request, tries + 1);
            }
            throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError(errorMessage, {
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),
            });
        }
        async query(canisterId, fields, identity) {
            const makeQuery = async () => {
                const id = await (identity !== undefined ? await identity : await this._identity);
                if (!id) {
                    throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
                }
                const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);
                const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();
                const request = {
                    request_type: "query" /* ReadRequestType.Query */,
                    canister_id: canister,
                    method_name: fields.methodName,
                    arg: fields.arg,
                    sender,
                    ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
                };
                const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(request);
                // TODO: remove this any. This can be a Signed or UnSigned request.
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let transformedRequest = await this._transform({
                    request: {
                        method: 'POST',
                        headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                    },
                    endpoint: "read" /* Endpoint.Query */,
                    body: request,
                });
                // Apply transform for identity.
                transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));
                const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);
                const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
                const queryResponse = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());
                return Object.assign(Object.assign({}, queryResponse), { httpDetails: {
                        ok: response.ok,
                        status: response.status,
                        statusText: response.statusText,
                        headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),
                    }, requestId });
            };
            const getSubnetStatus = async () => {
                if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                    return undefined;
                }
                const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
                if (subnetStatus) {
                    return subnetStatus;
                }
                await this.fetchSubnetKeys(canisterId.toString());
                return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
            };
            // Make query and fetch subnet keys in parallel
            const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);
            // Skip verification if the user has disabled it
            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                return query;
            }
            try {
                return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, query, subnetStatus);
            }
            catch (_) {
                // In case the node signatures have changed, refresh the subnet keys and try again
                console.warn('Query response verification failed. Retrying with fresh subnet keys.');
                __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").delete(canisterId.toString());
                await this.fetchSubnetKeys(canisterId.toString());
                const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
                if (!updatedSubnetStatus) {
                    throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');
                }
                return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, query, updatedSubnetStatus);
            }
        }
        async createReadStateRequest(fields, identity) {
            const id = await (identity !== undefined ? await identity : await this._identity);
            if (!id) {
                throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
            }
            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();
            // TODO: remove this any. This can be a Signed or UnSigned request.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const transformedRequest = await this._transform({
                request: {
                    method: 'POST',
                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                },
                endpoint: "read_state" /* Endpoint.ReadState */,
                body: {
                    request_type: "read_state" /* ReadRequestType.ReadState */,
                    paths: fields.paths,
                    sender,
                    ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
                },
            });
            // Apply transform for identity.
            return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);
        }
        async readState(canisterId, fields, identity, 
        // eslint-disable-next-line
        request) {
            const canister = typeof canisterId === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId) : canisterId;
            const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));
            const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);
            // TODO - https://dfinity.atlassian.net/browse/SDK-1092
            const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
            if (!response.ok) {
                throw new Error(`Server returned an error:\n` +
                    `  Code: ${response.status} (${response.statusText})\n` +
                    `  Body: ${await response.text()}\n`);
            }
            return _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());
        }
        /**
         * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request
         * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default
         */
        async syncTime(canisterId) {
            const CanisterStatus = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../canisterStatus */ "./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js"));
            const callTime = Date.now();
            try {
                if (!canisterId) {
                    console.log('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');
                }
                const status = await CanisterStatus.request({
                    // Fall back with canisterId of the ICP Ledger
                    canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),
                    agent: this,
                    paths: ['time'],
                });
                const replicaTime = status.get('time');
                if (replicaTime) {
                    this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
                }
            }
            catch (error) {
                console.error('Caught exception while attempting to sync time:', error);
            }
        }
        async status() {
            const headers = this._credentials
                ? {
                    Authorization: 'Basic ' + btoa(this._credentials),
                }
                : {};
            const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
            return _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());
        }
        async fetchRootKey() {
            if (!this._rootKeyFetched) {
                // Hex-encoded version of the replica root key
                this.rootKey = (await this.status()).root_key;
                this._rootKeyFetched = true;
            }
            return this.rootKey;
        }
        invalidateIdentity() {
            this._identity = null;
        }
        replaceIdentity(identity) {
            this._identity = Promise.resolve(identity);
        }
        async fetchSubnetKeys(canisterId) {
            const effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);
            const response = await (0,_canisterStatus__WEBPACK_IMPORTED_MODULE_9__.request)({
                canisterId: effectiveCanisterId,
                paths: ['subnet'],
                agent: this,
            });
            const subnetResponse = response.get('subnet');
            if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {
                __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").set(effectiveCanisterId.toText(), subnetResponse);
                return subnetResponse;
            }
            // If the subnet status is not returned, return undefined
            return undefined;
        }
        _transform(request) {
            let p = Promise.resolve(request);
            if (request.endpoint === "call" /* Endpoint.Call */) {
                for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f")) {
                    p = p.then(r => fn(r).then(r2 => r2 || r));
                }
            }
            else {
                for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f")) {
                    p = p.then(r => fn(r).then(r2 => r2 || r));
                }
            }
            return p;
        }
    }
    _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap();
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js ***!
      \**********************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Expiry: () => (/* binding */ Expiry),
    /* harmony export */   httpHeadersTransform: () => (/* binding */ httpHeadersTransform),
    /* harmony export */   makeExpiryTransform: () => (/* binding */ makeExpiryTransform),
    /* harmony export */   makeNonceTransform: () => (/* binding */ makeNonceTransform)
    /* harmony export */ });
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ "./node_modules/simple-cbor/src/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/@dfinity/agent/lib/esm/agent/http/types.js");
    
    
    
    const NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);
    const REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;
    class Expiry {
        constructor(deltaInMSec) {
            // Use bigint because it can overflow the maximum number allowed in a double float.
            const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *
                NANOSECONDS_PER_MILLISECONDS;
            // round down to the nearest second
            const ingress_as_seconds = raw_value / BigInt(1000000000);
            // round down to nearest minute
            const ingress_as_minutes = ingress_as_seconds / BigInt(60);
            const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1000000000);
            this._value = rounded_down_nanos;
        }
        toCBOR() {
            // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).
            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.u64(this._value.toString(16), 16);
        }
        toHash() {
            return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._value);
        }
    }
    /**
     * Create a Nonce transform, which takes a function that returns a Buffer, and adds it
     * as the nonce to every call requests.
     * @param nonceFn A function that returns a buffer. By default uses a semi-random method.
     */
    function makeNonceTransform(nonceFn = _types__WEBPACK_IMPORTED_MODULE_2__.makeNonce) {
        return async (request) => {
            // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.
            const headers = request.request.headers;
            // TODO: uncomment this when the http proxy supports it.
            // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));
            request.request.headers = headers;
            // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.
            if (request.endpoint === "call" /* Endpoint.Call */) {
                request.body.nonce = nonceFn();
            }
        };
    }
    /**
     * Create a transform that adds a delay (by default 5 minutes) to the expiry.
     *
     * @param delayInMilliseconds The delay to add to the call time, in milliseconds.
     */
    function makeExpiryTransform(delayInMilliseconds) {
        return async (request) => {
            request.body.ingress_expiry = new Expiry(delayInMilliseconds);
        };
    }
    /**
     * Maps the default fetch headers field to the serializable HttpHeaderField.
     *
     * @param headers Fetch definition of the headers type
     * @returns array of header fields
     */
    function httpHeadersTransform(headers) {
        const headerFields = [];
        headers.forEach((value, key) => {
            headerFields.push([key, value]);
        });
        return headerFields;
    }
    //# sourceMappingURL=transforms.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/http/types.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/types.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   SubmitRequestType: () => (/* binding */ SubmitRequestType),
    /* harmony export */   makeNonce: () => (/* binding */ makeNonce)
    /* harmony export */ });
    /* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/random */ "./node_modules/@dfinity/agent/lib/esm/utils/random.js");
    
    // The types of values allowed in the `request_type` field for submit requests.
    var SubmitRequestType;
    (function (SubmitRequestType) {
        SubmitRequestType["Call"] = "call";
    })(SubmitRequestType || (SubmitRequestType = {}));
    /**
     * Create a random Nonce, based on random values
     */
    function makeNonce() {
        // Encode 128 bits.
        const buffer = new ArrayBuffer(16);
        const view = new DataView(buffer);
        const rand1 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();
        const rand2 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();
        const rand3 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();
        const rand4 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();
        view.setUint32(0, rand1);
        view.setUint32(4, rand2);
        view.setUint32(8, rand3);
        view.setUint32(12, rand4);
        return buffer;
    }
    //# sourceMappingURL=types.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/index.js":
    /*!************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/index.js ***!
      \************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Expiry: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.Expiry),
    /* harmony export */   HttpAgent: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.HttpAgent),
    /* harmony export */   IdentityInvalidError: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.IdentityInvalidError),
    /* harmony export */   ProxyAgent: () => (/* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyAgent),
    /* harmony export */   ProxyMessageKind: () => (/* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyMessageKind),
    /* harmony export */   ProxyStubAgent: () => (/* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyStubAgent),
    /* harmony export */   ReplicaRejectCode: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.ReplicaRejectCode),
    /* harmony export */   RequestStatusResponseStatus: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus),
    /* harmony export */   getDefaultAgent: () => (/* binding */ getDefaultAgent),
    /* harmony export */   httpHeadersTransform: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.httpHeadersTransform),
    /* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform),
    /* harmony export */   makeNonce: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonce),
    /* harmony export */   makeNonceTransform: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform)
    /* harmony export */ });
    /* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./node_modules/@dfinity/agent/lib/esm/agent/api.js");
    /* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http */ "./node_modules/@dfinity/agent/lib/esm/agent/http/index.js");
    /* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proxy */ "./node_modules/@dfinity/agent/lib/esm/agent/proxy.js");
    
    
    
    function getDefaultAgent() {
        const agent = typeof window === 'undefined'
            ? typeof __webpack_require__.g === 'undefined'
                ? typeof self === 'undefined'
                    ? undefined
                    : self.ic.agent
                : __webpack_require__.g.ic.agent
            : window.ic.agent;
        if (!agent) {
            throw new Error('No Agent could be found.');
        }
        return agent;
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/agent/proxy.js":
    /*!************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/agent/proxy.js ***!
      \************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ProxyAgent: () => (/* binding */ ProxyAgent),
    /* harmony export */   ProxyMessageKind: () => (/* binding */ ProxyMessageKind),
    /* harmony export */   ProxyStubAgent: () => (/* binding */ ProxyStubAgent)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    
    var ProxyMessageKind;
    (function (ProxyMessageKind) {
        ProxyMessageKind["Error"] = "err";
        ProxyMessageKind["GetPrincipal"] = "gp";
        ProxyMessageKind["GetPrincipalResponse"] = "gpr";
        ProxyMessageKind["Query"] = "q";
        ProxyMessageKind["QueryResponse"] = "qr";
        ProxyMessageKind["Call"] = "c";
        ProxyMessageKind["CallResponse"] = "cr";
        ProxyMessageKind["ReadState"] = "rs";
        ProxyMessageKind["ReadStateResponse"] = "rsr";
        ProxyMessageKind["Status"] = "s";
        ProxyMessageKind["StatusResponse"] = "sr";
    })(ProxyMessageKind || (ProxyMessageKind = {}));
    // A Stub Agent that forwards calls to another Agent implementation.
    class ProxyStubAgent {
        constructor(_frontend, _agent) {
            this._frontend = _frontend;
            this._agent = _agent;
        }
        onmessage(msg) {
            switch (msg.type) {
                case ProxyMessageKind.GetPrincipal:
                    this._agent.getPrincipal().then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.GetPrincipalResponse,
                            response: response.toText(),
                        });
                    });
                    break;
                case ProxyMessageKind.Query:
                    this._agent.query(...msg.args).then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.QueryResponse,
                            response,
                        });
                    });
                    break;
                case ProxyMessageKind.Call:
                    this._agent.call(...msg.args).then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.CallResponse,
                            response,
                        });
                    });
                    break;
                case ProxyMessageKind.ReadState:
                    this._agent.readState(...msg.args).then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.ReadStateResponse,
                            response,
                        });
                    });
                    break;
                case ProxyMessageKind.Status:
                    this._agent.status().then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.StatusResponse,
                            response,
                        });
                    });
                    break;
                default:
                    throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
            }
        }
    }
    // An Agent that forwards calls to a backend. The calls are serialized
    class ProxyAgent {
        constructor(_backend) {
            this._backend = _backend;
            this._nextId = 0;
            this._pendingCalls = new Map();
            this.rootKey = null;
        }
        onmessage(msg) {
            const id = msg.id;
            const maybePromise = this._pendingCalls.get(id);
            if (!maybePromise) {
                throw new Error('A proxy get the same message twice...');
            }
            this._pendingCalls.delete(id);
            const [resolve, reject] = maybePromise;
            switch (msg.type) {
                case ProxyMessageKind.Error:
                    return reject(msg.error);
                case ProxyMessageKind.GetPrincipalResponse:
                case ProxyMessageKind.CallResponse:
                case ProxyMessageKind.QueryResponse:
                case ProxyMessageKind.ReadStateResponse:
                case ProxyMessageKind.StatusResponse:
                    return resolve(msg.response);
                default:
                    throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
            }
        }
        async getPrincipal() {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.GetPrincipal,
            }).then(principal => {
                if (typeof principal !== 'string') {
                    throw new Error('Invalid principal received.');
                }
                return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(principal);
            });
        }
        readState(canisterId, fields) {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.ReadState,
                args: [canisterId.toString(), fields],
            });
        }
        call(canisterId, fields) {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.Call,
                args: [canisterId.toString(), fields],
            });
        }
        status() {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.Status,
            });
        }
        query(canisterId, fields) {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.Query,
                args: [canisterId.toString(), fields],
            });
        }
        async _sendAndWait(msg) {
            return new Promise((resolve, reject) => {
                this._pendingCalls.set(msg.id, [resolve, reject]);
                this._backend(msg);
            });
        }
        async fetchRootKey() {
            // Hex-encoded version of the replica root key
            const rootKey = (await this.status()).root_key;
            this.rootKey = rootKey;
            return rootKey;
        }
    }
    //# sourceMappingURL=proxy.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/auth.js":
    /*!*****************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/auth.js ***!
      \*****************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   AnonymousIdentity: () => (/* binding */ AnonymousIdentity),
    /* harmony export */   SignIdentity: () => (/* binding */ SignIdentity),
    /* harmony export */   createIdentityDescriptor: () => (/* binding */ createIdentityDescriptor)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request_id */ "./node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    
    
    
    const domainSeparator = new TextEncoder().encode('\x0Aic-request');
    /**
     * An Identity that can sign blobs.
     */
    class SignIdentity {
        /**
         * Get the principal represented by this identity. Normally should be a
         * `Principal.selfAuthenticating()`.
         */
        getPrincipal() {
            if (!this._principal) {
                this._principal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
            }
            return this._principal;
        }
        /**
         * Transform a request into a signed version of the request. This is done last
         * after the transforms on the body of a request. The returned object can be
         * anything, but must be serializable to CBOR.
         * @param request - internet computer request to transform
         */
        async transformRequest(request) {
            const { body } = request, fields = __rest(request, ["body"]);
            const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_1__.requestIdOf)(body);
            return Object.assign(Object.assign({}, fields), { body: {
                    content: body,
                    sender_pubkey: this.getPublicKey().toDer(),
                    sender_sig: await this.sign((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(domainSeparator, requestId)),
                } });
        }
    }
    class AnonymousIdentity {
        getPrincipal() {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();
        }
        async transformRequest(request) {
            return Object.assign(Object.assign({}, request), { body: { content: request.body } });
        }
    }
    /**
     * Create an IdentityDescriptor from a @dfinity/identity Identity
     * @param identity - identity describe in returned descriptor
     */
    function createIdentityDescriptor(identity) {
        const identityIndicator = 'getPublicKey' in identity
            ? { type: 'PublicKeyIdentity', publicKey: (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(identity.getPublicKey().toDer()) }
            : { type: 'AnonymousIdentity' };
        return identityIndicator;
    }
    //# sourceMappingURL=auth.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js":
    /*!*********************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js ***!
      \*********************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   encodePath: () => (/* binding */ encodePath),
    /* harmony export */   fetchNodeKeys: () => (/* binding */ fetchNodeKeys),
    /* harmony export */   request: () => (/* binding */ request)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./node_modules/@dfinity/agent/lib/esm/errors.js");
    /* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../certificate */ "./node_modules/@dfinity/agent/lib/esm/certificate.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cbor */ "./node_modules/@dfinity/agent/lib/esm/cbor.js");
    /* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/leb */ "./node_modules/@dfinity/agent/lib/esm/utils/leb.js");
    /** @module CanisterStatus */
    
    
    
    
    
    
    /**
     *
     * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}
     * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}
     * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private
     * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}
     * @returns {Status} object populated with data from the requested paths
     * @example
     * const status = await canisterStatus({
     *   paths: ['controllers', 'candid'],
     *   ...options
     * });
     *
     * const controllers = status.get('controllers');
     */
    const request = async (options) => {
        const { agent, paths } = options;
        const canisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.canisterId);
        const uniquePaths = [...new Set(paths)];
        // Map path options to their correct formats
        const encodedPaths = uniquePaths.map(path => {
            return encodePath(path, canisterId);
        });
        const status = new Map();
        const promises = uniquePaths.map((path, index) => {
            return (async () => {
                var _a;
                try {
                    const response = await agent.readState(canisterId, {
                        paths: [encodedPaths[index]],
                    });
                    const cert = await _certificate__WEBPACK_IMPORTED_MODULE_2__.Certificate.create({
                        certificate: response.certificate,
                        rootKey: agent.rootKey,
                        canisterId: canisterId,
                    });
                    const lookup = (cert, path) => {
                        if (path === 'subnet') {
                            const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);
                            return {
                                path: path,
                                data,
                            };
                        }
                        else {
                            return {
                                path: path,
                                data: (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookupResultToBuffer)(cert.lookup(encodePath(path, canisterId))),
                            };
                        }
                    };
                    // must pass in the rootKey if we have no delegation
                    const { path, data } = lookup(cert, uniquePaths[index]);
                    if (!data) {
                        // Typically, the cert lookup will throw
                        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
                        if (typeof path === 'string') {
                            status.set(path, null);
                        }
                        else {
                            status.set(path.key, null);
                        }
                    }
                    else {
                        switch (path) {
                            case 'time': {
                                status.set(path, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeTime)(data));
                                break;
                            }
                            case 'controllers': {
                                status.set(path, decodeControllers(data));
                                break;
                            }
                            case 'module_hash': {
                                status.set(path, decodeHex(data));
                                break;
                            }
                            case 'subnet': {
                                status.set(path, data);
                                break;
                            }
                            case 'candid': {
                                status.set(path, new TextDecoder().decode(data));
                                break;
                            }
                            default: {
                                // Check for CustomPath signature
                                if (typeof path !== 'string' && 'key' in path && 'path' in path) {
                                    switch (path.decodeStrategy) {
                                        case 'raw':
                                            status.set(path.key, data);
                                            break;
                                        case 'leb128': {
                                            status.set(path.key, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeLeb128)(data));
                                            break;
                                        }
                                        case 'cbor': {
                                            status.set(path.key, decodeCbor(data));
                                            break;
                                        }
                                        case 'hex': {
                                            status.set(path.key, decodeHex(data));
                                            break;
                                        }
                                        case 'utf-8': {
                                            status.set(path.key, decodeUtf8(data));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (error) {
                    // Break on signature verification errors
                    if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {
                        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(error.message);
                    }
                    if (typeof path !== 'string' && 'key' in path && 'path' in path) {
                        status.set(path.key, null);
                    }
                    else {
                        status.set(path, null);
                    }
                    console.group();
                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
                    console.warn(error);
                    console.groupEnd();
                }
            })();
        });
        // Fetch all values separately, as each option can fail
        await Promise.all(promises);
        return status;
    };
    const fetchNodeKeys = (certificate, canisterId, root_key) => {
        if (!canisterId._isPrincipal) {
            throw new Error('Invalid canisterId');
        }
        const cert = _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(new Uint8Array(certificate));
        const tree = cert.tree;
        let delegation = cert.delegation;
        let subnetId;
        if (delegation && delegation.subnet_id) {
            subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));
        }
        // On local replica, with System type subnet, there is no delegation
        else if (!delegation && typeof root_key !== 'undefined') {
            subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(root_key));
            delegation = {
                subnet_id: subnetId.toUint8Array(),
                certificate: new ArrayBuffer(0),
            };
        }
        // otherwise use default NNS subnet id
        else {
            subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(_dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());
            delegation = {
                subnet_id: subnetId.toUint8Array(),
                certificate: new ArrayBuffer(0),
            };
        }
        const canisterInRange = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.check_canister_ranges)({ canisterId, subnetId, tree });
        if (!canisterInRange) {
            throw new Error('Canister not in range');
        }
        const nodeTree = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['subnet', delegation === null || delegation === void 0 ? void 0 : delegation.subnet_id, 'node'], tree);
        const nodeForks = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.flatten_forks)(nodeTree);
        nodeForks.length;
        const nodeKeys = new Map();
        nodeForks.forEach(fork => {
            Object.getPrototypeOf(new Uint8Array(fork[1]));
            const node_id = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(new Uint8Array(fork[1])).toText();
            const derEncodedPublicKey = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['public_key'], fork[2]);
            if (derEncodedPublicKey.byteLength !== 44) {
                throw new Error('Invalid public key length');
            }
            else {
                nodeKeys.set(node_id, derEncodedPublicKey);
            }
        });
        return {
            subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),
            nodeKeys,
        };
    };
    const encodePath = (path, canisterId) => {
        const encoder = new TextEncoder();
        const encode = (arg) => {
            return new DataView(encoder.encode(arg).buffer).buffer;
        };
        const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;
        switch (path) {
            case 'time':
                return [encode('time')];
            case 'controllers':
                return [encode('canister'), canisterBuffer, encode('controllers')];
            case 'module_hash':
                return [encode('canister'), canisterBuffer, encode('module_hash')];
            case 'subnet':
                return [encode('subnet')];
            case 'candid':
                return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];
            default: {
                // Check for CustomPath signature
                if ('key' in path && 'path' in path) {
                    // For simplified metadata queries
                    if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {
                        const metaPath = path.path;
                        const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;
                        return [encode('canister'), canisterBuffer, encode('metadata'), encoded];
                        // For non-metadata, return the provided custompath
                    }
                    else {
                        return path['path'];
                    }
                }
            }
        }
        throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);
    };
    const decodeHex = (buf) => {
        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(buf);
    };
    const decodeCbor = (buf) => {
        return _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(buf);
    };
    const decodeUtf8 = (buf) => {
        return new TextDecoder().decode(buf);
    };
    // Controllers are CBOR-encoded buffers
    const decodeControllers = (buf) => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const controllersRaw = decodeCbor(buf);
        return controllersRaw.map((buf) => {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(buf));
        });
    };
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/canisters/asset.js":
    /*!****************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/canisters/asset.js ***!
      \****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   createAssetCanisterActor: () => (/* binding */ createAssetCanisterActor)
    /* harmony export */ });
    /* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actor */ "./node_modules/@dfinity/agent/lib/esm/actor.js");
    /* harmony import */ var _asset_idl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset_idl */ "./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js");
    
    
    /**
     * Create a management canister actor.
     * @param config
     */
    function createAssetCanisterActor(config) {
        return _actor__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_asset_idl__WEBPACK_IMPORTED_MODULE_1__["default"], config);
    }
    //# sourceMappingURL=asset.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js":
    /*!********************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js ***!
      \********************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /**
     * This file is generated from the candid for asset management.
     */
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (({ IDL }) => {
        return IDL.Service({
            retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ['query']),
            store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], []),
        });
    });
    //# sourceMappingURL=asset_idl.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js ***!
      \*************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /**
     * This file is generated from the candid for asset management.
     */
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (({ IDL }) => {
        const canister_id = IDL.Principal;
        const definite_canister_settings = IDL.Record({
            controllers: IDL.Vec(IDL.Principal),
            freezing_threshold: IDL.Nat,
            memory_allocation: IDL.Nat,
            compute_allocation: IDL.Nat,
        });
        const canister_settings = IDL.Record({
            controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
            freezing_threshold: IDL.Opt(IDL.Nat),
            memory_allocation: IDL.Opt(IDL.Nat),
            compute_allocation: IDL.Opt(IDL.Nat),
        });
        const wasm_module = IDL.Vec(IDL.Nat8);
        return IDL.Service({
            canister_status: IDL.Func([IDL.Record({ canister_id: canister_id })], [
                IDL.Record({
                    status: IDL.Variant({
                        stopped: IDL.Null,
                        stopping: IDL.Null,
                        running: IDL.Null,
                    }),
                    memory_size: IDL.Nat,
                    cycles: IDL.Nat,
                    settings: definite_canister_settings,
                    module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
                }),
            ], []),
            create_canister: IDL.Func([IDL.Record({ settings: IDL.Opt(canister_settings) })], [IDL.Record({ canister_id: canister_id })], []),
            delete_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),
            deposit_cycles: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),
            install_code: IDL.Func([
                IDL.Record({
                    arg: IDL.Vec(IDL.Nat8),
                    wasm_module: wasm_module,
                    mode: IDL.Variant({
                        reinstall: IDL.Null,
                        upgrade: IDL.Null,
                        install: IDL.Null,
                    }),
                    canister_id: canister_id,
                }),
            ], [], []),
            provisional_create_canister_with_cycles: IDL.Func([
                IDL.Record({
                    settings: IDL.Opt(canister_settings),
                    amount: IDL.Opt(IDL.Nat),
                }),
            ], [IDL.Record({ canister_id: canister_id })], []),
            provisional_top_up_canister: IDL.Func([IDL.Record({ canister_id: canister_id, amount: IDL.Nat })], [], []),
            raw_rand: IDL.Func([], [IDL.Vec(IDL.Nat8)], []),
            start_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),
            stop_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),
            uninstall_code: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),
            update_settings: IDL.Func([
                IDL.Record({
                    canister_id: IDL.Principal,
                    settings: canister_settings,
                }),
            ], [], []),
        });
    });
    //# sourceMappingURL=management_idl.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/cbor.js":
    /*!*****************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/cbor.js ***!
      \*****************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   CborTag: () => (/* binding */ CborTag),
    /* harmony export */   decode: () => (/* binding */ decode),
    /* harmony export */   encode: () => (/* binding */ encode)
    /* harmony export */ });
    /* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! borc */ "./node_modules/borc/src/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ "./node_modules/simple-cbor/src/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    // This file is based on:
    // https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses
    
    
    
    
    // We are using hansl/simple-cbor for CBOR serialization, to avoid issues with
    // encoding the uint64 values that the HTTP handler of the client expects for
    // canister IDs. However, simple-cbor does not yet provide deserialization so
    // we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR
    // decoder.
    class PrincipalEncoder {
        get name() {
            return 'Principal';
        }
        get priority() {
            return 0;
        }
        match(value) {
            return value && value._isPrincipal === true;
        }
        encode(v) {
            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(v.toUint8Array());
        }
    }
    class BufferEncoder {
        get name() {
            return 'Buffer';
        }
        get priority() {
            return 1;
        }
        match(value) {
            return value instanceof ArrayBuffer || ArrayBuffer.isView(value);
        }
        encode(v) {
            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(new Uint8Array(v));
        }
    }
    class BigIntEncoder {
        get name() {
            return 'BigInt';
        }
        get priority() {
            return 1;
        }
        match(value) {
            return typeof value === `bigint`;
        }
        encode(v) {
            // Always use a bigint encoding.
            if (v > BigInt(0)) {
                return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(2, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)(v.toString(16))));
            }
            else {
                return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(3, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)((BigInt('-1') * v).toString(16))));
            }
        }
    }
    const serializer = simple_cbor__WEBPACK_IMPORTED_MODULE_1__.SelfDescribeCborSerializer.withDefaultEncoders(true);
    serializer.addEncoder(new PrincipalEncoder());
    serializer.addEncoder(new BufferEncoder());
    serializer.addEncoder(new BigIntEncoder());
    var CborTag;
    (function (CborTag) {
        CborTag[CborTag["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
        CborTag[CborTag["Semantic"] = 55799] = "Semantic";
    })(CborTag || (CborTag = {}));
    /**
     * Encode a JavaScript value into CBOR.
     */
    function encode(value) {
        return serializer.serialize(value);
    }
    function decodePositiveBigInt(buf) {
        const len = buf.byteLength;
        let res = BigInt(0);
        for (let i = 0; i < len; i++) {
            res = res * BigInt(0x100) + BigInt(buf[i]);
        }
        return res;
    }
    // A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.
    class Uint8ArrayDecoder extends borc__WEBPACK_IMPORTED_MODULE_0__.Decoder {
        createByteString(raw) {
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...raw);
        }
        createByteStringFromHeap(start, end) {
            if (start === end) {
                return new ArrayBuffer(0);
            }
            return new Uint8Array(this._heap.slice(start, end));
        }
    }
    function decode(input) {
        const buffer = new Uint8Array(input);
        const decoder = new Uint8ArrayDecoder({
            size: buffer.byteLength,
            tags: {
                // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).
                2: val => decodePositiveBigInt(val),
                3: val => -decodePositiveBigInt(val),
                [CborTag.Semantic]: (value) => value,
            },
        });
        return decoder.decodeFirst(buffer);
    }
    //# sourceMappingURL=cbor.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/certificate.js":
    /*!************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/certificate.js ***!
      \************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Certificate: () => (/* binding */ Certificate),
    /* harmony export */   CertificateVerificationError: () => (/* binding */ CertificateVerificationError),
    /* harmony export */   NodeId: () => (/* binding */ NodeId),
    /* harmony export */   check_canister_ranges: () => (/* binding */ check_canister_ranges),
    /* harmony export */   flatten_forks: () => (/* binding */ flatten_forks),
    /* harmony export */   hashTreeToString: () => (/* binding */ hashTreeToString),
    /* harmony export */   lookupResultToBuffer: () => (/* binding */ lookupResultToBuffer),
    /* harmony export */   lookup_path: () => (/* binding */ lookup_path),
    /* harmony export */   reconstruct: () => (/* binding */ reconstruct)
    /* harmony export */ });
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor */ "./node_modules/@dfinity/agent/lib/esm/cbor.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ "./node_modules/@dfinity/agent/lib/esm/errors.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request_id */ "./node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/bls */ "./node_modules/@dfinity/agent/lib/esm/utils/bls.js");
    /* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/leb */ "./node_modules/@dfinity/agent/lib/esm/utils/leb.js");
    
    
    
    
    
    
    
    /**
     * A certificate may fail verification with respect to the provided public key
     */
    class CertificateVerificationError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {
        constructor(reason) {
            super(`Invalid certificate: ${reason}`);
        }
    }
    const NodeId = {
        Empty: 0,
        Fork: 1,
        Labeled: 2,
        Leaf: 3,
        Pruned: 4,
    };
    
    /**
     * Make a human readable string out of a hash tree.
     * @param tree
     */
    function hashTreeToString(tree) {
        const indent = (s) => s
            .split('\n')
            .map(x => '  ' + x)
            .join('\n');
        function labelToString(label) {
            const decoder = new TextDecoder(undefined, { fatal: true });
            try {
                return JSON.stringify(decoder.decode(label));
            }
            catch (e) {
                return `data(...${label.byteLength} bytes)`;
            }
        }
        switch (tree[0]) {
            case NodeId.Empty:
                return '()';
            case NodeId.Fork: {
                if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {
                    const left = hashTreeToString(tree[1]);
                    const right = hashTreeToString(tree[2]);
                    return `sub(\n left:\n${indent(left)}\n---\n right:\n${indent(right)}\n)`;
                }
                else {
                    throw new Error('Invalid tree structure for fork');
                }
            }
            case NodeId.Labeled: {
                if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {
                    const label = labelToString(tree[1]);
                    const sub = hashTreeToString(tree[2]);
                    return `label(\n label:\n${indent(label)}\n sub:\n${indent(sub)}\n)`;
                }
                else {
                    throw new Error('Invalid tree structure for labeled');
                }
            }
            case NodeId.Leaf: {
                if (!tree[1]) {
                    throw new Error('Invalid tree structure for leaf');
                }
                else if (Array.isArray(tree[1])) {
                    return JSON.stringify(tree[1]);
                }
                return `leaf(...${tree[1].byteLength} bytes)`;
            }
            case NodeId.Pruned: {
                if (!tree[1]) {
                    throw new Error('Invalid tree structure for pruned');
                }
                else if (Array.isArray(tree[1])) {
                    return JSON.stringify(tree[1]);
                }
                return `pruned(${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(new Uint8Array(tree[1]))}`;
            }
            default: {
                return `unknown(${JSON.stringify(tree[0])})`;
            }
        }
    }
    function isBufferEqual(a, b) {
        if (a.byteLength !== b.byteLength) {
            return false;
        }
        const a8 = new Uint8Array(a);
        const b8 = new Uint8Array(b);
        for (let i = 0; i < a8.length; i++) {
            if (a8[i] !== b8[i]) {
                return false;
            }
        }
        return true;
    }
    class Certificate {
        constructor(certificate, _rootKey, _canisterId, _blsVerify, 
        // Default to 5 minutes
        _maxAgeInMinutes = 5) {
            this._rootKey = _rootKey;
            this._canisterId = _canisterId;
            this._blsVerify = _blsVerify;
            this._maxAgeInMinutes = _maxAgeInMinutes;
            this.cert = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(new Uint8Array(certificate));
        }
        /**
         * Create a new instance of a certificate, automatically verifying it. Throws a
         * CertificateVerificationError if the certificate cannot be verified.
         * @constructs  Certificate
         * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}
         * @param {ArrayBuffer} options.certificate The bytes of the certificate
         * @param {ArrayBuffer} options.rootKey The root key to verify against
         * @param {Principal} options.canisterId The effective or signing canister ID
         * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.
         * @throws {CertificateVerificationError}
         */
        static async create(options) {
            const cert = Certificate.createUnverified(options);
            await cert.verify();
            return cert;
        }
        static createUnverified(options) {
            let blsVerify = options.blsVerify;
            if (!blsVerify) {
                blsVerify = _utils_bls__WEBPACK_IMPORTED_MODULE_5__.blsVerify;
            }
            return new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);
        }
        lookup(path) {
            // constrain the type of the result, so that empty HashTree is undefined
            return lookupResultToBuffer(lookup_path(path, this.cert.tree));
        }
        lookup_label(label) {
            return this.lookup([label]);
        }
        async verify() {
            const rootHash = await reconstruct(this.cert.tree);
            const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
            const sig = this.cert.signature;
            const key = extractDER(derKey);
            const msg = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-state-root'), rootHash);
            let sigVer = false;
            const lookupTime = this.lookup(['time']);
            if (!lookupTime) {
                // Should never happen - time is always present in IC certificates
                throw new CertificateVerificationError('Certificate does not contain a time');
            }
            const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;
            const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;
            const now = Date.now();
            const earliestCertificateTime = now - MAX_AGE_IN_MSEC;
            const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;
            const certTime = (0,_utils_leb__WEBPACK_IMPORTED_MODULE_6__.decodeTime)(lookupTime);
            if (certTime.getTime() < earliestCertificateTime) {
                throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +
                    certTime.toISOString() +
                    ' Current time: ' +
                    new Date(now).toISOString());
            }
            else if (certTime.getTime() > fiveMinutesFromNow) {
                throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' +
                    certTime.toISOString() +
                    ' Current time: ' +
                    new Date(now).toISOString());
            }
            try {
                sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
            }
            catch (err) {
                sigVer = false;
            }
            if (!sigVer) {
                throw new CertificateVerificationError('Signature verification failed');
            }
        }
        async _checkDelegationAndGetKey(d) {
            if (!d) {
                return this._rootKey;
            }
            const cert = await Certificate.createUnverified({
                certificate: d.certificate,
                rootKey: this._rootKey,
                canisterId: this._canisterId,
                blsVerify: this._blsVerify,
                // Do not check max age for delegation certificates
                maxAgeInMinutes: Infinity,
            });
            if (cert.cert.delegation) {
                throw new CertificateVerificationError('Delegation certificates cannot be nested');
            }
            await cert.verify();
            const canisterInRange = check_canister_ranges({
                canisterId: this._canisterId,
                subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(new Uint8Array(d.subnet_id)),
                tree: cert.cert.tree,
            });
            if (!canisterInRange) {
                throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);
            }
            const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);
            if (!publicKeyLookup) {
                throw new Error(`Could not find subnet key for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);
            }
            return publicKeyLookup;
        }
    }
    const DER_PREFIX = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.fromHex)('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');
    const KEY_LENGTH = 96;
    function extractDER(buf) {
        const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;
        if (buf.byteLength !== expectedLength) {
            throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
        }
        const prefix = buf.slice(0, DER_PREFIX.byteLength);
        if (!isBufferEqual(prefix, DER_PREFIX)) {
            throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);
        }
        return buf.slice(DER_PREFIX.byteLength);
    }
    /**
     * utility function to constrain the type of a path
     * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup
     * @returns ArrayBuffer or Undefined
     */
    function lookupResultToBuffer(result) {
        if (result instanceof ArrayBuffer) {
            return result;
        }
        else if (result instanceof Uint8Array) {
            return result.buffer;
        }
        return undefined;
    }
    /**
     * @param t
     */
    async function reconstruct(t) {
        switch (t[0]) {
            case NodeId.Empty:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)(domain_sep('ic-hashtree-empty'));
            case NodeId.Pruned:
                return t[1];
            case NodeId.Leaf:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-leaf'), t[1]));
            case NodeId.Labeled:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));
            case NodeId.Fork:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));
            default:
                throw new Error('unreachable');
        }
    }
    function domain_sep(s) {
        const len = new Uint8Array([s.length]);
        const str = new TextEncoder().encode(s);
        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(len, str);
    }
    /**
     * @param path
     * @param tree
     */
    function lookup_path(path, tree) {
        if (path.length === 0) {
            switch (tree[0]) {
                case NodeId.Leaf: {
                    // should not be undefined
                    if (!tree[1])
                        throw new Error('Invalid tree structure for leaf');
                    if (tree[1] instanceof ArrayBuffer) {
                        return tree[1];
                    }
                    else if (tree[1] instanceof Uint8Array) {
                        return tree[1].buffer;
                    }
                    else
                        return tree[1];
                }
                case NodeId.Fork: {
                    return tree;
                }
                default: {
                    return tree;
                }
            }
        }
        const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];
        const t = find_label(label, flatten_forks(tree));
        if (t) {
            return lookup_path(path.slice(1), t);
        }
    }
    /**
     * If the tree is a fork, flatten it into an array of trees
     * @param t - the tree to flatten
     * @returns HashTree[] - the flattened tree
     */
    function flatten_forks(t) {
        switch (t[0]) {
            case NodeId.Empty:
                return [];
            case NodeId.Fork:
                return flatten_forks(t[1]).concat(flatten_forks(t[2]));
            default:
                return [t];
        }
    }
    function find_label(l, trees) {
        if (trees.length === 0) {
            return undefined;
        }
        for (const t of trees) {
            if (t[0] === NodeId.Labeled) {
                const p = t[1];
                if (isBufferEqual(l, p)) {
                    return t[2];
                }
            }
        }
    }
    /**
     * Check if a canister falls within a range of canisters
     * @param canisterId Principal
     * @param ranges [Principal, Principal][]
     * @returns
     */
    function check_canister_ranges(params) {
        const { canisterId, subnetId, tree } = params;
        const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);
        if (!rangeLookup || !(rangeLookup instanceof ArrayBuffer)) {
            throw new Error(`Could not find canister ranges for subnet ${subnetId}`);
        }
        const ranges_arr = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(rangeLookup);
        const ranges = ranges_arr.map(v => [
            _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[0]),
            _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[1]),
        ]);
        const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));
        return canisterInRange;
    }
    //# sourceMappingURL=certificate.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/der.js":
    /*!****************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/der.js ***!
      \****************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   DER_COSE_OID: () => (/* binding */ DER_COSE_OID),
    /* harmony export */   ED25519_OID: () => (/* binding */ ED25519_OID),
    /* harmony export */   SECP256K1_OID: () => (/* binding */ SECP256K1_OID),
    /* harmony export */   decodeLen: () => (/* binding */ decodeLen),
    /* harmony export */   decodeLenBytes: () => (/* binding */ decodeLenBytes),
    /* harmony export */   encodeLen: () => (/* binding */ encodeLen),
    /* harmony export */   encodeLenBytes: () => (/* binding */ encodeLenBytes),
    /* harmony export */   unwrapDER: () => (/* binding */ unwrapDER),
    /* harmony export */   wrapDER: () => (/* binding */ wrapDER)
    /* harmony export */ });
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    
    const encodeLenBytes = (len) => {
        if (len <= 0x7f) {
            return 1;
        }
        else if (len <= 0xff) {
            return 2;
        }
        else if (len <= 0xffff) {
            return 3;
        }
        else if (len <= 0xffffff) {
            return 4;
        }
        else {
            throw new Error('Length too long (> 4 bytes)');
        }
    };
    const encodeLen = (buf, offset, len) => {
        if (len <= 0x7f) {
            buf[offset] = len;
            return 1;
        }
        else if (len <= 0xff) {
            buf[offset] = 0x81;
            buf[offset + 1] = len;
            return 2;
        }
        else if (len <= 0xffff) {
            buf[offset] = 0x82;
            buf[offset + 1] = len >> 8;
            buf[offset + 2] = len;
            return 3;
        }
        else if (len <= 0xffffff) {
            buf[offset] = 0x83;
            buf[offset + 1] = len >> 16;
            buf[offset + 2] = len >> 8;
            buf[offset + 3] = len;
            return 4;
        }
        else {
            throw new Error('Length too long (> 4 bytes)');
        }
    };
    const decodeLenBytes = (buf, offset) => {
        if (buf[offset] < 0x80)
            return 1;
        if (buf[offset] === 0x80)
            throw new Error('Invalid length 0');
        if (buf[offset] === 0x81)
            return 2;
        if (buf[offset] === 0x82)
            return 3;
        if (buf[offset] === 0x83)
            return 4;
        throw new Error('Length too long (> 4 bytes)');
    };
    const decodeLen = (buf, offset) => {
        const lenBytes = decodeLenBytes(buf, offset);
        if (lenBytes === 1)
            return buf[offset];
        else if (lenBytes === 2)
            return buf[offset + 1];
        else if (lenBytes === 3)
            return (buf[offset + 1] << 8) + buf[offset + 2];
        else if (lenBytes === 4)
            return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];
        throw new Error('Length too long (> 4 bytes)');
    };
    /**
     * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE
     */
    const DER_COSE_OID = Uint8Array.from([
        ...[0x30, 0x0c],
        ...[0x06, 0x0a],
        ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE
    ]);
    /**
     * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm
     */
    const ED25519_OID = Uint8Array.from([
        ...[0x30, 0x05],
        ...[0x06, 0x03],
        ...[0x2b, 0x65, 0x70], // id-Ed25519 OID
    ]);
    /**
     * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm
     */
    const SECP256K1_OID = Uint8Array.from([
        ...[0x30, 0x10],
        ...[0x06, 0x07],
        ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01],
        ...[0x06, 0x05],
        ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1
    ]);
    /**
     * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:
     * `SEQUENCE(oid, BITSTRING(payload))`
     *
     * @param payload The payload to encode as the bit string
     * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with
     */
    function wrapDER(payload, oid) {
        // The Bit String header needs to include the unused bit count byte in its length
        const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);
        const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;
        let offset = 0;
        const buf = new Uint8Array(1 + encodeLenBytes(len) + len);
        // Sequence
        buf[offset++] = 0x30;
        // Sequence Length
        offset += encodeLen(buf, offset, len);
        // OID
        buf.set(oid, offset);
        offset += oid.byteLength;
        // Bit String Header
        buf[offset++] = 0x03;
        offset += encodeLen(buf, offset, payload.byteLength + 1);
        // 0 padding
        buf[offset++] = 0x00;
        buf.set(new Uint8Array(payload), offset);
        return buf;
    }
    /**
     * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.
     *
     * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`
     *
     * @param derEncoded The DER encoded and tagged data
     * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID
     * @returns The unwrapped payload
     */
    const unwrapDER = (derEncoded, oid) => {
        let offset = 0;
        const expect = (n, msg) => {
            if (buf[offset++] !== n) {
                throw new Error('Expected: ' + msg);
            }
        };
        const buf = new Uint8Array(derEncoded);
        expect(0x30, 'sequence');
        offset += decodeLenBytes(buf, offset);
        if (!(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.bufEquals)(buf.slice(offset, offset + oid.byteLength), oid)) {
            throw new Error('Not the expected OID.');
        }
        offset += oid.byteLength;
        expect(0x03, 'bit string');
        const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding
        offset += decodeLenBytes(buf, offset);
        expect(0x00, '0 padding');
        const result = buf.slice(offset);
        if (payloadLen !== result.length) {
            throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);
        }
        return result;
    };
    //# sourceMappingURL=der.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/errors.js":
    /*!*******************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/errors.js ***!
      \*******************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   AgentError: () => (/* binding */ AgentError)
    /* harmony export */ });
    /**
     * An error that happens in the Agent. This is the root of all errors and should be used
     * everywhere in the Agent code (this package).
     *
     * @todo https://github.com/dfinity/agent-js/issues/420
     */
    class AgentError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            Object.setPrototypeOf(this, AgentError.prototype);
        }
    }
    //# sourceMappingURL=errors.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/fetch_candid.js":
    /*!*************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/fetch_candid.js ***!
      \*************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   fetchCandid: () => (/* binding */ fetchCandid)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canisterStatus/index */ "./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js");
    /* harmony import */ var _agent_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http */ "./node_modules/@dfinity/agent/lib/esm/agent/http/index.js");
    /* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actor */ "./node_modules/@dfinity/agent/lib/esm/actor.js");
    
    
    
    
    /**
     * Retrieves the Candid interface for the specified canister.
     *
     * @param agent The agent to use for the request (usually an `HttpAgent`)
     * @param canisterId A string corresponding to the canister ID
     * @returns Candid source code
     */
    async function fetchCandid(canisterId, agent) {
        if (!agent) {
            // Create an anonymous `HttpAgent` (adapted from Candid UI)
            agent = new _agent_http__WEBPACK_IMPORTED_MODULE_2__.HttpAgent();
            if (agent.isLocal()) {
                agent.fetchRootKey();
            }
        }
        // Attempt to use canister metadata
        const status = await _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__.request({
            agent,
            canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId),
            paths: ['candid'],
        });
        const candid = status.get('candid');
        if (candid) {
            return candid;
        }
        // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata
        const tmpHackInterface = ({ IDL }) => IDL.Service({
            __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),
        });
        const actor = _actor__WEBPACK_IMPORTED_MODULE_3__.Actor.createActor(tmpHackInterface, { agent, canisterId });
        return (await actor.__get_candid_interface_tmp_hack());
    }
    //# sourceMappingURL=fetch_candid.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/index.js":
    /*!******************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/index.js ***!
      \******************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ACTOR_METHOD_WITH_HTTP_DETAILS),
    /* harmony export */   Actor: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.Actor),
    /* harmony export */   ActorCallError: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ActorCallError),
    /* harmony export */   AnonymousIdentity: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.AnonymousIdentity),
    /* harmony export */   CanisterInstallMode: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.CanisterInstallMode),
    /* harmony export */   CanisterStatus: () => (/* reexport module object */ _canisterStatus__WEBPACK_IMPORTED_MODULE_15__),
    /* harmony export */   Cbor: () => (/* reexport module object */ _cbor__WEBPACK_IMPORTED_MODULE_16__),
    /* harmony export */   Certificate: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.Certificate),
    /* harmony export */   CertificateVerificationError: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.CertificateVerificationError),
    /* harmony export */   DER_COSE_OID: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.DER_COSE_OID),
    /* harmony export */   ED25519_OID: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.ED25519_OID),
    /* harmony export */   Ed25519PublicKey: () => (/* reexport safe */ _public_key__WEBPACK_IMPORTED_MODULE_9__.Ed25519PublicKey),
    /* harmony export */   Expiry: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.Expiry),
    /* harmony export */   HttpAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.HttpAgent),
    /* harmony export */   IdentityInvalidError: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.IdentityInvalidError),
    /* harmony export */   NodeId: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.NodeId),
    /* harmony export */   ProxyAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyAgent),
    /* harmony export */   ProxyMessageKind: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyMessageKind),
    /* harmony export */   ProxyStubAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyStubAgent),
    /* harmony export */   QueryCallRejectedError: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.QueryCallRejectedError),
    /* harmony export */   ReplicaRejectCode: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode),
    /* harmony export */   RequestStatusResponseStatus: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus),
    /* harmony export */   SECP256K1_OID: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.SECP256K1_OID),
    /* harmony export */   SignIdentity: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.SignIdentity),
    /* harmony export */   SubmitRequestType: () => (/* reexport safe */ _agent_http_types__WEBPACK_IMPORTED_MODULE_3__.SubmitRequestType),
    /* harmony export */   UpdateCallRejectedError: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.UpdateCallRejectedError),
    /* harmony export */   blsVerify: () => (/* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_11__.blsVerify),
    /* harmony export */   bufEquals: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.bufEquals),
    /* harmony export */   bufFromBufLike: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.bufFromBufLike),
    /* harmony export */   check_canister_ranges: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.check_canister_ranges),
    /* harmony export */   compare: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.compare),
    /* harmony export */   concat: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.concat),
    /* harmony export */   createAssetCanisterActor: () => (/* reexport safe */ _canisters_asset__WEBPACK_IMPORTED_MODULE_5__.createAssetCanisterActor),
    /* harmony export */   createIdentityDescriptor: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.createIdentityDescriptor),
    /* harmony export */   decodeLen: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.decodeLen),
    /* harmony export */   decodeLenBytes: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.decodeLenBytes),
    /* harmony export */   encodeLen: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.encodeLen),
    /* harmony export */   encodeLenBytes: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.encodeLenBytes),
    /* harmony export */   fetchCandid: () => (/* reexport safe */ _fetch_candid__WEBPACK_IMPORTED_MODULE_8__.fetchCandid),
    /* harmony export */   flatten_forks: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.flatten_forks),
    /* harmony export */   fromHex: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.fromHex),
    /* harmony export */   getDefaultAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent),
    /* harmony export */   getManagementCanister: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.getManagementCanister),
    /* harmony export */   hash: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hash),
    /* harmony export */   hashOfMap: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hashOfMap),
    /* harmony export */   hashTreeToString: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.hashTreeToString),
    /* harmony export */   hashValue: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hashValue),
    /* harmony export */   httpHeadersTransform: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.httpHeadersTransform),
    /* harmony export */   lookupResultToBuffer: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer),
    /* harmony export */   lookup_path: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.lookup_path),
    /* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform),
    /* harmony export */   makeNonce: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonce),
    /* harmony export */   makeNonceTransform: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform),
    /* harmony export */   polling: () => (/* reexport module object */ _polling__WEBPACK_IMPORTED_MODULE_14__),
    /* harmony export */   randomNumber: () => (/* reexport safe */ _utils_random__WEBPACK_IMPORTED_MODULE_13__.randomNumber),
    /* harmony export */   reconstruct: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.reconstruct),
    /* harmony export */   requestIdOf: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.requestIdOf),
    /* harmony export */   toHex: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.toHex),
    /* harmony export */   uint8ToBuf: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.uint8ToBuf),
    /* harmony export */   unwrapDER: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.unwrapDER),
    /* harmony export */   verify: () => (/* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_11__.verify),
    /* harmony export */   wrapDER: () => (/* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.wrapDER)
    /* harmony export */ });
    /* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ "./node_modules/@dfinity/agent/lib/esm/actor.js");
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ "./node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _agent_http_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http/transforms */ "./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js");
    /* harmony import */ var _agent_http_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./agent/http/types */ "./node_modules/@dfinity/agent/lib/esm/agent/http/types.js");
    /* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./auth */ "./node_modules/@dfinity/agent/lib/esm/auth.js");
    /* harmony import */ var _canisters_asset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canisters/asset */ "./node_modules/@dfinity/agent/lib/esm/canisters/asset.js");
    /* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./certificate */ "./node_modules/@dfinity/agent/lib/esm/certificate.js");
    /* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./der */ "./node_modules/@dfinity/agent/lib/esm/der.js");
    /* harmony import */ var _fetch_candid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fetch_candid */ "./node_modules/@dfinity/agent/lib/esm/fetch_candid.js");
    /* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./public_key */ "./node_modules/@dfinity/agent/lib/esm/public_key.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./request_id */ "./node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/bls */ "./node_modules/@dfinity/agent/lib/esm/utils/bls.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    /* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/random */ "./node_modules/@dfinity/agent/lib/esm/utils/random.js");
    /* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./polling */ "./node_modules/@dfinity/agent/lib/esm/polling/index.js");
    /* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./canisterStatus */ "./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js");
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cbor */ "./node_modules/@dfinity/agent/lib/esm/cbor.js");
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/polling/index.js":
    /*!**************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/polling/index.js ***!
      \**************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   defaultStrategy: () => (/* reexport safe */ _strategy__WEBPACK_IMPORTED_MODULE_3__.defaultStrategy),
    /* harmony export */   pollForResponse: () => (/* binding */ pollForResponse),
    /* harmony export */   strategy: () => (/* reexport module object */ _strategy__WEBPACK_IMPORTED_MODULE_3__)
    /* harmony export */ });
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../agent */ "./node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../certificate */ "./node_modules/@dfinity/agent/lib/esm/certificate.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    /* harmony import */ var _strategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategy */ "./node_modules/@dfinity/agent/lib/esm/polling/strategy.js");
    
    
    
    
    
    /**
     * Polls the IC to check the status of the given request then
     * returns the response bytes once the request has been processed.
     * @param agent The agent to use to poll read_state.
     * @param canisterId The effective canister ID.
     * @param requestId The Request ID to poll status for.
     * @param strategy A polling strategy.
     * @param request Request for the readState call.
     */
    async function pollForResponse(agent, canisterId, requestId, strategy, 
    // eslint-disable-next-line
    request, blsVerify) {
        var _a;
        const path = [new TextEncoder().encode('request_status'), requestId];
        const currentRequest = request !== null && request !== void 0 ? request : (await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, { paths: [path] })));
        const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);
        if (agent.rootKey == null)
            throw new Error('Agent root key not initialized before polling');
        const cert = await _certificate__WEBPACK_IMPORTED_MODULE_1__.Certificate.create({
            certificate: state.certificate,
            rootKey: agent.rootKey,
            canisterId: canisterId,
            blsVerify,
        });
        const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);
        let status;
        if (typeof maybeBuf === 'undefined') {
            // Missing requestId means we need to wait
            status = _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown;
        }
        else {
            status = new TextDecoder().decode(maybeBuf);
        }
        switch (status) {
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Replied: {
                return cert.lookup([...path, 'reply']);
            }
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Received:
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown:
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Processing:
                // Execute the polling strategy, then retry.
                await strategy(canisterId, requestId, status);
                return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Rejected: {
                const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code']))[0];
                const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message']));
                throw new Error(`Call was rejected:\n` +
                    `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\n` +
                    `  Reject code: ${rejectCode}\n` +
                    `  Reject text: ${rejectMessage}\n`);
            }
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Done:
                // This is _technically_ not an error, but we still didn't see the `Replied` status so
                // we don't know the result and cannot decode it.
                throw new Error(`Call was marked as done but we never saw the reply:\n` +
                    `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\n`);
        }
        throw new Error('unreachable');
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/polling/strategy.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/polling/strategy.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   backoff: () => (/* binding */ backoff),
    /* harmony export */   chain: () => (/* binding */ chain),
    /* harmony export */   conditionalDelay: () => (/* binding */ conditionalDelay),
    /* harmony export */   defaultStrategy: () => (/* binding */ defaultStrategy),
    /* harmony export */   maxAttempts: () => (/* binding */ maxAttempts),
    /* harmony export */   once: () => (/* binding */ once),
    /* harmony export */   throttle: () => (/* binding */ throttle),
    /* harmony export */   timeout: () => (/* binding */ timeout)
    /* harmony export */ });
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    
    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;
    /**
     * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second
     * with an exponential backoff factor of 1.2. Timeout after 5 minutes.
     */
    function defaultStrategy() {
        return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
    }
    /**
     * Predicate that returns true once.
     */
    function once() {
        let first = true;
        return async () => {
            if (first) {
                first = false;
                return true;
            }
            return false;
        };
    }
    /**
     * Delay the polling once.
     * @param condition A predicate that indicates when to delay.
     * @param timeInMsec The amount of time to delay.
     */
    function conditionalDelay(condition, timeInMsec) {
        return async (canisterId, requestId, status) => {
            if (await condition(canisterId, requestId, status)) {
                return new Promise(resolve => setTimeout(resolve, timeInMsec));
            }
        };
    }
    /**
     * Error out after a maximum number of polling has been done.
     * @param count The maximum attempts to poll.
     */
    function maxAttempts(count) {
        let attempts = count;
        return async (canisterId, requestId, status) => {
            if (--attempts <= 0) {
                throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` +
                    `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\n` +
                    `  Request status: ${status}\n`);
            }
        };
    }
    /**
     * Throttle polling.
     * @param throttleInMsec Amount in millisecond to wait between each polling.
     */
    function throttle(throttleInMsec) {
        return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));
    }
    /**
     * Reject a call after a certain amount of time.
     * @param timeInMsec Time in milliseconds before the polling should be rejected.
     */
    function timeout(timeInMsec) {
        const end = Date.now() + timeInMsec;
        return async (canisterId, requestId, status) => {
            if (Date.now() > end) {
                throw new Error(`Request timed out after ${timeInMsec} msec:\n` +
                    `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\n` +
                    `  Request status: ${status}\n`);
            }
        };
    }
    /**
     * A strategy that throttle, but using an exponential backoff strategy.
     * @param startingThrottleInMsec The throttle in milliseconds to start with.
     * @param backoffFactor The factor to multiple the throttle time between every poll. For
     *   example if using 2, the throttle will double between every run.
     */
    function backoff(startingThrottleInMsec, backoffFactor) {
        let currentThrottling = startingThrottleInMsec;
        return () => new Promise(resolve => setTimeout(() => {
            currentThrottling *= backoffFactor;
            resolve();
        }, currentThrottling));
    }
    /**
     * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,
     * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.
     * @param strategies A strategy list to chain.
     */
    function chain(...strategies) {
        return async (canisterId, requestId, status) => {
            for (const a of strategies) {
                await a(canisterId, requestId, status);
            }
        };
    }
    //# sourceMappingURL=strategy.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/public_key.js":
    /*!***********************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/public_key.js ***!
      \***********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Ed25519PublicKey: () => (/* binding */ Ed25519PublicKey)
    /* harmony export */ });
    /* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./der */ "./node_modules/@dfinity/agent/lib/esm/der.js");
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey;
    
    class Ed25519PublicKey {
        // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
        constructor(key) {
            _Ed25519PublicKey_rawKey.set(this, void 0);
            _Ed25519PublicKey_derKey.set(this, void 0);
            if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {
                throw new Error('An Ed25519 public key must be exactly 32bytes long');
            }
            __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, "f");
            __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), "f");
        }
        static from(key) {
            return this.fromDer(key.toDer());
        }
        static fromRaw(rawKey) {
            return new Ed25519PublicKey(rawKey);
        }
        static fromDer(derKey) {
            return new Ed25519PublicKey(this.derDecode(derKey));
        }
        static derEncode(publicKey) {
            return (0,_der__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(publicKey, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID).buffer;
        }
        static derDecode(key) {
            const unwrapped = (0,_der__WEBPACK_IMPORTED_MODULE_0__.unwrapDER)(key, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);
            if (unwrapped.length !== this.RAW_KEY_LENGTH) {
                throw new Error('An Ed25519 public key must be exactly 32bytes long');
            }
            return unwrapped;
        }
        get rawKey() {
            return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, "f");
        }
        get derKey() {
            return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, "f");
        }
        toDer() {
            return this.derKey;
        }
        toRaw() {
            return this.rawKey;
        }
    }
    _Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();
    // The length of Ed25519 public keys is always 32 bytes.
    Ed25519PublicKey.RAW_KEY_LENGTH = 32;
    //# sourceMappingURL=public_key.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/request_id.js":
    /*!***********************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/request_id.js ***!
      \***********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   hash: () => (/* binding */ hash),
    /* harmony export */   hashOfMap: () => (/* binding */ hashOfMap),
    /* harmony export */   hashValue: () => (/* binding */ hashValue),
    /* harmony export */   requestIdOf: () => (/* binding */ requestIdOf)
    /* harmony export */ });
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borc */ "./node_modules/borc/src/index.js");
    /* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/esm/sha256.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js");
    
    
    
    
    /**
     * sha256 hash the provided Buffer
     * @param data - input to hash function
     */
    function hash(data) {
        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.uint8ToBuf)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.create().update(new Uint8Array(data)).digest());
    }
    /**
     *
     * @param value unknown value
     * @returns ArrayBuffer
     */
    function hashValue(value) {
        if (value instanceof borc__WEBPACK_IMPORTED_MODULE_1__.Tagged) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return hashValue(value.value);
        }
        else if (typeof value === 'string') {
            return hashString(value);
        }
        else if (typeof value === 'number') {
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));
        }
        else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
            return hash(value);
        }
        else if (Array.isArray(value)) {
            const vals = value.map(hashValue);
            return hash((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...vals));
        }
        else if (value && typeof value === 'object' && value._isPrincipal) {
            return hash(value.toUint8Array());
        }
        else if (typeof value === 'object' &&
            value !== null &&
            typeof value.toHash === 'function') {
            return hashValue(value.toHash());
            // TODO This should be move to a specific async method as the webauthn flow required
            // the flow to be synchronous to ensure Safari touch id works.
            // } else if (value instanceof Promise) {
            //   return value.then(x => hashValue(x));
        }
        else if (typeof value === 'object') {
            return hashOfMap(value);
        }
        else if (typeof value === 'bigint') {
            // Do this check much later than the other bigint check because this one is much less
            // type-safe.
            // So we want to try all the high-assurance type guards before this 'probable' one.
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));
        }
        throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {
            // include so logs/callers can understand the confusing value.
            // (when stringified in error message, prototype info is lost)
            value,
        });
    }
    const hashString = (value) => {
        const encoded = new TextEncoder().encode(value);
        return hash(encoded);
    };
    /**
     * Get the RequestId of the provided ic-ref request.
     * RequestId is the result of the representation-independent-hash function.
     * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map
     * @param request - ic-ref request to hash into RequestId
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function requestIdOf(request) {
        return hashOfMap(request);
    }
    /**
     * Hash a map into an ArrayBuffer using the representation-independent-hash function.
     * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map
     * @param map - Any non-nested object
     * @returns ArrayBuffer
     */
    function hashOfMap(map) {
        const hashed = Object.entries(map)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => {
            const hashedKey = hashString(key);
            const hashedValue = hashValue(value);
            return [hashedKey, hashedValue];
        });
        const traversed = hashed;
        const sorted = traversed.sort(([k1], [k2]) => {
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.compare)(k1, k2);
        });
        const concatenated = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...sorted.map(x => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...x)));
        const result = hash(concatenated);
        return result;
    }
    //# sourceMappingURL=request_id.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/utils/bls.js":
    /*!**********************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/utils/bls.js ***!
      \**********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   blsVerify: () => (/* binding */ blsVerify),
    /* harmony export */   verify: () => (/* binding */ verify)
    /* harmony export */ });
    /* harmony import */ var _vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/bls/bls */ "./node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js");
    
    let verify;
    /**
     *
     * @param pk primary key: Uint8Array
     * @param sig signature: Uint8Array
     * @param msg message: Uint8Array
     * @returns Promise resolving a boolean
     */
    async function blsVerify(pk, sig, msg) {
        if (!verify) {
            await (0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__["default"])();
            if ((0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__.bls_init)() !== 0) {
                throw new Error('Cannot initialize BLS');
            }
            verify = (pk1, sig1, msg1) => {
                // Reorder things from what the WASM expects (sig, m, w).
                return (0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__.bls_verify)(sig1, msg1, pk1) === 0;
            };
        }
        return verify(pk, sig, msg);
    }
    //# sourceMappingURL=bls.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/utils/buffer.js":
    /*!*************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/utils/buffer.js ***!
      \*************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   bufEquals: () => (/* binding */ bufEquals),
    /* harmony export */   bufFromBufLike: () => (/* binding */ bufFromBufLike),
    /* harmony export */   compare: () => (/* binding */ compare),
    /* harmony export */   concat: () => (/* binding */ concat),
    /* harmony export */   fromHex: () => (/* binding */ fromHex),
    /* harmony export */   toHex: () => (/* binding */ toHex),
    /* harmony export */   uint8ToBuf: () => (/* binding */ uint8ToBuf)
    /* harmony export */ });
    /**
     * Concatenate multiple array buffers.
     * @param buffers The buffers to concatenate.
     */
    function concat(...buffers) {
        const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
        let index = 0;
        for (const b of buffers) {
            result.set(new Uint8Array(b), index);
            index += b.byteLength;
        }
        return result.buffer;
    }
    /**
     * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.
     * @param buffer The buffer to return the hexadecimal string of.
     */
    function toHex(buffer) {
        return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');
    }
    const hexRe = new RegExp(/^[0-9a-fA-F]+$/);
    /**
     * Transforms a hexadecimal string into an array buffer.
     * @param hex The hexadecimal string to use.
     */
    function fromHex(hex) {
        if (!hexRe.test(hex)) {
            throw new Error('Invalid hexadecimal string.');
        }
        const buffer = [...hex]
            .reduce((acc, curr, i) => {
            acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;
            return acc;
        }, [])
            .map(x => Number.parseInt(x, 16));
        return new Uint8Array(buffer).buffer;
    }
    /**
     *
     * @param b1 array buffer 1
     * @param b2 array buffer 2
     * @returns number - negative if b1 < b2, positive if b1 > b2, 0 if b1 === b2
     */
    function compare(b1, b2) {
        if (b1.byteLength !== b2.byteLength) {
            return b1.byteLength - b2.byteLength;
        }
        const u1 = new Uint8Array(b1);
        const u2 = new Uint8Array(b2);
        for (let i = 0; i < u1.length; i++) {
            if (u1[i] !== u2[i]) {
                return u1[i] - u2[i];
            }
        }
        return 0;
    }
    /**
     * Checks two array buffers for equality.
     * @param b1 array buffer 1
     * @param b2 array buffer 2
     * @returns boolean
     */
    function bufEquals(b1, b2) {
        return compare(b1, b2) === 0;
    }
    /**
     * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.
     * @param {Uint8Array} arr Uint8Array to convert
     * @returns ArrayBuffer
     */
    function uint8ToBuf(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;
    }
    /**
     * Returns a true ArrayBuffer from an ArrayBufferLike object.
     * @param bufLike a buffer-like object
     * @returns ArrayBuffer
     */
    function bufFromBufLike(bufLike) {
        if (bufLike instanceof Uint8Array) {
            return uint8ToBuf(bufLike);
        }
        if (bufLike instanceof ArrayBuffer) {
            return bufLike;
        }
        if ('buffer' in bufLike) {
            return bufLike.buffer;
        }
        return new Uint8Array(bufLike);
    }
    //# sourceMappingURL=buffer.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js ***!
      \*******************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ExpirableMap: () => (/* binding */ ExpirableMap)
    /* harmony export */ });
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ExpirableMap_inner, _ExpirableMap_expirationTime, _a, _b;
    /**
     * A map that expires entries after a given time.
     * Defaults to 10 minutes.
     */
    class ExpirableMap {
        /**
         * Create a new ExpirableMap.
         * @param {ExpirableMapOptions<any, any>} options - options for the map.
         * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.
         * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.
         */
        constructor(options = {}) {
            // Internals
            _ExpirableMap_inner.set(this, void 0);
            _ExpirableMap_expirationTime.set(this, void 0);
            this[_a] = this.entries.bind(this);
            this[_b] = 'ExpirableMap';
            const { source = [], expirationTime = 10 * 60 * 1000 } = options;
            const currentTime = Date.now();
            __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([...source].map(([key, value]) => [key, { value, timestamp: currentTime }])), "f");
            __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, "f");
        }
        /**
         * Prune removes all expired entries.
         */
        prune() {
            const currentTime = Date.now();
            for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()) {
                if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
                    __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
                }
            }
            return this;
        }
        // Implementing the Map interface
        /**
         * Set the value for the given key. Prunes expired entries.
         * @param key for the entry
         * @param value of the entry
         * @returns this
         */
        set(key, value) {
            this.prune();
            const entry = {
                value,
                timestamp: Date.now(),
            };
            __classPrivateFieldGet(this, _ExpirableMap_inner, "f").set(key, entry);
            return this;
        }
        /**
         * Get the value associated with the key, if it exists and has not expired.
         * @param key K
         * @returns the value associated with the key, or undefined if the key is not present or has expired.
         */
        get(key) {
            const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").get(key);
            if (entry === undefined) {
                return undefined;
            }
            if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
                __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
                return undefined;
            }
            return entry.value;
        }
        /**
         * Clear all entries.
         */
        clear() {
            __classPrivateFieldGet(this, _ExpirableMap_inner, "f").clear();
        }
        /**
         * Entries returns the entries of the map, without the expiration time.
         * @returns an iterator over the entries of the map.
         */
        entries() {
            const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries();
            const generator = function* () {
                for (const [key, value] of iterator) {
                    yield [key, value.value];
                }
            };
            return generator();
        }
        /**
         * Values returns the values of the map, without the expiration time.
         * @returns an iterator over the values of the map.
         */
        values() {
            const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").values();
            const generator = function* () {
                for (const value of iterator) {
                    yield value.value;
                }
            };
            return generator();
        }
        /**
         * Keys returns the keys of the map
         * @returns an iterator over the keys of the map.
         */
        keys() {
            return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").keys();
        }
        /**
         * forEach calls the callbackfn on each entry of the map.
         * @param callbackfn to call on each entry
         * @param thisArg to use as this when calling the callbackfn
         */
        forEach(callbackfn, thisArg) {
            for (const [key, value] of __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()) {
                callbackfn.call(thisArg, value.value, key, this);
            }
        }
        /**
         * has returns true if the key exists and has not expired.
         * @param key K
         * @returns true if the key exists and has not expired.
         */
        has(key) {
            return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").has(key);
        }
        /**
         * delete the entry for the given key.
         * @param key K
         * @returns true if the key existed and has been deleted.
         */
        delete(key) {
            return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
        }
        /**
         * get size of the map.
         * @returns the size of the map.
         */
        get size() {
            return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").size;
        }
    }
    _ExpirableMap_inner = new WeakMap(), _ExpirableMap_expirationTime = new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;
    //# sourceMappingURL=expirableMap.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/utils/leb.js":
    /*!**********************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/utils/leb.js ***!
      \**********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   decodeLeb128: () => (/* binding */ decodeLeb128),
    /* harmony export */   decodeTime: () => (/* binding */ decodeTime)
    /* harmony export */ });
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@dfinity/candid/lib/esm/index.js");
    
    const decodeLeb128 = (buf) => {
        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(new _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(buf));
    };
    // time is a LEB128-encoded Nat
    const decodeTime = (buf) => {
        const decoded = decodeLeb128(buf);
        // nanoseconds to milliseconds
        return new Date(Number(decoded) / 1000000);
    };
    //# sourceMappingURL=leb.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/utils/random.js":
    /*!*************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/utils/random.js ***!
      \*************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   randomNumber: () => (/* binding */ randomNumber)
    /* harmony export */ });
    /**
     * Generates a random unsigned 32-bit integer between 0 and 0xffffffff
     * @returns {number} a random number
     */
    const randomNumber = () => {
        // determine whether browser crypto is available
        if (typeof window !== 'undefined' && !!window.crypto && !!window.crypto.getRandomValues) {
            const array = new Uint32Array(1);
            window.crypto.getRandomValues(array);
            return array[0];
        }
        // A second check for webcrypto, in case it is loaded under global instead of window
        if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
            const array = new Uint32Array(1);
            crypto.getRandomValues(array);
            return array[0];
        }
        // determine whether node crypto is available
        if (typeof crypto !== 'undefined' && crypto.randomInt) {
            return crypto.randomInt(0, 0xffffffff);
        }
        // fall back to Math.random
        return Math.floor(Math.random() * 0xffffffff);
    };
    //# sourceMappingURL=random.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js":
    /*!***************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js ***!
      \***************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   bls_init: () => (/* binding */ bls_init),
    /* harmony export */   bls_verify: () => (/* binding */ bls_verify),
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
    /* harmony import */ var _wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm */ "./node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js");
    
    // This WASM is generated from the miracl BLS Rust code (see
    // https://github.com/dfinity/miracl_core_bls12381/)
    
    let wasm;
    const wasmBytes = base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__.decode(_wasm__WEBPACK_IMPORTED_MODULE_1__.wasmBytesBase64);
    /**
     * @returns {number}
     */
    function bls_init() {
        let ret = wasm.bls_init();
        return ret;
    }
    let cachegetUint8Memory0 = null;
    function getUint8Memory0() {
        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachegetUint8Memory0;
    }
    function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1);
        getUint8Memory0().set(arg, ptr / 1);
        return [ptr, arg.length];
    }
    /**
     * @param {Uint8Array} sig
     * @param {Uint8Array} m
     * @param {Uint8Array} w
     * @returns {number}
     */
    function bls_verify(sig, m, w) {
        const [ptr0, len0] = passArray8ToWasm0(sig, wasm.__wbindgen_malloc);
        const [ptr1, len1] = passArray8ToWasm0(m, wasm.__wbindgen_malloc);
        const [ptr2, len2] = passArray8ToWasm0(w, wasm.__wbindgen_malloc);
        const ret = wasm.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
        return ret;
    }
    async function load(module, imports) {
        if (typeof Response === 'function' && module instanceof Response) {
            const bytes = await module.arrayBuffer();
            return await WebAssembly.instantiate(bytes, imports);
        }
        else {
            const instance = await WebAssembly.instantiate(module, imports);
            if (instance instanceof WebAssembly.Instance) {
                return { instance, module };
            }
            else {
                return instance;
            }
        }
    }
    async function init() {
        const imports = {};
        const { instance, module } = await load(wasmBytes, imports);
        wasm = instance.exports;
        init.__wbindgen_wasm_module = module;
        return wasm;
    }
    /**
     * If `module_or_path` is {RequestInfo} or {URL}, makes a request and
     * for everything else, calls `WebAssembly.instantiate` directly.
     *
     * @param {InitInput | Promise<InitInput>} module_or_path
     *
     * @returns {Promise<InitOutput>}
     */
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (init);
    //# sourceMappingURL=bls.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js":
    /*!****************************************************************!*\
      !*** ./node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js ***!
      \****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   wasmBytesBase64: () => (/* binding */ wasmBytesBase64)
    /* harmony export */ });
    const wasmBytesBase64 = `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akE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJB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AEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApB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ABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRA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AWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRU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aikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIg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DCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFq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AAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;
    //# sourceMappingURL=wasm.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/candid-core.js":
    /*!*************************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/candid-core.js ***!
      \*************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   InputBox: () => (/* binding */ InputBox),
    /* harmony export */   InputForm: () => (/* binding */ InputForm),
    /* harmony export */   OptionForm: () => (/* binding */ OptionForm),
    /* harmony export */   RecordForm: () => (/* binding */ RecordForm),
    /* harmony export */   TupleForm: () => (/* binding */ TupleForm),
    /* harmony export */   VariantForm: () => (/* binding */ VariantForm),
    /* harmony export */   VecForm: () => (/* binding */ VecForm)
    /* harmony export */ });
    class InputBox {
        constructor(idl, ui) {
            this.idl = idl;
            this.ui = ui;
            this.label = null;
            this.value = undefined;
            const status = document.createElement('span');
            status.className = 'status';
            this.status = status;
            if (ui.input) {
                ui.input.addEventListener('blur', () => {
                    if (ui.input.value === '') {
                        return;
                    }
                    this.parse();
                });
                ui.input.addEventListener('input', () => {
                    status.style.display = 'none';
                    ui.input.classList.remove('reject');
                });
            }
        }
        isRejected() {
            return this.value === undefined;
        }
        parse(config = {}) {
            if (this.ui.form) {
                const value = this.ui.form.parse(config);
                this.value = value;
                return value;
            }
            if (this.ui.input) {
                const input = this.ui.input;
                try {
                    const value = this.ui.parse(this.idl, config, input.value);
                    if (!this.idl.covariant(value)) {
                        throw new Error(`${input.value} is not of type ${this.idl.display()}`);
                    }
                    this.status.style.display = 'none';
                    this.value = value;
                    return value;
                }
                catch (err) {
                    input.classList.add('reject');
                    this.status.style.display = 'block';
                    this.status.innerHTML = 'InputError: ' + err.message;
                    this.value = undefined;
                    return undefined;
                }
            }
            return null;
        }
        render(dom) {
            const container = document.createElement('span');
            if (this.label) {
                const label = document.createElement('label');
                label.innerText = this.label;
                container.appendChild(label);
            }
            if (this.ui.input) {
                container.appendChild(this.ui.input);
                container.appendChild(this.status);
            }
            if (this.ui.form) {
                this.ui.form.render(container);
            }
            dom.appendChild(container);
        }
    }
    class InputForm {
        constructor(ui) {
            this.ui = ui;
            this.form = [];
        }
        renderForm(dom) {
            if (this.ui.container) {
                this.form.forEach(e => e.render(this.ui.container));
                dom.appendChild(this.ui.container);
            }
            else {
                this.form.forEach(e => e.render(dom));
            }
        }
        render(dom) {
            if (this.ui.open && this.ui.event) {
                dom.appendChild(this.ui.open);
                const form = this;
                // eslint-disable-next-line
                form.ui.open.addEventListener(form.ui.event, () => {
                    // Remove old form
                    if (form.ui.container) {
                        form.ui.container.innerHTML = '';
                    }
                    else {
                        const oldContainer = form.ui.open.nextElementSibling;
                        if (oldContainer) {
                            oldContainer.parentNode.removeChild(oldContainer);
                        }
                    }
                    // Render form
                    form.generateForm();
                    form.renderForm(dom);
                });
            }
            else {
                this.generateForm();
                this.renderForm(dom);
            }
        }
    }
    class RecordForm extends InputForm {
        constructor(fields, ui) {
            super(ui);
            this.fields = fields;
            this.ui = ui;
        }
        generateForm() {
            this.form = this.fields.map(([key, type]) => {
                const input = this.ui.render(type);
                // eslint-disable-next-line
                if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {
                    input.label = this.ui.labelMap[key] + ' ';
                }
                else {
                    input.label = key + ' ';
                }
                return input;
            });
        }
        parse(config) {
            const v = {};
            this.fields.forEach(([key, _], i) => {
                const value = this.form[i].parse(config);
                v[key] = value;
            });
            if (this.form.some(input => input.isRejected())) {
                return undefined;
            }
            return v;
        }
    }
    class TupleForm extends InputForm {
        constructor(components, ui) {
            super(ui);
            this.components = components;
            this.ui = ui;
        }
        generateForm() {
            this.form = this.components.map(type => {
                const input = this.ui.render(type);
                return input;
            });
        }
        parse(config) {
            const v = [];
            this.components.forEach((_, i) => {
                const value = this.form[i].parse(config);
                v.push(value);
            });
            if (this.form.some(input => input.isRejected())) {
                return undefined;
            }
            return v;
        }
    }
    class VariantForm extends InputForm {
        constructor(fields, ui) {
            super(ui);
            this.fields = fields;
            this.ui = ui;
        }
        generateForm() {
            const index = this.ui.open.selectedIndex;
            const [_, type] = this.fields[index];
            const variant = this.ui.render(type);
            this.form = [variant];
        }
        parse(config) {
            const select = this.ui.open;
            const selected = select.options[select.selectedIndex].value;
            const value = this.form[0].parse(config);
            if (value === undefined) {
                return undefined;
            }
            const v = {};
            v[selected] = value;
            return v;
        }
    }
    class OptionForm extends InputForm {
        constructor(ty, ui) {
            super(ui);
            this.ty = ty;
            this.ui = ui;
        }
        generateForm() {
            if (this.ui.open.checked) {
                const opt = this.ui.render(this.ty);
                this.form = [opt];
            }
            else {
                this.form = [];
            }
        }
        parse(config) {
            if (this.form.length === 0) {
                return [];
            }
            else {
                const value = this.form[0].parse(config);
                if (value === undefined) {
                    return undefined;
                }
                return [value];
            }
        }
    }
    class VecForm extends InputForm {
        constructor(ty, ui) {
            super(ui);
            this.ty = ty;
            this.ui = ui;
        }
        generateForm() {
            const len = +this.ui.open.value;
            this.form = [];
            for (let i = 0; i < len; i++) {
                const t = this.ui.render(this.ty);
                this.form.push(t);
            }
        }
        parse(config) {
            const value = this.form.map(input => {
                return input.parse(config);
            });
            if (this.form.some(input => input.isRejected())) {
                return undefined;
            }
            return value;
        }
    }
    //# sourceMappingURL=candid-core.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/candid-ui.js":
    /*!***********************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/candid-ui.js ***!
      \***********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Render: () => (/* binding */ Render),
    /* harmony export */   inputBox: () => (/* binding */ inputBox),
    /* harmony export */   optForm: () => (/* binding */ optForm),
    /* harmony export */   recordForm: () => (/* binding */ recordForm),
    /* harmony export */   renderInput: () => (/* binding */ renderInput),
    /* harmony export */   renderValue: () => (/* binding */ renderValue),
    /* harmony export */   tupleForm: () => (/* binding */ tupleForm),
    /* harmony export */   variantForm: () => (/* binding */ variantForm),
    /* harmony export */   vecForm: () => (/* binding */ vecForm)
    /* harmony export */ });
    /* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./idl */ "./node_modules/@dfinity/candid/lib/esm/idl.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./candid-core */ "./node_modules/@dfinity/candid/lib/esm/candid-core.js");
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /* eslint-disable @typescript-eslint/no-unused-vars */
    
    
    
    const InputConfig = { parse: parsePrimitive };
    const FormConfig = { render: renderInput };
    const inputBox = (t, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.InputBox(t, Object.assign(Object.assign({}, InputConfig), config));
    };
    const recordForm = (fields, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));
    };
    const tupleForm = (components, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));
    };
    const variantForm = (fields, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));
    };
    const optForm = (ty, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));
    };
    const vecForm = (ty, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));
    };
    class Render extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitType(t, d) {
            const input = document.createElement('input');
            input.classList.add('argument');
            input.placeholder = t.display();
            return inputBox(t, { input });
        }
        visitNull(t, d) {
            return inputBox(t, {});
        }
        visitRecord(t, fields, d) {
            let config = {};
            if (fields.length > 1) {
                const container = document.createElement('div');
                container.classList.add('popup-form');
                config = { container };
            }
            const form = recordForm(fields, config);
            return inputBox(t, { form });
        }
        visitTuple(t, components, d) {
            let config = {};
            if (components.length > 1) {
                const container = document.createElement('div');
                container.classList.add('popup-form');
                config = { container };
            }
            const form = tupleForm(components, config);
            return inputBox(t, { form });
        }
        visitVariant(t, fields, d) {
            const select = document.createElement('select');
            for (const [key, type] of fields) {
                const option = new Option(key);
                select.add(option);
            }
            select.selectedIndex = -1;
            select.classList.add('open');
            const config = { open: select, event: 'change' };
            const form = variantForm(fields, config);
            return inputBox(t, { form });
        }
        visitOpt(t, ty, d) {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.classList.add('open');
            const form = optForm(ty, { open: checkbox, event: 'change' });
            return inputBox(t, { form });
        }
        visitVec(t, ty, d) {
            const len = document.createElement('input');
            len.type = 'number';
            len.min = '0';
            len.max = '100';
            len.style.width = '8rem';
            len.placeholder = 'len';
            len.classList.add('open');
            const container = document.createElement('div');
            container.classList.add('popup-form');
            const form = vecForm(ty, { open: len, event: 'change', container });
            return inputBox(t, { form });
        }
        visitRec(t, ty, d) {
            return renderInput(ty);
        }
    }
    class Parse extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitNull(t, v) {
            return null;
        }
        visitBool(t, v) {
            if (v === 'true') {
                return true;
            }
            if (v === 'false') {
                return false;
            }
            throw new Error(`Cannot parse ${v} as boolean`);
        }
        visitText(t, v) {
            return v;
        }
        visitFloat(t, v) {
            return parseFloat(v);
        }
        visitFixedInt(t, v) {
            if (t._bits <= 32) {
                return parseInt(v, 10);
            }
            else {
                return BigInt(v);
            }
        }
        visitFixedNat(t, v) {
            if (t._bits <= 32) {
                return parseInt(v, 10);
            }
            else {
                return BigInt(v);
            }
        }
        visitNumber(t, v) {
            return BigInt(v);
        }
        visitPrincipal(t, v) {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);
        }
        visitService(t, v) {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);
        }
        visitFunc(t, v) {
            const x = v.split('.', 2);
            return [_dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(x[0]), x[1]];
        }
    }
    class Random extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitNull(t, v) {
            return null;
        }
        visitBool(t, v) {
            return Math.random() < 0.5;
        }
        visitText(t, v) {
            return Math.random().toString(36).substring(6);
        }
        visitFloat(t, v) {
            return Math.random();
        }
        visitInt(t, v) {
            return BigInt(this.generateNumber(true));
        }
        visitNat(t, v) {
            return BigInt(this.generateNumber(false));
        }
        visitFixedInt(t, v) {
            const x = this.generateNumber(true);
            if (t._bits <= 32) {
                return x;
            }
            else {
                return BigInt(v);
            }
        }
        visitFixedNat(t, v) {
            const x = this.generateNumber(false);
            if (t._bits <= 32) {
                return x;
            }
            else {
                return BigInt(v);
            }
        }
        generateNumber(signed) {
            const num = Math.floor(Math.random() * 100);
            if (signed && Math.random() < 0.5) {
                return -num;
            }
            else {
                return num;
            }
        }
    }
    function parsePrimitive(t, config, d) {
        if (config.random && d === '') {
            return t.accept(new Random(), d);
        }
        else {
            return t.accept(new Parse(), d);
        }
    }
    /**
     *
     * @param t an IDL type
     * @returns an input for that type
     */
    function renderInput(t) {
        return t.accept(new Render(), null);
    }
    /**
     *
     * @param t an IDL Type
     * @param input an InputBox
     * @param value any
     * @returns rendering that value to the provided input
     */
    function renderValue(t, input, value) {
        return t.accept(new RenderValue(), { input, value });
    }
    class RenderValue extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitType(t, d) {
            d.input.ui.input.value = t.valueToString(d.value);
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        visitNull(t, d) { }
        visitText(t, d) {
            d.input.ui.input.value = d.value;
        }
        visitRec(t, ty, d) {
            renderValue(ty, d.input, d.value);
        }
        visitOpt(t, ty, d) {
            if (d.value.length === 0) {
                return;
            }
            else {
                const form = d.input.ui.form;
                const open = form.ui.open;
                open.checked = true;
                open.dispatchEvent(new Event(form.ui.event));
                renderValue(ty, form.form[0], d.value[0]);
            }
        }
        visitRecord(t, fields, d) {
            const form = d.input.ui.form;
            fields.forEach(([key, type], i) => {
                renderValue(type, form.form[i], d.value[key]);
            });
        }
        visitTuple(t, components, d) {
            const form = d.input.ui.form;
            components.forEach((type, i) => {
                renderValue(type, form.form[i], d.value[i]);
            });
        }
        visitVariant(t, fields, d) {
            const form = d.input.ui.form;
            const selected = Object.entries(d.value)[0];
            fields.forEach(([key, type], i) => {
                if (key === selected[0]) {
                    const open = form.ui.open;
                    open.selectedIndex = i;
                    open.dispatchEvent(new Event(form.ui.event));
                    renderValue(type, form.form[0], selected[1]);
                }
            });
        }
        visitVec(t, ty, d) {
            const form = d.input.ui.form;
            const len = d.value.length;
            const open = form.ui.open;
            open.value = len;
            open.dispatchEvent(new Event(form.ui.event));
            d.value.forEach((v, i) => {
                renderValue(ty, form.form[i], v);
            });
        }
    }
    //# sourceMappingURL=candid-ui.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/idl.js":
    /*!*****************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/idl.js ***!
      \*****************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Bool: () => (/* binding */ Bool),
    /* harmony export */   BoolClass: () => (/* binding */ BoolClass),
    /* harmony export */   ConstructType: () => (/* binding */ ConstructType),
    /* harmony export */   Empty: () => (/* binding */ Empty),
    /* harmony export */   EmptyClass: () => (/* binding */ EmptyClass),
    /* harmony export */   FixedIntClass: () => (/* binding */ FixedIntClass),
    /* harmony export */   FixedNatClass: () => (/* binding */ FixedNatClass),
    /* harmony export */   Float32: () => (/* binding */ Float32),
    /* harmony export */   Float64: () => (/* binding */ Float64),
    /* harmony export */   FloatClass: () => (/* binding */ FloatClass),
    /* harmony export */   Func: () => (/* binding */ Func),
    /* harmony export */   FuncClass: () => (/* binding */ FuncClass),
    /* harmony export */   Int: () => (/* binding */ Int),
    /* harmony export */   Int16: () => (/* binding */ Int16),
    /* harmony export */   Int32: () => (/* binding */ Int32),
    /* harmony export */   Int64: () => (/* binding */ Int64),
    /* harmony export */   Int8: () => (/* binding */ Int8),
    /* harmony export */   IntClass: () => (/* binding */ IntClass),
    /* harmony export */   Nat: () => (/* binding */ Nat),
    /* harmony export */   Nat16: () => (/* binding */ Nat16),
    /* harmony export */   Nat32: () => (/* binding */ Nat32),
    /* harmony export */   Nat64: () => (/* binding */ Nat64),
    /* harmony export */   Nat8: () => (/* binding */ Nat8),
    /* harmony export */   NatClass: () => (/* binding */ NatClass),
    /* harmony export */   Null: () => (/* binding */ Null),
    /* harmony export */   NullClass: () => (/* binding */ NullClass),
    /* harmony export */   Opt: () => (/* binding */ Opt),
    /* harmony export */   OptClass: () => (/* binding */ OptClass),
    /* harmony export */   PrimitiveType: () => (/* binding */ PrimitiveType),
    /* harmony export */   Principal: () => (/* binding */ Principal),
    /* harmony export */   PrincipalClass: () => (/* binding */ PrincipalClass),
    /* harmony export */   Rec: () => (/* binding */ Rec),
    /* harmony export */   RecClass: () => (/* binding */ RecClass),
    /* harmony export */   Record: () => (/* binding */ Record),
    /* harmony export */   RecordClass: () => (/* binding */ RecordClass),
    /* harmony export */   Reserved: () => (/* binding */ Reserved),
    /* harmony export */   ReservedClass: () => (/* binding */ ReservedClass),
    /* harmony export */   Service: () => (/* binding */ Service),
    /* harmony export */   ServiceClass: () => (/* binding */ ServiceClass),
    /* harmony export */   Text: () => (/* binding */ Text),
    /* harmony export */   TextClass: () => (/* binding */ TextClass),
    /* harmony export */   Tuple: () => (/* binding */ Tuple),
    /* harmony export */   TupleClass: () => (/* binding */ TupleClass),
    /* harmony export */   Type: () => (/* binding */ Type),
    /* harmony export */   Unknown: () => (/* binding */ Unknown),
    /* harmony export */   UnknownClass: () => (/* binding */ UnknownClass),
    /* harmony export */   Variant: () => (/* binding */ Variant),
    /* harmony export */   VariantClass: () => (/* binding */ VariantClass),
    /* harmony export */   Vec: () => (/* binding */ Vec),
    /* harmony export */   VecClass: () => (/* binding */ VecClass),
    /* harmony export */   Visitor: () => (/* binding */ Visitor),
    /* harmony export */   decode: () => (/* binding */ decode),
    /* harmony export */   encode: () => (/* binding */ encode)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/candid/lib/esm/utils/buffer.js");
    /* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hash */ "./node_modules/@dfinity/candid/lib/esm/utils/hash.js");
    /* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/leb128 */ "./node_modules/@dfinity/candid/lib/esm/utils/leb128.js");
    /* harmony import */ var _utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/bigint-math */ "./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js");
    /* eslint-disable @typescript-eslint/no-unused-vars */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    
    
    
    
    
    const magicNumber = 'DIDL';
    const toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error
    function zipWith(xs, ys, f) {
        return xs.map((x, i) => f(x, ys[i]));
    }
    /**
     * An IDL Type Table, which precedes the data in the stream.
     */
    class TypeTable {
        constructor() {
            // List of types. Needs to be an array as the index needs to be stable.
            this._typs = [];
            this._idx = new Map();
        }
        has(obj) {
            return this._idx.has(obj.name);
        }
        add(type, buf) {
            const idx = this._typs.length;
            this._idx.set(type.name, idx);
            this._typs.push(buf);
        }
        merge(obj, knot) {
            const idx = this._idx.get(obj.name);
            const knotIdx = this._idx.get(knot);
            if (idx === undefined) {
                throw new Error('Missing type index for ' + obj);
            }
            if (knotIdx === undefined) {
                throw new Error('Missing type index for ' + knot);
            }
            this._typs[idx] = this._typs[knotIdx];
            // Delete the type.
            this._typs.splice(knotIdx, 1);
            this._idx.delete(knot);
        }
        encode() {
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._typs.length);
            const buf = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this._typs);
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);
        }
        indexOf(typeName) {
            if (!this._idx.has(typeName)) {
                throw new Error('Missing type index for ' + typeName);
            }
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(this._idx.get(typeName) || 0);
        }
    }
    class Visitor {
        visitType(t, data) {
            throw new Error('Not implemented');
        }
        visitPrimitive(t, data) {
            return this.visitType(t, data);
        }
        visitEmpty(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitBool(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitNull(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitReserved(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitText(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitNumber(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitInt(t, data) {
            return this.visitNumber(t, data);
        }
        visitNat(t, data) {
            return this.visitNumber(t, data);
        }
        visitFloat(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitFixedInt(t, data) {
            return this.visitNumber(t, data);
        }
        visitFixedNat(t, data) {
            return this.visitNumber(t, data);
        }
        visitPrincipal(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitConstruct(t, data) {
            return this.visitType(t, data);
        }
        visitVec(t, ty, data) {
            return this.visitConstruct(t, data);
        }
        visitOpt(t, ty, data) {
            return this.visitConstruct(t, data);
        }
        visitRecord(t, fields, data) {
            return this.visitConstruct(t, data);
        }
        visitTuple(t, components, data) {
            const fields = components.map((ty, i) => [`_${i}_`, ty]);
            return this.visitRecord(t, fields, data);
        }
        visitVariant(t, fields, data) {
            return this.visitConstruct(t, data);
        }
        visitRec(t, ty, data) {
            return this.visitConstruct(ty, data);
        }
        visitFunc(t, data) {
            return this.visitConstruct(t, data);
        }
        visitService(t, data) {
            return this.visitConstruct(t, data);
        }
    }
    /**
     * Represents an IDL type.
     */
    class Type {
        /* Display type name */
        display() {
            return this.name;
        }
        valueToString(x) {
            return toReadableString(x);
        }
        /* Implement `T` in the IDL spec, only needed for non-primitive types */
        buildTypeTable(typeTable) {
            if (!typeTable.has(this)) {
                this._buildTypeTableImpl(typeTable);
            }
        }
    }
    class PrimitiveType extends Type {
        checkType(t) {
            if (this.name !== t.name) {
                throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);
            }
            return t;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _buildTypeTableImpl(typeTable) {
            // No type table encoding for Primitive types.
            return;
        }
    }
    class ConstructType extends Type {
        checkType(t) {
            if (t instanceof RecClass) {
                const ty = t.getType();
                if (typeof ty === 'undefined') {
                    throw new Error('type mismatch with uninitialized type');
                }
                return ty;
            }
            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);
        }
        encodeType(typeTable) {
            return typeTable.indexOf(this.name);
        }
    }
    /**
     * Represents an IDL Empty, a type which has no inhabitants.
     * Since no values exist for this type, it cannot be serialised or deserialised.
     * Result types like `Result<Text, Empty>` should always succeed.
     */
    class EmptyClass extends PrimitiveType {
        accept(v, d) {
            return v.visitEmpty(this, d);
        }
        covariant(x) {
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue() {
            throw new Error('Empty cannot appear as a function argument');
        }
        valueToString() {
            throw new Error('Empty cannot appear as a value');
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-17 /* IDLTypeIds.Empty */);
        }
        decodeValue() {
            throw new Error('Empty cannot appear as an output');
        }
        get name() {
            return 'empty';
        }
    }
    /**
     * Represents an IDL Unknown, a placeholder type for deserialization only.
     * When decoding a value as Unknown, all fields will be retained but the names are only available in
     * hashed form.
     * A deserialized unknown will offer it's actual type by calling the `type()` function.
     * Unknown cannot be serialized and attempting to do so will throw an error.
     */
    class UnknownClass extends Type {
        checkType(t) {
            throw new Error('Method not implemented for unknown.');
        }
        accept(v, d) {
            throw v.visitType(this, d);
        }
        covariant(x) {
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue() {
            throw new Error('Unknown cannot appear as a function argument');
        }
        valueToString() {
            throw new Error('Unknown cannot appear as a value');
        }
        encodeType() {
            throw new Error('Unknown cannot be serialized');
        }
        decodeValue(b, t) {
            let decodedValue = t.decodeValue(b, t);
            if (Object(decodedValue) !== decodedValue) {
                // decodedValue is primitive. Box it, otherwise we cannot add the type() function.
                // The type() function is important for primitives because otherwise we cannot tell apart the
                // different number types.
                decodedValue = Object(decodedValue);
            }
            let typeFunc;
            if (t instanceof RecClass) {
                typeFunc = () => t.getType();
            }
            else {
                typeFunc = () => t;
            }
            // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property
            // 'type' which means it would be serialized if the value would be candid encoded again.
            // This in turn leads to problems if the decoded value is a variant because these values are
            // only allowed to have a single property.
            Object.defineProperty(decodedValue, 'type', {
                value: typeFunc,
                writable: true,
                enumerable: false,
                configurable: true,
            });
            return decodedValue;
        }
        _buildTypeTableImpl() {
            throw new Error('Unknown cannot be serialized');
        }
        get name() {
            return 'Unknown';
        }
    }
    /**
     * Represents an IDL Bool
     */
    class BoolClass extends PrimitiveType {
        accept(v, d) {
            return v.visitBool(this, d);
        }
        covariant(x) {
            if (typeof x === 'boolean')
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            return new Uint8Array([x ? 1 : 0]);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-2 /* IDLTypeIds.Bool */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {
                case 0:
                    return false;
                case 1:
                    return true;
                default:
                    throw new Error('Boolean value out of range');
            }
        }
        get name() {
            return 'bool';
        }
    }
    /**
     * Represents an IDL Null
     */
    class NullClass extends PrimitiveType {
        accept(v, d) {
            return v.visitNull(this, d);
        }
        covariant(x) {
            if (x === null)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue() {
            return new ArrayBuffer(0);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-1 /* IDLTypeIds.Null */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return null;
        }
        get name() {
            return 'null';
        }
    }
    /**
     * Represents an IDL Reserved
     */
    class ReservedClass extends PrimitiveType {
        accept(v, d) {
            return v.visitReserved(this, d);
        }
        covariant(x) {
            return true;
        }
        encodeValue() {
            return new ArrayBuffer(0);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-16 /* IDLTypeIds.Reserved */);
        }
        decodeValue(b, t) {
            if (t.name !== this.name) {
                t.decodeValue(b, t);
            }
            return null;
        }
        get name() {
            return 'reserved';
        }
    }
    /**
     * Represents an IDL Text
     */
    class TextClass extends PrimitiveType {
        accept(v, d) {
            return v.visitText(this, d);
        }
        covariant(x) {
            if (typeof x === 'string')
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const buf = new TextEncoder().encode(x);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-15 /* IDLTypeIds.Text */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);
            const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, Number(len));
            const decoder = new TextDecoder('utf8', { fatal: true });
            return decoder.decode(buf);
        }
        get name() {
            return 'text';
        }
        valueToString(x) {
            return '"' + x + '"';
        }
    }
    /**
     * Represents an IDL Int
     */
    class IntClass extends PrimitiveType {
        accept(v, d) {
            return v.visitInt(this, d);
        }
        covariant(x) {
            // We allow encoding of JavaScript plain numbers.
            // But we will always decode to bigint.
            if (typeof x === 'bigint' || Number.isInteger(x))
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(x);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-4 /* IDLTypeIds.Int */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(b);
        }
        get name() {
            return 'int';
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL Nat
     */
    class NatClass extends PrimitiveType {
        accept(v, d) {
            return v.visitNat(this, d);
        }
        covariant(x) {
            // We allow encoding of JavaScript plain numbers.
            // But we will always decode to bigint.
            if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0))
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-3 /* IDLTypeIds.Nat */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);
        }
        get name() {
            return 'nat';
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL Float
     */
    class FloatClass extends PrimitiveType {
        constructor(_bits) {
            super();
            this._bits = _bits;
            if (_bits !== 32 && _bits !== 64) {
                throw new Error('not a valid float type');
            }
        }
        accept(v, d) {
            return v.visitFloat(this, d);
        }
        covariant(x) {
            if (typeof x === 'number' || x instanceof Number)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const buf = new ArrayBuffer(this._bits / 8);
            const view = new DataView(buf);
            if (this._bits === 32) {
                view.setFloat32(0, x, true);
            }
            else {
                view.setFloat64(0, x, true);
            }
            return buf;
        }
        encodeType() {
            const opcode = this._bits === 32 ? -13 /* IDLTypeIds.Float32 */ : -14 /* IDLTypeIds.Float64 */;
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(opcode);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const bytes = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, this._bits / 8);
            const view = new DataView(bytes);
            if (this._bits === 32) {
                return view.getFloat32(0, true);
            }
            else {
                return view.getFloat64(0, true);
            }
        }
        get name() {
            return 'float' + this._bits;
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL fixed-width Int(n)
     */
    class FixedIntClass extends PrimitiveType {
        constructor(_bits) {
            super();
            this._bits = _bits;
        }
        accept(v, d) {
            return v.visitFixedInt(this, d);
        }
        covariant(x) {
            const min = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) * BigInt(-1);
            const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) - BigInt(1);
            let ok = false;
            if (typeof x === 'bigint') {
                ok = x >= min && x <= max;
            }
            else if (Number.isInteger(x)) {
                const v = BigInt(x);
                ok = v >= min && v <= max;
            }
            else {
                ok = false;
            }
            if (ok)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeIntLE)(x, this._bits / 8);
        }
        encodeType() {
            const offset = Math.log2(this._bits) - 3;
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-9 - offset);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readIntLE)(b, this._bits / 8);
            if (this._bits <= 32) {
                return Number(num);
            }
            else {
                return num;
            }
        }
        get name() {
            return `int${this._bits}`;
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL fixed-width Nat(n)
     */
    class FixedNatClass extends PrimitiveType {
        constructor(_bits) {
            super();
            this._bits = _bits;
        }
        accept(v, d) {
            return v.visitFixedNat(this, d);
        }
        covariant(x) {
            const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits);
            let ok = false;
            if (typeof x === 'bigint' && x >= BigInt(0)) {
                ok = x < max;
            }
            else if (Number.isInteger(x) && x >= 0) {
                const v = BigInt(x);
                ok = v < max;
            }
            else {
                ok = false;
            }
            if (ok)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeUIntLE)(x, this._bits / 8);
        }
        encodeType() {
            const offset = Math.log2(this._bits) - 3;
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-5 - offset);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readUIntLE)(b, this._bits / 8);
            if (this._bits <= 32) {
                return Number(num);
            }
            else {
                return num;
            }
        }
        get name() {
            return `nat${this._bits}`;
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL Array
     *
     * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).
     * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.
     * @param {Type} t
     */
    class VecClass extends ConstructType {
        constructor(_type) {
            super();
            this._type = _type;
            // If true, this vector is really a blob and we can just use memcpy.
            //
            // NOTE:
            // With support of encoding/dencoding of TypedArrays, this optimization is
            // only used when plain array of bytes are passed as encoding input in order
            // to be backward compatible.
            this._blobOptimization = false;
            if (_type instanceof FixedNatClass && _type._bits === 8) {
                this._blobOptimization = true;
            }
        }
        accept(v, d) {
            return v.visitVec(this, this._type, d);
        }
        covariant(x) {
            // Special case for ArrayBuffer
            const bits = this._type instanceof FixedNatClass
                ? this._type._bits
                : this._type instanceof FixedIntClass
                    ? this._type._bits
                    : 0;
            if ((ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8) ||
                (Array.isArray(x) &&
                    x.every((v, idx) => {
                        try {
                            return this._type.covariant(v);
                        }
                        catch (e) {
                            throw new Error(`Invalid ${this.display()} argument: \n\nindex ${idx} -> ${e.message}`);
                        }
                    })))
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x.length);
            if (this._blobOptimization) {
                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x));
            }
            if (ArrayBuffer.isView(x)) {
                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x.buffer));
            }
            const buf = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);
            buf.write(len);
            for (const d of x) {
                const encoded = this._type.encodeValue(d);
                buf.write(new Uint8Array(encoded));
            }
            return buf.buffer;
        }
        _buildTypeTableImpl(typeTable) {
            this._type.buildTypeTable(typeTable);
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-19 /* IDLTypeIds.Vector */);
            const buffer = this._type.encodeType(typeTable);
            typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));
        }
        decodeValue(b, t) {
            const vec = this.checkType(t);
            if (!(vec instanceof VecClass)) {
                throw new Error('Not a vector type');
            }
            const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));
            if (this._type instanceof FixedNatClass) {
                if (this._type._bits == 8) {
                    return new Uint8Array(b.read(len));
                }
                if (this._type._bits == 16) {
                    return new Uint16Array(b.read(len * 2));
                }
                if (this._type._bits == 32) {
                    return new Uint32Array(b.read(len * 4));
                }
                if (this._type._bits == 64) {
                    return new BigUint64Array(b.read(len * 8));
                }
            }
            if (this._type instanceof FixedIntClass) {
                if (this._type._bits == 8) {
                    return new Int8Array(b.read(len));
                }
                if (this._type._bits == 16) {
                    return new Int16Array(b.read(len * 2));
                }
                if (this._type._bits == 32) {
                    return new Int32Array(b.read(len * 4));
                }
                if (this._type._bits == 64) {
                    return new BigInt64Array(b.read(len * 8));
                }
            }
            const rets = [];
            for (let i = 0; i < len; i++) {
                rets.push(this._type.decodeValue(b, vec._type));
            }
            return rets;
        }
        get name() {
            return `vec ${this._type.name}`;
        }
        display() {
            return `vec ${this._type.display()}`;
        }
        valueToString(x) {
            const elements = x.map(e => this._type.valueToString(e));
            return 'vec {' + elements.join('; ') + '}';
        }
    }
    /**
     * Represents an IDL Option
     * @param {Type} t
     */
    class OptClass extends ConstructType {
        constructor(_type) {
            super();
            this._type = _type;
        }
        accept(v, d) {
            return v.visitOpt(this, this._type, d);
        }
        covariant(x) {
            try {
                if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))
                    return true;
            }
            catch (e) {
                throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \n\n-> ${e.message}`);
            }
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            if (x.length === 0) {
                return new Uint8Array([0]);
            }
            else {
                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));
            }
        }
        _buildTypeTableImpl(typeTable) {
            this._type.buildTypeTable(typeTable);
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-18 /* IDLTypeIds.Opt */);
            const buffer = this._type.encodeType(typeTable);
            typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));
        }
        decodeValue(b, t) {
            const opt = this.checkType(t);
            if (!(opt instanceof OptClass)) {
                throw new Error('Not an option type');
            }
            switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {
                case 0:
                    return [];
                case 1:
                    return [this._type.decodeValue(b, opt._type)];
                default:
                    throw new Error('Not an option value');
            }
        }
        get name() {
            return `opt ${this._type.name}`;
        }
        display() {
            return `opt ${this._type.display()}`;
        }
        valueToString(x) {
            if (x.length === 0) {
                return 'null';
            }
            else {
                return `opt ${this._type.valueToString(x[0])}`;
            }
        }
    }
    /**
     * Represents an IDL Record
     * @param {object} [fields] - mapping of function name to Type
     */
    class RecordClass extends ConstructType {
        constructor(fields = {}) {
            super();
            this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));
        }
        accept(v, d) {
            return v.visitRecord(this, this._fields, d);
        }
        tryAsTuple() {
            const res = [];
            for (let i = 0; i < this._fields.length; i++) {
                const [key, type] = this._fields[i];
                if (key !== `_${i}_`) {
                    return null;
                }
                res.push(type);
            }
            return res;
        }
        covariant(x) {
            if (typeof x === 'object' &&
                this._fields.every(([k, t]) => {
                    // eslint-disable-next-line
                    if (!x.hasOwnProperty(k)) {
                        throw new Error(`Record is missing key "${k}".`);
                    }
                    try {
                        return t.covariant(x[k]);
                    }
                    catch (e) {
                        throw new Error(`Invalid ${this.display()} argument: \n\nfield ${k} -> ${e.message}`);
                    }
                }))
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const values = this._fields.map(([key]) => x[key]);
            const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);
        }
        _buildTypeTableImpl(T) {
            this._fields.forEach(([_, value]) => value.buildTypeTable(T));
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-20 /* IDLTypeIds.Record */);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);
            const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(T)));
            T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...fields)));
        }
        decodeValue(b, t) {
            const record = this.checkType(t);
            if (!(record instanceof RecordClass)) {
                throw new Error('Not a record type');
            }
            const x = {};
            let expectedRecordIdx = 0;
            let actualRecordIdx = 0;
            while (actualRecordIdx < record._fields.length) {
                const [hash, type] = record._fields[actualRecordIdx];
                if (expectedRecordIdx >= this._fields.length) {
                    // skip unexpected left over fields present on the wire
                    type.decodeValue(b, type);
                    actualRecordIdx++;
                    continue;
                }
                const [expectKey, expectType] = this._fields[expectedRecordIdx];
                const expectedId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(this._fields[expectedRecordIdx][0]);
                const actualId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(hash);
                if (expectedId === actualId) {
                    // the current field on the wire matches the expected field
                    x[expectKey] = expectType.decodeValue(b, type);
                    expectedRecordIdx++;
                    actualRecordIdx++;
                }
                else if (actualId > expectedId) {
                    // The expected field does not exist on the wire
                    if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
                        x[expectKey] = [];
                        expectedRecordIdx++;
                    }
                    else {
                        throw new Error('Cannot find required field ' + expectKey);
                    }
                }
                else {
                    // The field on the wire does not exist in the output type, so we can skip it
                    type.decodeValue(b, type);
                    actualRecordIdx++;
                }
            }
            // initialize left over expected optional fields
            for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {
                if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
                    // TODO this assumes null value in opt is represented as []
                    x[expectKey] = [];
                }
                else {
                    throw new Error('Cannot find required field ' + expectKey);
                }
            }
            return x;
        }
        get name() {
            const fields = this._fields.map(([key, value]) => key + ':' + value.name);
            return `record {${fields.join('; ')}}`;
        }
        display() {
            const fields = this._fields.map(([key, value]) => key + ':' + value.display());
            return `record {${fields.join('; ')}}`;
        }
        valueToString(x) {
            const values = this._fields.map(([key]) => x[key]);
            const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));
            return `record {${fields.join('; ')}}`;
        }
    }
    /**
     * Represents Tuple, a syntactic sugar for Record.
     * @param {Type} components
     */
    class TupleClass extends RecordClass {
        constructor(_components) {
            const x = {};
            _components.forEach((e, i) => (x['_' + i + '_'] = e));
            super(x);
            this._components = _components;
        }
        accept(v, d) {
            return v.visitTuple(this, this._components, d);
        }
        covariant(x) {
            // `>=` because tuples can be covariant when encoded.
            if (Array.isArray(x) &&
                x.length >= this._fields.length &&
                this._components.every((t, i) => {
                    try {
                        return t.covariant(x[i]);
                    }
                    catch (e) {
                        throw new Error(`Invalid ${this.display()} argument: \n\nindex ${i} -> ${e.message}`);
                    }
                }))
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);
        }
        decodeValue(b, t) {
            const tuple = this.checkType(t);
            if (!(tuple instanceof TupleClass)) {
                throw new Error('not a tuple type');
            }
            if (tuple._components.length < this._components.length) {
                throw new Error('tuple mismatch');
            }
            const res = [];
            for (const [i, wireType] of tuple._components.entries()) {
                if (i >= this._components.length) {
                    // skip value
                    wireType.decodeValue(b, wireType);
                }
                else {
                    res.push(this._components[i].decodeValue(b, wireType));
                }
            }
            return res;
        }
        display() {
            const fields = this._components.map(value => value.display());
            return `record {${fields.join('; ')}}`;
        }
        valueToString(values) {
            const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));
            return `record {${fields.join('; ')}}`;
        }
    }
    /**
     * Represents an IDL Variant
     * @param {object} [fields] - mapping of function name to Type
     */
    class VariantClass extends ConstructType {
        constructor(fields = {}) {
            super();
            this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));
        }
        accept(v, d) {
            return v.visitVariant(this, this._fields, d);
        }
        covariant(x) {
            if (typeof x === 'object' &&
                Object.entries(x).length === 1 &&
                this._fields.every(([k, v]) => {
                    try {
                        // eslint-disable-next-line
                        return !x.hasOwnProperty(k) || v.covariant(x[k]);
                    }
                    catch (e) {
                        throw new Error(`Invalid ${this.display()} argument: \n\nvariant ${k} -> ${e.message}`);
                    }
                }))
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            for (let i = 0; i < this._fields.length; i++) {
                const [name, type] = this._fields[i];
                // eslint-disable-next-line
                if (x.hasOwnProperty(name)) {
                    const idx = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(i);
                    const buf = type.encodeValue(x[name]);
                    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(idx, buf);
                }
            }
            throw Error('Variant has no data: ' + x);
        }
        _buildTypeTableImpl(typeTable) {
            this._fields.forEach(([, type]) => {
                type.buildTypeTable(typeTable);
            });
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-21 /* IDLTypeIds.Variant */);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);
            const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(typeTable)));
            typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...fields));
        }
        decodeValue(b, t) {
            const variant = this.checkType(t);
            if (!(variant instanceof VariantClass)) {
                throw new Error('Not a variant type');
            }
            const idx = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));
            if (idx >= variant._fields.length) {
                throw Error('Invalid variant index: ' + idx);
            }
            const [wireHash, wireType] = variant._fields[idx];
            for (const [key, expectType] of this._fields) {
                if ((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(wireHash) === (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)) {
                    const value = expectType.decodeValue(b, wireType);
                    return { [key]: value };
                }
            }
            throw new Error('Cannot find field hash ' + wireHash);
        }
        get name() {
            const fields = this._fields.map(([key, type]) => key + ':' + type.name);
            return `variant {${fields.join('; ')}}`;
        }
        display() {
            const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));
            return `variant {${fields.join('; ')}}`;
        }
        valueToString(x) {
            for (const [name, type] of this._fields) {
                // eslint-disable-next-line
                if (x.hasOwnProperty(name)) {
                    const value = type.valueToString(x[name]);
                    if (value === 'null') {
                        return `variant {${name}}`;
                    }
                    else {
                        return `variant {${name}=${value}}`;
                    }
                }
            }
            throw new Error('Variant has no data: ' + x);
        }
    }
    /**
     * Represents a reference to an IDL type, used for defining recursive data
     * types.
     */
    class RecClass extends ConstructType {
        constructor() {
            super(...arguments);
            this._id = RecClass._counter++;
            this._type = undefined;
        }
        accept(v, d) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return v.visitRec(this, this._type, d);
        }
        fill(t) {
            this._type = t;
        }
        getType() {
            return this._type;
        }
        covariant(x) {
            if (this._type ? this._type.covariant(x) : false)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return this._type.encodeValue(x);
        }
        _buildTypeTableImpl(typeTable) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            typeTable.add(this, new Uint8Array([]));
            this._type.buildTypeTable(typeTable);
            typeTable.merge(this, this._type.name);
        }
        decodeValue(b, t) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return this._type.decodeValue(b, t);
        }
        get name() {
            return `rec_${this._id}`;
        }
        display() {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return `${this.name}.${this._type.name}`;
        }
        valueToString(x) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return this._type.valueToString(x);
        }
    }
    RecClass._counter = 0;
    function decodePrincipalId(b) {
        const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);
        if (x !== 1) {
            throw new Error('Cannot decode principal');
        }
        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));
        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, len)));
    }
    /**
     * Represents an IDL principal reference
     */
    class PrincipalClass extends PrimitiveType {
        accept(v, d) {
            return v.visitPrincipal(this, d);
        }
        covariant(x) {
            if (x && x._isPrincipal)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const buf = x.toUint8Array();
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-24 /* IDLTypeIds.Principal */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return decodePrincipalId(b);
        }
        get name() {
            return 'principal';
        }
        valueToString(x) {
            return `${this.name} "${x.toText()}"`;
        }
    }
    /**
     * Represents an IDL function reference.
     * @param argTypes Argument types.
     * @param retTypes Return types.
     * @param annotations Function annotations.
     */
    class FuncClass extends ConstructType {
        constructor(argTypes, retTypes, annotations = []) {
            super();
            this.argTypes = argTypes;
            this.retTypes = retTypes;
            this.annotations = annotations;
        }
        static argsToString(types, v) {
            if (types.length !== v.length) {
                throw new Error('arity mismatch');
            }
            return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';
        }
        accept(v, d) {
            return v.visitFunc(this, d);
        }
        covariant(x) {
            if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue([principal, methodName]) {
            const buf = principal.toUint8Array();
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);
            const canister = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);
            const method = new TextEncoder().encode(methodName);
            const methodLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(method.byteLength);
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), canister, methodLen, method);
        }
        _buildTypeTableImpl(T) {
            this.argTypes.forEach(arg => arg.buildTypeTable(T));
            this.retTypes.forEach(arg => arg.buildTypeTable(T));
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-22 /* IDLTypeIds.Func */);
            const argLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.argTypes.length);
            const args = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.argTypes.map(arg => arg.encodeType(T)));
            const retLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.retTypes.length);
            const rets = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.retTypes.map(arg => arg.encodeType(T)));
            const annLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.annotations.length);
            const anns = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.annotations.map(a => this.encodeAnnotation(a)));
            T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, argLen, args, retLen, rets, annLen, anns));
        }
        decodeValue(b) {
            const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);
            if (x !== 1) {
                throw new Error('Cannot decode function reference');
            }
            const canister = decodePrincipalId(b);
            const mLen = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));
            const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, mLen);
            const decoder = new TextDecoder('utf8', { fatal: true });
            const method = decoder.decode(buf);
            return [canister, method];
        }
        get name() {
            const args = this.argTypes.map(arg => arg.name).join(', ');
            const rets = this.retTypes.map(arg => arg.name).join(', ');
            const annon = ' ' + this.annotations.join(' ');
            return `(${args}) -> (${rets})${annon}`;
        }
        valueToString([principal, str]) {
            return `func "${principal.toText()}".${str}`;
        }
        display() {
            const args = this.argTypes.map(arg => arg.display()).join(', ');
            const rets = this.retTypes.map(arg => arg.display()).join(', ');
            const annon = ' ' + this.annotations.join(' ');
            return `(${args})  (${rets})${annon}`;
        }
        encodeAnnotation(ann) {
            if (ann === 'query') {
                return new Uint8Array([1]);
            }
            else if (ann === 'oneway') {
                return new Uint8Array([2]);
            }
            else if (ann === 'composite_query') {
                return new Uint8Array([3]);
            }
            else {
                throw new Error('Illegal function annotation');
            }
        }
    }
    class ServiceClass extends ConstructType {
        constructor(fields) {
            super();
            this._fields = Object.entries(fields).sort((a, b) => {
                if (a[0] < b[0]) {
                    return -1;
                }
                if (a[0] > b[0]) {
                    return 1;
                }
                return 0;
            });
        }
        accept(v, d) {
            return v.visitService(this, d);
        }
        covariant(x) {
            if (x && x._isPrincipal)
                return true;
            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
        }
        encodeValue(x) {
            const buf = x.toUint8Array();
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.length);
            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);
        }
        _buildTypeTableImpl(T) {
            this._fields.forEach(([_, func]) => func.buildTypeTable(T));
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-23 /* IDLTypeIds.Service */);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);
            const meths = this._fields.map(([label, func]) => {
                const labelBuf = new TextEncoder().encode(label);
                const labelLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(labelBuf.length);
                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(labelLen, labelBuf, func.encodeType(T));
            });
            T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...meths));
        }
        decodeValue(b) {
            return decodePrincipalId(b);
        }
        get name() {
            const fields = this._fields.map(([key, value]) => key + ':' + value.name);
            return `service {${fields.join('; ')}}`;
        }
        valueToString(x) {
            return `service "${x.toText()}"`;
        }
    }
    /**
     * Takes an unknown value and returns a string representation of it.
     * @param x - unknown value
     * @returns {string} string representation of the value
     */
    function toReadableString(x) {
        const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);
        return str && str.length > toReadableString_max
            ? str.substring(0, toReadableString_max - 3) + '...'
            : str;
    }
    /**
     * Encode a array of values
     * @param argTypes - array of Types
     * @param args - array of values
     * @returns {ArrayBuffer} serialised value
     */
    function encode(argTypes, args) {
        if (args.length < argTypes.length) {
            throw Error('Wrong number of message arguments');
        }
        const typeTable = new TypeTable();
        argTypes.forEach(t => t.buildTypeTable(typeTable));
        const magic = new TextEncoder().encode(magicNumber);
        const table = typeTable.encode();
        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(args.length);
        const typs = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...argTypes.map(t => t.encodeType(typeTable)));
        const vals = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...zipWith(argTypes, args, (t, x) => {
            try {
                t.covariant(x);
            }
            catch (e) {
                const err = new Error(e.message + '\n\n');
                throw err;
            }
            return t.encodeValue(x);
        }));
        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(magic, table, len, typs, vals);
    }
    /**
     * Decode a binary value
     * @param retTypes - Types expected in the buffer.
     * @param bytes - hex-encoded string, or buffer.
     * @returns Value deserialised to JS type
     */
    function decode(retTypes, bytes) {
        const b = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(bytes);
        if (bytes.byteLength < magicNumber.length) {
            throw new Error('Message length smaller than magic number');
        }
        const magicBuffer = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, magicNumber.length);
        const magic = new TextDecoder().decode(magicBuffer);
        if (magic !== magicNumber) {
            throw new Error('Wrong magic number: ' + JSON.stringify(magic));
        }
        function readTypeTable(pipe) {
            const typeTable = [];
            const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
            for (let i = 0; i < len; i++) {
                const ty = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));
                switch (ty) {
                    case -18 /* IDLTypeIds.Opt */:
                    case -19 /* IDLTypeIds.Vector */: {
                        const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));
                        typeTable.push([ty, t]);
                        break;
                    }
                    case -20 /* IDLTypeIds.Record */:
                    case -21 /* IDLTypeIds.Variant */: {
                        const fields = [];
                        let objectLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                        let prevHash;
                        while (objectLength--) {
                            const hash = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                            if (hash >= Math.pow(2, 32)) {
                                throw new Error('field id out of 32-bit range');
                            }
                            if (typeof prevHash === 'number' && prevHash >= hash) {
                                throw new Error('field id collision or not sorted');
                            }
                            prevHash = hash;
                            const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));
                            fields.push([hash, t]);
                        }
                        typeTable.push([ty, fields]);
                        break;
                    }
                    case -22 /* IDLTypeIds.Func */: {
                        const args = [];
                        let argLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                        while (argLength--) {
                            args.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));
                        }
                        const returnValues = [];
                        let returnValuesLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                        while (returnValuesLength--) {
                            returnValues.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));
                        }
                        const annotations = [];
                        let annotationLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                        while (annotationLength--) {
                            const annotation = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                            switch (annotation) {
                                case 1: {
                                    annotations.push('query');
                                    break;
                                }
                                case 2: {
                                    annotations.push('oneway');
                                    break;
                                }
                                case 3: {
                                    annotations.push('composite_query');
                                    break;
                                }
                                default:
                                    throw new Error('unknown annotation');
                            }
                        }
                        typeTable.push([ty, [args, returnValues, annotations]]);
                        break;
                    }
                    case -23 /* IDLTypeIds.Service */: {
                        let servLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                        const methods = [];
                        while (servLength--) {
                            const nameLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
                            const funcName = new TextDecoder().decode((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(pipe, nameLength));
                            const funcType = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe);
                            methods.push([funcName, funcType]);
                        }
                        typeTable.push([ty, methods]);
                        break;
                    }
                    default:
                        throw new Error('Illegal op_code: ' + ty);
                }
            }
            const rawList = [];
            const length = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));
            for (let i = 0; i < length; i++) {
                rawList.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));
            }
            return [typeTable, rawList];
        }
        const [rawTable, rawTypes] = readTypeTable(b);
        if (rawTypes.length < retTypes.length) {
            throw new Error('Wrong number of return values');
        }
        const table = rawTable.map(_ => Rec());
        function getType(t) {
            if (t < -24) {
                throw new Error('future value not supported');
            }
            if (t < 0) {
                switch (t) {
                    case -1:
                        return Null;
                    case -2:
                        return Bool;
                    case -3:
                        return Nat;
                    case -4:
                        return Int;
                    case -5:
                        return Nat8;
                    case -6:
                        return Nat16;
                    case -7:
                        return Nat32;
                    case -8:
                        return Nat64;
                    case -9:
                        return Int8;
                    case -10:
                        return Int16;
                    case -11:
                        return Int32;
                    case -12:
                        return Int64;
                    case -13:
                        return Float32;
                    case -14:
                        return Float64;
                    case -15:
                        return Text;
                    case -16:
                        return Reserved;
                    case -17:
                        return Empty;
                    case -24:
                        return Principal;
                    default:
                        throw new Error('Illegal op_code: ' + t);
                }
            }
            if (t >= rawTable.length) {
                throw new Error('type index out of range');
            }
            return table[t];
        }
        function buildType(entry) {
            switch (entry[0]) {
                case -19 /* IDLTypeIds.Vector */: {
                    const ty = getType(entry[1]);
                    return Vec(ty);
                }
                case -18 /* IDLTypeIds.Opt */: {
                    const ty = getType(entry[1]);
                    return Opt(ty);
                }
                case -20 /* IDLTypeIds.Record */: {
                    const fields = {};
                    for (const [hash, ty] of entry[1]) {
                        const name = `_${hash}_`;
                        fields[name] = getType(ty);
                    }
                    const record = Record(fields);
                    const tuple = record.tryAsTuple();
                    if (Array.isArray(tuple)) {
                        return Tuple(...tuple);
                    }
                    else {
                        return record;
                    }
                }
                case -21 /* IDLTypeIds.Variant */: {
                    const fields = {};
                    for (const [hash, ty] of entry[1]) {
                        const name = `_${hash}_`;
                        fields[name] = getType(ty);
                    }
                    return Variant(fields);
                }
                case -22 /* IDLTypeIds.Func */: {
                    const [args, returnValues, annotations] = entry[1];
                    return Func(args.map((t) => getType(t)), returnValues.map((t) => getType(t)), annotations);
                }
                case -23 /* IDLTypeIds.Service */: {
                    const rec = {};
                    const methods = entry[1];
                    for (const [name, typeRef] of methods) {
                        let type = getType(typeRef);
                        if (type instanceof RecClass) {
                            // unpack reference type
                            type = type.getType();
                        }
                        if (!(type instanceof FuncClass)) {
                            throw new Error('Illegal service definition: services can only contain functions');
                        }
                        rec[name] = type;
                    }
                    return Service(rec);
                }
                default:
                    throw new Error('Illegal op_code: ' + entry[0]);
            }
        }
        rawTable.forEach((entry, i) => {
            // Process function type first, so that we can construct the correct service type
            if (entry[0] === -22 /* IDLTypeIds.Func */) {
                const t = buildType(entry);
                table[i].fill(t);
            }
        });
        rawTable.forEach((entry, i) => {
            if (entry[0] !== -22 /* IDLTypeIds.Func */) {
                const t = buildType(entry);
                table[i].fill(t);
            }
        });
        const types = rawTypes.map(t => getType(t));
        const output = retTypes.map((t, i) => {
            return t.decodeValue(b, types[i]);
        });
        // skip unused values
        for (let ind = retTypes.length; ind < types.length; ind++) {
            types[ind].decodeValue(b, types[ind]);
        }
        if (b.byteLength > 0) {
            throw new Error('decode: Left-over bytes');
        }
        return output;
    }
    // Export Types instances.
    const Empty = new EmptyClass();
    const Reserved = new ReservedClass();
    /**
     * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.
     */
    const Unknown = new UnknownClass();
    const Bool = new BoolClass();
    const Null = new NullClass();
    const Text = new TextClass();
    const Int = new IntClass();
    const Nat = new NatClass();
    const Float32 = new FloatClass(32);
    const Float64 = new FloatClass(64);
    const Int8 = new FixedIntClass(8);
    const Int16 = new FixedIntClass(16);
    const Int32 = new FixedIntClass(32);
    const Int64 = new FixedIntClass(64);
    const Nat8 = new FixedNatClass(8);
    const Nat16 = new FixedNatClass(16);
    const Nat32 = new FixedNatClass(32);
    const Nat64 = new FixedNatClass(64);
    const Principal = new PrincipalClass();
    /**
     *
     * @param types array of any types
     * @returns TupleClass from those types
     */
    function Tuple(...types) {
        return new TupleClass(types);
    }
    /**
     *
     * @param t IDL Type
     * @returns VecClass from that type
     */
    function Vec(t) {
        return new VecClass(t);
    }
    /**
     *
     * @param t IDL Type
     * @returns OptClass of Type
     */
    function Opt(t) {
        return new OptClass(t);
    }
    /**
     *
     * @param t Record of string and IDL Type
     * @returns RecordClass of string and Type
     */
    function Record(t) {
        return new RecordClass(t);
    }
    /**
     *
     * @param fields Record of string and IDL Type
     * @returns VariantClass
     */
    function Variant(fields) {
        return new VariantClass(fields);
    }
    /**
     *
     * @returns new RecClass
     */
    function Rec() {
        return new RecClass();
    }
    /**
     *
     * @param args array of IDL Types
     * @param ret array of IDL Types
     * @param annotations array of strings, [] by default
     * @returns new FuncClass
     */
    function Func(args, ret, annotations = []) {
        return new FuncClass(args, ret, annotations);
    }
    /**
     *
     * @param t Record of string and FuncClass
     * @returns ServiceClass
     */
    function Service(t) {
        return new ServiceClass(t);
    }
    //# sourceMappingURL=idl.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/index.js":
    /*!*******************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/index.js ***!
      \*******************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   IDL: () => (/* reexport module object */ _idl__WEBPACK_IMPORTED_MODULE_2__),
    /* harmony export */   InputBox: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputBox),
    /* harmony export */   InputForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputForm),
    /* harmony export */   OptionForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.OptionForm),
    /* harmony export */   PipeArrayBuffer: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.PipeArrayBuffer),
    /* harmony export */   RecordForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.RecordForm),
    /* harmony export */   Render: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.Render),
    /* harmony export */   TupleForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.TupleForm),
    /* harmony export */   VariantForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VariantForm),
    /* harmony export */   VecForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VecForm),
    /* harmony export */   bufFromBufLike: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.bufFromBufLike),
    /* harmony export */   concat: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat),
    /* harmony export */   fromHexString: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHexString),
    /* harmony export */   idlLabelToId: () => (/* reexport safe */ _utils_hash__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId),
    /* harmony export */   inputBox: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.inputBox),
    /* harmony export */   lebDecode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebDecode),
    /* harmony export */   lebEncode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebEncode),
    /* harmony export */   optForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.optForm),
    /* harmony export */   readIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readIntLE),
    /* harmony export */   readUIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readUIntLE),
    /* harmony export */   recordForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.recordForm),
    /* harmony export */   renderInput: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderInput),
    /* harmony export */   renderValue: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderValue),
    /* harmony export */   safeRead: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeRead),
    /* harmony export */   safeReadUint8: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeReadUint8),
    /* harmony export */   slebDecode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebDecode),
    /* harmony export */   slebEncode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebEncode),
    /* harmony export */   toHexString: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.toHexString),
    /* harmony export */   tupleForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.tupleForm),
    /* harmony export */   uint8ToBuf: () => (/* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.uint8ToBuf),
    /* harmony export */   variantForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.variantForm),
    /* harmony export */   vecForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.vecForm),
    /* harmony export */   writeIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeIntLE),
    /* harmony export */   writeUIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeUIntLE)
    /* harmony export */ });
    /* harmony import */ var _candid_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candid-ui */ "./node_modules/@dfinity/candid/lib/esm/candid-ui.js");
    /* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./candid-core */ "./node_modules/@dfinity/candid/lib/esm/candid-core.js");
    /* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl */ "./node_modules/@dfinity/candid/lib/esm/idl.js");
    /* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/hash */ "./node_modules/@dfinity/candid/lib/esm/utils/hash.js");
    /* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/leb128 */ "./node_modules/@dfinity/candid/lib/esm/utils/leb128.js");
    /* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/buffer */ "./node_modules/@dfinity/candid/lib/esm/utils/buffer.js");
    /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ "./node_modules/@dfinity/candid/lib/esm/types.js");
    
    
    
    
    
    
    
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/types.js":
    /*!*******************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/types.js ***!
      \*******************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    
    //# sourceMappingURL=types.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js ***!
      \*******************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   iexp2: () => (/* binding */ iexp2),
    /* harmony export */   ilog2: () => (/* binding */ ilog2)
    /* harmony export */ });
    /**
     * Equivalent to `Math.log2(n)` with support for `BigInt` values
     * @param n bigint or integer
     * @returns integer
     */
    function ilog2(n) {
        const nBig = BigInt(n);
        if (n <= 0) {
            throw new RangeError('Input must be positive');
        }
        return nBig.toString(2).length - 1;
    }
    /**
     * Equivalent to `2 ** n` with support for `BigInt` values
     * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)
     * @param n bigint or integer
     * @returns bigint
     */
    function iexp2(n) {
        const nBig = BigInt(n);
        if (n < 0) {
            throw new RangeError('Input must be non-negative');
        }
        return BigInt(1) << nBig;
    }
    //# sourceMappingURL=bigint-math.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/utils/buffer.js":
    /*!**************************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/utils/buffer.js ***!
      \**************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   PipeArrayBuffer: () => (/* binding */ PipeArrayBuffer),
    /* harmony export */   bufFromBufLike: () => (/* binding */ bufFromBufLike),
    /* harmony export */   concat: () => (/* binding */ concat),
    /* harmony export */   fromHexString: () => (/* binding */ fromHexString),
    /* harmony export */   toHexString: () => (/* binding */ toHexString),
    /* harmony export */   uint8ToBuf: () => (/* binding */ uint8ToBuf)
    /* harmony export */ });
    /**
     * Concatenate multiple array buffers.
     * @param buffers The buffers to concatenate.
     */
    function concat(...buffers) {
        const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
        let index = 0;
        for (const b of buffers) {
            result.set(new Uint8Array(b), index);
            index += b.byteLength;
        }
        return result;
    }
    /**
     * Returns an hexadecimal representation of an array buffer.
     * @param bytes The array buffer.
     */
    function toHexString(bytes) {
        return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
    }
    /**
     * Return an array buffer from its hexadecimal representation.
     * @param hexString The hexadecimal string.
     */
    function fromHexString(hexString) {
        var _a;
        return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));
    }
    /**
     * A class that abstracts a pipe-like ArrayBuffer.
     */
    class PipeArrayBuffer {
        /**
         * Creates a new instance of a pipe
         * @param buffer an optional buffer to start with
         * @param length an optional amount of bytes to use for the length.
         */
        constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {
            this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));
            this._view = new Uint8Array(this._buffer, 0, length);
        }
        get buffer() {
            // Return a copy of the buffer.
            return bufFromBufLike(this._view.slice());
        }
        get byteLength() {
            return this._view.byteLength;
        }
        /**
         * Read `num` number of bytes from the front of the pipe.
         * @param num The number of bytes to read.
         */
        read(num) {
            const result = this._view.subarray(0, num);
            this._view = this._view.subarray(num);
            return result.slice().buffer;
        }
        readUint8() {
            const result = this._view[0];
            this._view = this._view.subarray(1);
            return result;
        }
        /**
         * Write a buffer to the end of the pipe.
         * @param buf The bytes to write.
         */
        write(buf) {
            const b = new Uint8Array(buf);
            const offset = this._view.byteLength;
            if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {
                // Alloc grow the view to include the new bytes.
                this.alloc(b.byteLength);
            }
            else {
                // Update the view to include the new bytes.
                this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);
            }
            this._view.set(b, offset);
        }
        /**
         * Whether or not there is more data to read from the buffer
         */
        get end() {
            return this._view.byteLength === 0;
        }
        /**
         * Allocate a fixed amount of memory in the buffer. This does not affect the view.
         * @param amount A number of bytes to add to the buffer.
         */
        alloc(amount) {
            // Add a little bit of exponential growth.
            const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);
            const v = new Uint8Array(b, 0, this._view.byteLength + amount);
            v.set(this._view);
            this._buffer = b;
            this._view = v;
        }
    }
    /**
     * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.
     * @param {Uint8Array} arr Uint8Array to convert
     * @returns ArrayBuffer
     */
    function uint8ToBuf(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;
    }
    /**
     * Returns a true ArrayBuffer from an ArrayBufferLike object.
     * @param bufLike a buffer-like object
     * @returns ArrayBuffer
     */
    function bufFromBufLike(bufLike) {
        if (bufLike instanceof Uint8Array) {
            return uint8ToBuf(bufLike);
        }
        if (bufLike instanceof ArrayBuffer) {
            return bufLike;
        }
        if ('buffer' in bufLike) {
            return bufLike.buffer;
        }
        return new Uint8Array(bufLike);
    }
    //# sourceMappingURL=buffer.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/utils/hash.js":
    /*!************************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/utils/hash.js ***!
      \************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   idlLabelToId: () => (/* binding */ idlLabelToId)
    /* harmony export */ });
    /**
     * Hashes a string to a number. Algorithm can be found here:
     * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf
     * @param s - string to hash
     * @returns number representing hashed string
     */
    function idlHash(s) {
        const utf8encoder = new TextEncoder();
        const array = utf8encoder.encode(s);
        let h = 0;
        for (const c of array) {
            h = (h * 223 + c) % 2 ** 32;
        }
        return h;
    }
    /**
     *
     * @param label string
     * @returns number representing hashed label
     */
    function idlLabelToId(label) {
        if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
            const num = +label.slice(1, -1);
            if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
                return num;
            }
        }
        return idlHash(label);
    }
    //# sourceMappingURL=hash.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/candid/lib/esm/utils/leb128.js":
    /*!**************************************************************!*\
      !*** ./node_modules/@dfinity/candid/lib/esm/utils/leb128.js ***!
      \**************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   lebDecode: () => (/* binding */ lebDecode),
    /* harmony export */   lebEncode: () => (/* binding */ lebEncode),
    /* harmony export */   readIntLE: () => (/* binding */ readIntLE),
    /* harmony export */   readUIntLE: () => (/* binding */ readUIntLE),
    /* harmony export */   safeRead: () => (/* binding */ safeRead),
    /* harmony export */   safeReadUint8: () => (/* binding */ safeReadUint8),
    /* harmony export */   slebDecode: () => (/* binding */ slebDecode),
    /* harmony export */   slebEncode: () => (/* binding */ slebEncode),
    /* harmony export */   writeIntLE: () => (/* binding */ writeIntLE),
    /* harmony export */   writeUIntLE: () => (/* binding */ writeUIntLE)
    /* harmony export */ });
    /* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ "./node_modules/@dfinity/candid/lib/esm/utils/buffer.js");
    /* eslint-disable no-constant-condition */
    // Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer
    //       implementation, which isn't compatible with the NPM buffer package
    //       which we use everywhere else. This means that we have to transform
    //       one into the other, hence why every function that returns a Buffer
    //       actually return `new Buffer(pipe.buffer)`.
    // TODO: The best solution would be to have our own buffer type around
    //       Uint8Array which is standard.
    
    function eob() {
        throw new Error('unexpected end of buffer');
    }
    /**
     *
     * @param pipe Pipe from buffer-pipe
     * @param num number
     * @returns Buffer
     */
    function safeRead(pipe, num) {
        if (pipe.byteLength < num) {
            eob();
        }
        return pipe.read(num);
    }
    /**
     * @param pipe - PipeArrayBuffer simulating buffer-pipe api
     */
    function safeReadUint8(pipe) {
        const byte = pipe.readUint8();
        if (byte === undefined) {
            eob();
        }
        return byte;
    }
    /**
     * Encode a positive number (or bigint) into a Buffer. The number will be floored to the
     * nearest integer.
     * @param value The number to encode.
     */
    function lebEncode(value) {
        if (typeof value === 'number') {
            value = BigInt(value);
        }
        if (value < BigInt(0)) {
            throw new Error('Cannot leb encode negative values.');
        }
        const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
        const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
        while (true) {
            const i = Number(value & BigInt(0x7f));
            value /= BigInt(0x80);
            if (value === BigInt(0)) {
                pipe.write(new Uint8Array([i]));
                break;
            }
            else {
                pipe.write(new Uint8Array([i | 0x80]));
            }
        }
        return pipe.buffer;
    }
    /**
     * Decode a leb encoded buffer into a bigint. The number will always be positive (does not
     * support signed leb encoding).
     * @param pipe A Buffer containing the leb encoded bits.
     */
    function lebDecode(pipe) {
        let weight = BigInt(1);
        let value = BigInt(0);
        let byte;
        do {
            byte = safeReadUint8(pipe);
            value += BigInt(byte & 0x7f).valueOf() * weight;
            weight *= BigInt(128);
        } while (byte >= 0x80);
        return value;
    }
    /**
     * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number
     * will be floored to the nearest integer.
     * @param value The number to encode.
     */
    function slebEncode(value) {
        if (typeof value === 'number') {
            value = BigInt(value);
        }
        const isNeg = value < BigInt(0);
        if (isNeg) {
            value = -value - BigInt(1);
        }
        const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
        const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
        while (true) {
            const i = getLowerBytes(value);
            value /= BigInt(0x80);
            // prettier-ignore
            if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)
                || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {
                pipe.write(new Uint8Array([i]));
                break;
            }
            else {
                pipe.write(new Uint8Array([i | 0x80]));
            }
        }
        function getLowerBytes(num) {
            const bytes = num % BigInt(0x80);
            if (isNeg) {
                // We swap the bits here again, and remove 1 to do two's complement.
                return Number(BigInt(0x80) - bytes - BigInt(1));
            }
            else {
                return Number(bytes);
            }
        }
        return pipe.buffer;
    }
    /**
     * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative
     * signed-leb encoding.
     * @param pipe A Buffer containing the signed leb encoded bits.
     */
    function slebDecode(pipe) {
        // Get the size of the buffer, then cut a buffer of that size.
        const pipeView = new Uint8Array(pipe.buffer);
        let len = 0;
        for (; len < pipeView.byteLength; len++) {
            if (pipeView[len] < 0x80) {
                // If it's a positive number, we reuse lebDecode.
                if ((pipeView[len] & 0x40) === 0) {
                    return lebDecode(pipe);
                }
                break;
            }
        }
        const bytes = new Uint8Array(safeRead(pipe, len + 1));
        let value = BigInt(0);
        for (let i = bytes.byteLength - 1; i >= 0; i--) {
            value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);
        }
        return -value - BigInt(1);
    }
    /**
     *
     * @param value bigint or number
     * @param byteLength number
     * @returns Buffer
     */
    function writeUIntLE(value, byteLength) {
        if (BigInt(value) < BigInt(0)) {
            throw new Error('Cannot write negative values.');
        }
        return writeIntLE(value, byteLength);
    }
    /**
     *
     * @param value - bigint or number
     * @param byteLength - number
     * @returns ArrayBuffer
     */
    function writeIntLE(value, byteLength) {
        value = BigInt(value);
        const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);
        let i = 0;
        let mul = BigInt(256);
        let sub = BigInt(0);
        let byte = Number(value % mul);
        pipe.write(new Uint8Array([byte]));
        while (++i < byteLength) {
            if (value < 0 && sub === BigInt(0) && byte !== 0) {
                sub = BigInt(1);
            }
            byte = Number((value / mul - sub) % BigInt(256));
            pipe.write(new Uint8Array([byte]));
            mul *= BigInt(256);
        }
        return pipe.buffer;
    }
    /**
     *
     * @param pipe Pipe from buffer-pipe
     * @param byteLength number
     * @returns bigint
     */
    function readUIntLE(pipe, byteLength) {
        let val = BigInt(safeReadUint8(pipe));
        let mul = BigInt(1);
        let i = 0;
        while (++i < byteLength) {
            mul *= BigInt(256);
            const byte = BigInt(safeReadUint8(pipe));
            val = val + mul * byte;
        }
        return val;
    }
    /**
     *
     * @param pipe Pipe from buffer-pipe
     * @param byteLength number
     * @returns bigint
     */
    function readIntLE(pipe, byteLength) {
        let val = readUIntLE(pipe, byteLength);
        const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));
        if (val >= mul) {
            val -= mul * BigInt(2);
        }
        return val;
    }
    //# sourceMappingURL=leb128.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/principal/lib/esm/index.js":
    /*!**********************************************************!*\
      !*** ./node_modules/@dfinity/principal/lib/esm/index.js ***!
      \**********************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   JSON_KEY_PRINCIPAL: () => (/* binding */ JSON_KEY_PRINCIPAL),
    /* harmony export */   Principal: () => (/* binding */ Principal)
    /* harmony export */ });
    /* harmony import */ var _utils_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/base32 */ "./node_modules/@dfinity/principal/lib/esm/utils/base32.js");
    /* harmony import */ var _utils_getCrc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getCrc */ "./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js");
    /* harmony import */ var _utils_sha224__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/sha224 */ "./node_modules/@dfinity/principal/lib/esm/utils/sha224.js");
    
    
    
    const JSON_KEY_PRINCIPAL = '__principal__';
    const SELF_AUTHENTICATING_SUFFIX = 2;
    const ANONYMOUS_SUFFIX = 4;
    const MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = 'aaaaa-aa';
    const fromHexString = (hexString) => { var _a; return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))); };
    const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
    class Principal {
        constructor(_arr) {
            this._arr = _arr;
            this._isPrincipal = true;
        }
        static anonymous() {
            return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
        }
        /**
         * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`
         * @returns {Principal} principal of the management canister
         */
        static managementCanister() {
            return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);
        }
        static selfAuthenticating(publicKey) {
            const sha = (0,_utils_sha224__WEBPACK_IMPORTED_MODULE_2__.sha224)(publicKey);
            return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));
        }
        static from(other) {
            if (typeof other === 'string') {
                return Principal.fromText(other);
            }
            else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {
                return new Principal(other);
            }
            else if (typeof other === 'object' &&
                other !== null &&
                other._isPrincipal === true) {
                return new Principal(other._arr);
            }
            throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
        }
        static fromHex(hex) {
            return new this(fromHexString(hex));
        }
        static fromText(text) {
            let maybePrincipal = text;
            // If formatted as JSON string, parse it first
            if (text.includes(JSON_KEY_PRINCIPAL)) {
                const obj = JSON.parse(text);
                if (JSON_KEY_PRINCIPAL in obj) {
                    maybePrincipal = obj[JSON_KEY_PRINCIPAL];
                }
            }
            const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');
            let arr = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.decode)(canisterIdNoDash);
            arr = arr.slice(4, arr.length);
            const principal = new this(arr);
            if (principal.toText() !== maybePrincipal) {
                throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${maybePrincipal}" may not be a valid Principal ID).`);
            }
            return principal;
        }
        static fromUint8Array(arr) {
            return new this(arr);
        }
        isAnonymous() {
            return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
        }
        toUint8Array() {
            return this._arr;
        }
        toHex() {
            return toHexString(this._arr).toUpperCase();
        }
        toText() {
            const checksumArrayBuf = new ArrayBuffer(4);
            const view = new DataView(checksumArrayBuf);
            view.setUint32(0, (0,_utils_getCrc__WEBPACK_IMPORTED_MODULE_1__.getCrc32)(this._arr));
            const checksum = new Uint8Array(checksumArrayBuf);
            const bytes = Uint8Array.from(this._arr);
            const array = new Uint8Array([...checksum, ...bytes]);
            const result = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.encode)(array);
            const matches = result.match(/.{1,5}/g);
            if (!matches) {
                // This should only happen if there's no character, which is unreachable.
                throw new Error();
            }
            return matches.join('-');
        }
        toString() {
            return this.toText();
        }
        /**
         * Serializes to JSON
         * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string
         */
        toJSON() {
            return { [JSON_KEY_PRINCIPAL]: this.toText() };
        }
        /**
         * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification
         * @param {Principal} other - a {@link Principal} to compare
         * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than
         */
        compareTo(other) {
            for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {
                if (this._arr[i] < other._arr[i])
                    return 'lt';
                else if (this._arr[i] > other._arr[i])
                    return 'gt';
            }
            // Here, at least one principal is a prefix of the other principal (they could be the same)
            if (this._arr.length < other._arr.length)
                return 'lt';
            if (this._arr.length > other._arr.length)
                return 'gt';
            return 'eq';
        }
        /**
         * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method
         * @param other a {@link Principal} to compare
         * @returns {boolean} boolean
         */
        ltEq(other) {
            const cmp = this.compareTo(other);
            return cmp == 'lt' || cmp == 'eq';
        }
        /**
         * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method
         * @param other a {@link Principal} to compare
         * @returns {boolean} boolean
         */
        gtEq(other) {
            const cmp = this.compareTo(other);
            return cmp == 'gt' || cmp == 'eq';
        }
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/principal/lib/esm/utils/base32.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@dfinity/principal/lib/esm/utils/base32.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   decode: () => (/* binding */ decode),
    /* harmony export */   encode: () => (/* binding */ encode)
    /* harmony export */ });
    const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
    // Build a lookup table for decoding.
    const lookupTable = Object.create(null);
    for (let i = 0; i < alphabet.length; i++) {
        lookupTable[alphabet[i]] = i;
    }
    // Add aliases for rfc4648.
    lookupTable['0'] = lookupTable.o;
    lookupTable['1'] = lookupTable.i;
    /**
     * @param input The input array to encode.
     * @returns A Base32 string encoding the input.
     */
    function encode(input) {
        // How many bits will we skip from the first byte.
        let skip = 0;
        // 5 high bits, carry from one byte to the next.
        let bits = 0;
        // The output string in base32.
        let output = '';
        function encodeByte(byte) {
            if (skip < 0) {
                // we have a carry from the previous byte
                bits |= byte >> -skip;
            }
            else {
                // no carry
                bits = (byte << skip) & 248;
            }
            if (skip > 3) {
                // Not enough data to produce a character, get us another one
                skip -= 8;
                return 1;
            }
            if (skip < 4) {
                // produce a character
                output += alphabet[bits >> 3];
                skip += 5;
            }
            return 0;
        }
        for (let i = 0; i < input.length;) {
            i += encodeByte(input[i]);
        }
        return output + (skip < 0 ? alphabet[bits >> 3] : '');
    }
    /**
     * @param input The base32 encoded string to decode.
     */
    function decode(input) {
        // how many bits we have from the previous character.
        let skip = 0;
        // current byte we're producing.
        let byte = 0;
        const output = new Uint8Array(((input.length * 4) / 3) | 0);
        let o = 0;
        function decodeChar(char) {
            // Consume a character from the stream, store
            // the output in this.output. As before, better
            // to use update().
            let val = lookupTable[char.toLowerCase()];
            if (val === undefined) {
                throw new Error(`Invalid character: ${JSON.stringify(char)}`);
            }
            // move to the high bits
            val <<= 3;
            byte |= val >>> skip;
            skip += 5;
            if (skip >= 8) {
                // We have enough bytes to produce an output
                output[o++] = byte;
                skip -= 8;
                if (skip > 0) {
                    byte = (val << (5 - skip)) & 255;
                }
                else {
                    byte = 0;
                }
            }
        }
        for (const c of input) {
            decodeChar(c);
        }
        return output.slice(0, o);
    }
    //# sourceMappingURL=base32.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   getCrc32: () => (/* binding */ getCrc32)
    /* harmony export */ });
    // This file is translated to JavaScript from
    // https://lxp32.github.io/docs/a-simple-example-crc32-calculation/
    const lookUpTable = new Uint32Array([
        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
        0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
        0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
        0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
        0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
        0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
        0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
        0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
        0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
        0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
        0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
        0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
        0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
        0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
        0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
        0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
        0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
        0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
        0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
        0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
        0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
        0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
    ]);
    /**
     * Calculate the CRC32 of an ArrayBufferLike.
     * @param buf The BufferLike to calculate the CRC32 of.
     */
    function getCrc32(buf) {
        const b = new Uint8Array(buf);
        let crc = -1;
        for (let i = 0; i < b.length; i++) {
            const byte = b[i];
            const t = (byte ^ crc) & 0xff;
            crc = lookUpTable[t] ^ (crc >>> 8);
        }
        return (crc ^ -1) >>> 0;
    }
    //# sourceMappingURL=getCrc.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@dfinity/principal/lib/esm/utils/sha224.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@dfinity/principal/lib/esm/utils/sha224.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   sha224: () => (/* binding */ sha224)
    /* harmony export */ });
    /* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/esm/sha256.js");
    
    /**
     * Returns the SHA224 hash of the buffer.
     * @param data Arraybuffer to encode
     */
    function sha224(data) {
        return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha224.create().update(new Uint8Array(data)).digest();
    }
    //# sourceMappingURL=sha224.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/constants/canisters.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/constants/canisters.js ***!
      \**********************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.NFT_CANISTERS = void 0;
    exports.NFT_CANISTERS = {
        WRAPPED_PUNKS: 'bxdf4-baaaa-aaaah-qaruq-cai',
        WRAPPED_DRIP: '3db6u-aiaaa-aaaah-qbjbq-cai',
        IC_PUNKS: 'qcg3w-tyaaa-aaaah-qakea-cai',
        IC_DRIP: 'd3ttm-qaaaa-aaaai-qam4a-cai',
        ICP_BUNNY_MAIN: 'xkbqi-2qaaa-aaaah-qbpqq-cai',
        ICP_BUNNY_STORAGE: [
            'efqhu-yqaaa-aaaaf-qaeda-cai',
            'ecrba-viaaa-aaaaf-qaedq-cai',
            'fp7fo-2aaaa-aaaaf-qaeea-cai',
            'fi6d2-xyaaa-aaaaf-qaeeq-cai',
            'fb5ig-bqaaa-aaaaf-qaefa-cai',
            'fg4os-miaaa-aaaaf-qaefq-cai',
            'ft377-naaaa-aaaaf-qaega-cai',
            'fu2zl-ayaaa-aaaaf-qaegq-cai',
            'f5zsx-wqaaa-aaaaf-qaeha-cai',
            'f2yud-3iaaa-aaaaf-qaehq-cai',
        ],
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/constants/index.js":
    /*!******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/constants/index.js ***!
      \******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.KYASSHU_URL = exports.IC_HOST = void 0;
    exports.IC_HOST = 'https://ic0.app/';
    exports.KYASSHU_URL = 'https://kyasshu.fleek.co';
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/constants/standards.js ***!
      \**********************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.NFT = exports.TOKEN = void 0;
    exports.TOKEN = {
        dip20: 'DIP20',
        xtc: 'XTC',
        wicp: 'WICP',
        ext: 'EXT',
        icp: 'ICP',
        rosetta: 'ROSETTA'
    };
    exports.NFT = {
        ext: 'EXT',
        icpunks: 'ICPUNKS',
        departuresLabs: 'DEPARTURELABS',
        erc721: 'ERC721',
        dip721: 'DIP721',
        c3: 'C3',
        nftOrigyn: 'NFTORIGYN'
    };
    exports["default"] = {
        TOKEN: exports.TOKEN, NFT: exports.NFT
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/c3.did.js":
    /*!**************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/c3.did.js ***!
      \**************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const TokenIndex__1 = IDL.Nat;
        const TokenIndex = IDL.Nat;
        const TransferResponse = IDL.Variant({
            'ok': TokenIndex,
            'err': IDL.Variant({
                'ListOnMarketPlace': IDL.Null,
                'NotAllowTransferToSelf': IDL.Null,
                'NotOwnerOrNotApprove': IDL.Null,
                'Other': IDL.Null,
            }),
        });
        const TokenDetails = IDL.Record({
            'id': IDL.Nat,
            'rarityScore': IDL.Float64,
        });
        const GetTokenResponse = IDL.Variant({
            'ok': TokenDetails,
            'err': IDL.Variant({ 'NotFoundIndex': IDL.Null }),
        });
        const C2NFT = IDL.Service({
            'getAllNFT': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Tuple(TokenIndex__1, IDL.Principal))], ['query']),
            'getNftStoreCIDByIndex': IDL.Func([TokenIndex__1], [IDL.Principal], ['query']),
            'getTokenById': IDL.Func([IDL.Nat], [GetTokenResponse], ['query']),
            'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, TokenIndex__1], [TransferResponse], []),
        });
        return C2NFT;
    };
    const init = ({ IDL }) => {
        return [IDL.Principal, IDL.Principal, IDL.Principal];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/address_book.did.js":
    /*!***************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/address_book.did.js ***!
      \***************************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const addressBookIDL = ({ IDL }) => {
        const valueType = IDL.Variant({
            'PrincipalId': IDL.Principal,
            'AccountId': IDL.Text,
            'Icns': IDL.Text,
        });
        const address = IDL.Record({
            'name': IDL.Text,
            'description': IDL.Opt(IDL.Text),
            'emoji': IDL.Opt(IDL.Text),
            'value': valueType,
        });
        const operation_error = IDL.Variant({
            'NotAuthorized': IDL.Null,
            'BadParameters': IDL.Null,
            'Unknown': IDL.Text,
            'NonExistentItem': IDL.Null,
        });
        const operation_response = IDL.Variant({
            'Ok': IDL.Null,
            'Err': operation_error,
        });
        return IDL.Service({
            'add': IDL.Func([address], [operation_response], []),
            'get_all': IDL.Func([], [IDL.Vec(address)], []),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'remove': IDL.Func([IDL.Text], [operation_response], []),
        });
    };
    exports["default"] = addressBookIDL;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/canister_registry.did.js":
    /*!********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/canister_registry.did.js ***!
      \********************************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const detail_value = IDL.Rec();
        detail_value.fill(IDL.Variant({
            'I64': IDL.Int64,
            'U64': IDL.Nat64,
            'Vec': IDL.Vec(detail_value),
            'Slice': IDL.Vec(IDL.Nat8),
            'Text': IDL.Text,
            'True': IDL.Null,
            'False': IDL.Null,
            'Float': IDL.Float64,
            'Principal': IDL.Principal,
        }));
        const canister_metadata = IDL.Record({
            'thumbnail': IDL.Text,
            'name': IDL.Text,
            'frontend': IDL.Opt(IDL.Text),
            'description': IDL.Text,
            'principal_id': IDL.Principal,
            'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),
        });
        const operation_error = IDL.Variant({
            'NotAuthorized': IDL.Null,
            'BadParameters': IDL.Null,
            'Unknown': IDL.Text,
            'NonExistentItem': IDL.Null,
        });
        const operation_response = IDL.Variant({
            'Ok': IDL.Opt(IDL.Text),
            'Err': operation_error,
        });
        return IDL.Service({
            'add': IDL.Func([canister_metadata], [operation_response], []),
            'get': IDL.Func([IDL.Principal], [IDL.Opt(canister_metadata)], ['query']),
            'get_all': IDL.Func([], [IDL.Vec(canister_metadata)], ['query']),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'remove': IDL.Func([IDL.Principal], [operation_response], []),
        });
    };
    const init = () => { return []; };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/nft_registry.did.js":
    /*!***************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/nft_registry.did.js ***!
      \***************************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const detail_value = IDL.Rec();
        detail_value.fill(IDL.Variant({
            'I64': IDL.Int64,
            'U64': IDL.Nat64,
            'Vec': IDL.Vec(detail_value),
            'Slice': IDL.Vec(IDL.Nat8),
            'Text': IDL.Text,
            'True': IDL.Null,
            'False': IDL.Null,
            'Float': IDL.Float64,
            'Principal': IDL.Principal,
        }));
        const nft_canister = IDL.Record({
            'thumbnail': IDL.Text,
            'name': IDL.Text,
            'frontend': IDL.Opt(IDL.Text),
            'description': IDL.Text,
            'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),
            'principal_id': IDL.Principal,
        });
        const operation_error = IDL.Variant({
            'NotAuthorized': IDL.Null,
            'BadParameters': IDL.Null,
            'Unknown': IDL.Text,
            'NonExistentItem': IDL.Null,
        });
        const operation_response = IDL.Variant({
            'Ok': IDL.Opt(IDL.Text),
            'Err': operation_error,
        });
        return IDL.Service({
            'add': IDL.Func([nft_canister], [operation_response], []),
            'get': IDL.Func([IDL.Principal], [IDL.Opt(nft_canister)], ['query']),
            'get_all': IDL.Func([], [IDL.Vec(nft_canister)], ['query']),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'remove': IDL.Func([IDL.Principal], [operation_response], []),
            'set_controller': IDL.Func([IDL.Principal], [operation_response], []),
        });
    };
    const init = () => { return []; };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/registry_standard.did.js":
    /*!********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/registry_standard.did.js ***!
      \********************************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const detail_value = IDL.Rec();
        detail_value.fill(IDL.Variant({
            'I64': IDL.Int64,
            'U64': IDL.Nat64,
            'Vec': IDL.Vec(detail_value),
            'Slice': IDL.Vec(IDL.Nat8),
            'Text': IDL.Text,
            'True': IDL.Null,
            'False': IDL.Null,
            'Float': IDL.Float64,
            'Principal': IDL.Principal,
        }));
        const metadata = IDL.Record({
            'thumbnail': IDL.Text,
            'name': IDL.Text,
            'frontend': IDL.Opt(IDL.Text),
            'description': IDL.Text,
            'principal_id': IDL.Principal,
            'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),
        });
        const error = IDL.Variant({
            'NotAuthorized': IDL.Null,
            'BadParameters': IDL.Null,
            'Unknown': IDL.Text,
            'NonExistantCanister': IDL.Null,
        });
        const response = IDL.Variant({ 'Ok': IDL.Opt(IDL.Text), 'Err': error });
        return IDL.Service({
            'add': IDL.Func([metadata], [response], []),
            'get': IDL.Func([IDL.Principal], [IDL.Opt(metadata)], ['query']),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'remove': IDL.Func([IDL.Principal], [response], []),
        });
    };
    const init = () => { return []; };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/token_registry.did.js":
    /*!*****************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/token_registry.did.js ***!
      \*****************************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const detail_value = IDL.Rec();
        detail_value.fill(IDL.Variant({
            'I64': IDL.Int64,
            'U64': IDL.Nat64,
            'Vec': IDL.Vec(detail_value),
            'Slice': IDL.Vec(IDL.Nat8),
            'Text': IDL.Text,
            'True': IDL.Null,
            'False': IDL.Null,
            'Float': IDL.Float64,
            'Principal': IDL.Principal,
        }));
        const token = IDL.Record({
            'thumbnail': IDL.Text,
            'name': IDL.Text,
            'frontend': IDL.Opt(IDL.Text),
            'description': IDL.Text,
            'principal_id': IDL.Principal,
            'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),
        });
        const operation_error = IDL.Variant({
            'NotAuthorized': IDL.Null,
            'BadParameters': IDL.Null,
            'Unknown': IDL.Text,
            'NonExistentItem': IDL.Null,
        });
        const operation_response = IDL.Variant({
            'Ok': IDL.Opt(IDL.Text),
            'Err': operation_error,
        });
        return IDL.Service({
            'add': IDL.Func([token], [operation_response], []),
            'get': IDL.Func([IDL.Principal], [IDL.Opt(token)], ['query']),
            'get_all': IDL.Func([], [IDL.Vec(token)], ['query']),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'remove': IDL.Func([IDL.Principal], [operation_response], []),
            'set_controller': IDL.Func([IDL.Principal], [operation_response], []),
        });
    };
    const init = () => { return []; };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/departure_labs.did.js":
    /*!**************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/departure_labs.did.js ***!
      \**************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const Property = IDL.Rec();
        const Query = IDL.Rec();
        const Update = IDL.Rec();
        const Callback = IDL.Func([], [], []);
        const StagedWrite = IDL.Variant({
            'Init': IDL.Record({ 'size': IDL.Nat, 'callback': IDL.Opt(Callback) }),
            'Chunk': IDL.Record({
                'chunk': IDL.Vec(IDL.Nat8),
                'callback': IDL.Opt(Callback),
            }),
        });
        const AssetRequest = IDL.Variant({
            'Put': IDL.Record({
                'key': IDL.Text,
                'contentType': IDL.Text,
                'callback': IDL.Opt(Callback),
                'payload': IDL.Variant({
                    'StagedData': IDL.Null,
                    'Payload': IDL.Vec(IDL.Nat8),
                }),
            }),
            'Remove': IDL.Record({ 'key': IDL.Text, 'callback': IDL.Opt(Callback) }),
            'StagedWrite': StagedWrite,
        });
        const AuthorizeRequest = IDL.Record({
            'p': IDL.Principal,
            'id': IDL.Text,
            'isAuthorized': IDL.Bool,
        });
        const Error = IDL.Variant({
            'Immutable': IDL.Null,
            'NotFound': IDL.Null,
            'Unauthorized': IDL.Null,
            'InvalidRequest': IDL.Null,
            'AuthorizedPrincipalLimitReached': IDL.Nat,
        });
        const Result_1 = IDL.Variant({ 'ok': IDL.Null, 'err': Error });
        const ContractInfo = IDL.Record({
            'nft_payload_size': IDL.Nat,
            'memory_size': IDL.Nat,
            'max_live_size': IDL.Nat,
            'cycles': IDL.Nat,
            'total_minted': IDL.Nat,
            'heap_size': IDL.Nat,
            'authorized_users': IDL.Vec(IDL.Principal),
        });
        const TopupCallback = IDL.Func([], [], []);
        const Contract = IDL.Variant({
            'ContractAuthorize': IDL.Record({
                'isAuthorized': IDL.Bool,
                'user': IDL.Principal,
            }),
            'Mint': IDL.Record({ 'id': IDL.Text, 'owner': IDL.Principal }),
        });
        const Token = IDL.Variant({
            'Authorize': IDL.Record({
                'id': IDL.Text,
                'isAuthorized': IDL.Bool,
                'user': IDL.Principal,
            }),
            'Transfer': IDL.Record({
                'id': IDL.Text,
                'to': IDL.Principal,
                'from': IDL.Principal,
            }),
        });
        const Message = IDL.Record({
            'topupCallback': TopupCallback,
            'createdAt': IDL.Int,
            'topupAmount': IDL.Nat,
            'event': IDL.Variant({ 'ContractEvent': Contract, 'TokenEvent': Token }),
        });
        const Callback__1 = IDL.Func([Message], [], []);
        const CallbackStatus = IDL.Record({
            'failedCalls': IDL.Nat,
            'failedCallsLimit': IDL.Nat,
            'callback': IDL.Opt(Callback__1),
            'noTopupCallLimit': IDL.Nat,
            'callsSinceLastTopup': IDL.Nat,
        });
        const ContractMetadata = IDL.Record({
            'name': IDL.Text,
            'symbol': IDL.Text,
        });
        const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);
        const Request = IDL.Record({
            'url': IDL.Text,
            'method': IDL.Text,
            'body': IDL.Vec(IDL.Nat8),
            'headers': IDL.Vec(HeaderField),
        });
        const StreamingCallbackToken = IDL.Record({
            'key': IDL.Text,
            'index': IDL.Nat,
            'content_encoding': IDL.Text,
        });
        const StreamingCallbackResponse = IDL.Record({
            'token': IDL.Opt(StreamingCallbackToken),
            'body': IDL.Vec(IDL.Nat8),
        });
        const StreamingCallback = IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']);
        const StreamingStrategy = IDL.Variant({
            'Callback': IDL.Record({
                'token': StreamingCallbackToken,
                'callback': StreamingCallback,
            }),
        });
        const Response = IDL.Record({
            'body': IDL.Vec(IDL.Nat8),
            'headers': IDL.Vec(HeaderField),
            'streaming_strategy': IDL.Opt(StreamingStrategy),
            'status_code': IDL.Nat16,
        });
        const Value = IDL.Variant({
            'Int': IDL.Int,
            'Nat': IDL.Nat,
            'Empty': IDL.Null,
            'Bool': IDL.Bool,
            'Text': IDL.Text,
            'Float': IDL.Float64,
            'Principal': IDL.Principal,
            'Class': IDL.Vec(Property),
        });
        Property.fill(IDL.Record({ 'value': Value, 'name': IDL.Text, 'immutable': IDL.Bool }));
        const Properties = IDL.Vec(Property);
        const Egg = IDL.Record({
            'contentType': IDL.Text,
            'owner': IDL.Opt(IDL.Principal),
            'properties': Properties,
            'isPrivate': IDL.Bool,
            'payload': IDL.Variant({
                'StagedData': IDL.Null,
                'Payload': IDL.Vec(IDL.Nat8),
            }),
        });
        const Result_5 = IDL.Variant({ 'ok': IDL.Principal, 'err': Error });
        Query.fill(IDL.Record({ 'name': IDL.Text, 'next': IDL.Vec(Query) }));
        const QueryMode = IDL.Variant({ 'All': IDL.Null, 'Some': IDL.Vec(Query) });
        const QueryRequest = IDL.Record({ 'id': IDL.Text, 'mode': QueryMode });
        const Result = IDL.Variant({ 'ok': Properties, 'err': Error });
        const Chunk = IDL.Record({
            'data': IDL.Vec(IDL.Nat8),
            'totalPages': IDL.Nat,
            'nextPage': IDL.Opt(IDL.Nat),
        });
        const PayloadResult = IDL.Variant({
            'Complete': IDL.Vec(IDL.Nat8),
            'Chunk': Chunk,
        });
        const PublicToken = IDL.Record({
            'id': IDL.Text,
            'contentType': IDL.Text,
            'owner': IDL.Principal,
            'createdAt': IDL.Int,
            'properties': Properties,
            'payload': PayloadResult,
        });
        const Result_4 = IDL.Variant({ 'ok': PublicToken, 'err': Error });
        const Result_3 = IDL.Variant({ 'ok': Chunk, 'err': Error });
        const Metadata = IDL.Record({
            'id': IDL.Text,
            'contentType': IDL.Text,
            'owner': IDL.Principal,
            'createdAt': IDL.Int,
            'properties': Properties,
        });
        const Result_2 = IDL.Variant({ 'ok': Metadata, 'err': Error });
        const UpdateEventCallback = IDL.Variant({
            'Set': Callback__1,
            'Remove': IDL.Null,
        });
        const UpdateMode = IDL.Variant({ 'Set': Value, 'Next': IDL.Vec(Update) });
        Update.fill(IDL.Record({ 'mode': UpdateMode, 'name': IDL.Text }));
        const UpdateRequest = IDL.Record({
            'id': IDL.Text,
            'update': IDL.Vec(Update),
        });
        const Hub = IDL.Service({
            'assetRequest': IDL.Func([AssetRequest], [], []),
            'authorize': IDL.Func([AuthorizeRequest], [Result_1], []),
            'balanceOf': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Text)], []),
            'getAuthorized': IDL.Func([IDL.Text], [IDL.Vec(IDL.Principal)], ['query']),
            'getContractInfo': IDL.Func([], [ContractInfo], []),
            'getEventCallbackStatus': IDL.Func([], [CallbackStatus], []),
            'getMetadata': IDL.Func([], [ContractMetadata], ['query']),
            'getTotalMinted': IDL.Func([], [IDL.Nat], ['query']),
            'http_request': IDL.Func([Request], [Response], ['query']),
            'http_request_streaming_callback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),
            'init': IDL.Func([IDL.Vec(IDL.Principal), ContractMetadata], [], []),
            'isAuthorized': IDL.Func([IDL.Text, IDL.Principal], [IDL.Bool], ['query']),
            'listAssets': IDL.Func([], [IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text, IDL.Nat))], ['query']),
            'mint': IDL.Func([Egg], [IDL.Text], []),
            'nftStreamingCallback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),
            'ownerOf': IDL.Func([IDL.Text], [Result_5], ['query']),
            'queryProperties': IDL.Func([QueryRequest], [Result], ['query']),
            'staticStreamingCallback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),
            'tokenByIndex': IDL.Func([IDL.Text], [Result_4], []),
            'tokenChunkByIndex': IDL.Func([IDL.Text, IDL.Nat], [Result_3], []),
            'tokenMetadataByIndex': IDL.Func([IDL.Text], [Result_2], []),
            'transfer': IDL.Func([IDL.Principal, IDL.Text], [Result_1], []),
            'updateContractOwners': IDL.Func([IDL.Principal, IDL.Bool], [Result_1], []),
            'updateEventCallback': IDL.Func([UpdateEventCallback], [], []),
            'updateProperties': IDL.Func([UpdateRequest], [Result], []),
            'wallet_receive': IDL.Func([], [], []),
            'writeStaged': IDL.Func([StagedWrite], [], []),
        });
        return Hub;
    };
    const init = ({}) => { return []; };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dip_20.did.js":
    /*!******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dip_20.did.js ***!
      \******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const TxError = IDL.Variant({
            'InsufficientAllowance': IDL.Null,
            'InsufficientBalance': IDL.Null,
            'ErrorOperationStyle': IDL.Null,
            'Unauthorized': IDL.Null,
            'LedgerTrap': IDL.Null,
            'ErrorTo': IDL.Null,
            'Other': IDL.Null,
            'BlockUsed': IDL.Null,
            'AmountTooSmall': IDL.Null,
        });
        const Result = IDL.Variant({ 'Ok': IDL.Nat, 'Err': TxError });
        const Metadata = IDL.Record({
            'fee': IDL.Nat,
            'decimals': IDL.Nat8,
            'owner': IDL.Principal,
            'logo': IDL.Text,
            'name': IDL.Text,
            'totalSupply': IDL.Nat,
            'symbol': IDL.Text,
        });
        const TokenInfo = IDL.Record({
            'holderNumber': IDL.Nat64,
            'deployTime': IDL.Nat64,
            'metadata': Metadata,
            'historySize': IDL.Nat64,
            'cycles': IDL.Nat64,
            'feeTo': IDL.Principal,
        });
        return IDL.Service({
            'allowance': IDL.Func([IDL.Principal, IDL.Principal], [IDL.Nat], ['query']),
            'approve': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),
            'balanceOf': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),
            'decimals': IDL.Func([], [IDL.Nat8], ['query']),
            'getAllowanceSize': IDL.Func([], [IDL.Nat64], ['query']),
            'getBlockUsed': IDL.Func([], [IDL.Vec(IDL.Nat64)], ['query']),
            'getHolders': IDL.Func([IDL.Nat64, IDL.Nat64], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),
            'getMetadata': IDL.Func([], [Metadata], ['query']),
            'getTokenInfo': IDL.Func([], [TokenInfo], ['query']),
            'getUserApprovals': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),
            'historySize': IDL.Func([], [IDL.Nat64], ['query']),
            'isBlockUsed': IDL.Func([IDL.Nat64], [IDL.Bool], ['query']),
            'logo': IDL.Func([], [IDL.Text], ['query']),
            'mint': IDL.Func([IDL.Opt(IDL.Vec(IDL.Nat8)), IDL.Nat64], [Result], []),
            'mintFor': IDL.Func([IDL.Opt(IDL.Vec(IDL.Nat8)), IDL.Nat64, IDL.Principal], [Result], []),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'owner': IDL.Func([], [IDL.Principal], ['query']),
            'setFee': IDL.Func([IDL.Nat], [], []),
            'setFeeTo': IDL.Func([IDL.Principal], [], []),
            'setGenesis': IDL.Func([], [Result], []),
            'setLogo': IDL.Func([IDL.Text], [], []),
            'setName': IDL.Func([IDL.Text], [], []),
            'setOwner': IDL.Func([IDL.Principal], [], []),
            'symbol': IDL.Func([], [IDL.Text], ['query']),
            'totalSupply': IDL.Func([], [IDL.Nat], ['query']),
            'transfer': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),
            'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result], []),
            'withdraw': IDL.Func([IDL.Nat64, IDL.Text], [Result], []),
        });
    };
    const init = ({ IDL }) => {
        return [
            IDL.Text,
            IDL.Text,
            IDL.Text,
            IDL.Nat8,
            IDL.Nat,
            IDL.Principal,
            IDL.Nat,
            IDL.Principal,
            IDL.Principal,
        ];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/dip_721.did.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/dip_721.did.js ***!
      \*******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports["default"] = ({ IDL }) => {
        const Vec = IDL.Rec();
        const InitArgs = IDL.Record({
            'cap': IDL.Opt(IDL.Principal),
            'logo': IDL.Opt(IDL.Text),
            'name': IDL.Opt(IDL.Text),
            'custodians': IDL.Opt(IDL.Vec(IDL.Principal)),
            'symbol': IDL.Opt(IDL.Text),
        });
        const NftError = IDL.Variant({
            'UnauthorizedOperator': IDL.Null,
            'SelfTransfer': IDL.Null,
            'TokenNotFound': IDL.Null,
            'UnauthorizedOwner': IDL.Null,
            'SelfApprove': IDL.Null,
            'OperatorNotFound': IDL.Null,
            'ExistedNFT': IDL.Null,
            'OwnerNotFound': IDL.Null,
        });
        const Result = IDL.Variant({ 'Ok': IDL.Nat, 'Err': NftError });
        const Result_1 = IDL.Variant({ 'Ok': IDL.Bool, 'Err': NftError });
        const ManualReply = IDL.Record({
            'logo': IDL.Opt(IDL.Text),
            'name': IDL.Opt(IDL.Text),
            'created_at': IDL.Nat64,
            'upgraded_at': IDL.Nat64,
            'custodians': IDL.Vec(IDL.Principal),
            'symbol': IDL.Opt(IDL.Text),
        });
        Vec.fill(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Variant({
            'Nat64Content': IDL.Nat64,
            'Nat32Content': IDL.Nat32,
            'BoolContent': IDL.Bool,
            'Nat8Content': IDL.Nat8,
            'Int64Content': IDL.Int64,
            'IntContent': IDL.Int,
            'NatContent': IDL.Nat,
            'Nat16Content': IDL.Nat16,
            'Int32Content': IDL.Int32,
            'Int8Content': IDL.Int8,
            'FloatContent': IDL.Float64,
            'Int16Content': IDL.Int16,
            'BlobContent': IDL.Vec(IDL.Nat8),
            'NestedContent': Vec,
            'Principal': IDL.Principal,
            'TextContent': IDL.Text,
        }))));
        const GenericValue = IDL.Variant({
            'Nat64Content': IDL.Nat64,
            'Nat32Content': IDL.Nat32,
            'BoolContent': IDL.Bool,
            'Nat8Content': IDL.Nat8,
            'Int64Content': IDL.Int64,
            'IntContent': IDL.Int,
            'NatContent': IDL.Nat,
            'Nat16Content': IDL.Nat16,
            'Int32Content': IDL.Int32,
            'Int8Content': IDL.Int8,
            'FloatContent': IDL.Float64,
            'Int16Content': IDL.Int16,
            'BlobContent': IDL.Vec(IDL.Nat8),
            'NestedContent': Vec,
            'Principal': IDL.Principal,
            'TextContent': IDL.Text,
        });
        const Result_2 = IDL.Variant({
            'Ok': IDL.Opt(IDL.Principal),
            'Err': NftError,
        });
        const ManualReply_1 = IDL.Variant({
            'Ok': IDL.Vec(IDL.Nat),
            'Err': NftError,
        });
        const TokenMetadata = IDL.Record({
            'transferred_at': IDL.Opt(IDL.Nat64),
            'transferred_by': IDL.Opt(IDL.Principal),
            'owner': IDL.Opt(IDL.Principal),
            'operator': IDL.Opt(IDL.Principal),
            'approved_at': IDL.Opt(IDL.Nat64),
            'approved_by': IDL.Opt(IDL.Principal),
            'properties': IDL.Vec(IDL.Tuple(IDL.Text, GenericValue)),
            'is_burned': IDL.Bool,
            'token_identifier': IDL.Nat,
            'burned_at': IDL.Opt(IDL.Nat64),
            'burned_by': IDL.Opt(IDL.Principal),
            'minted_at': IDL.Nat64,
            'minted_by': IDL.Principal,
        });
        const ManualReply_2 = IDL.Variant({
            'Ok': IDL.Vec(TokenMetadata),
            'Err': NftError,
        });
        const Stats = IDL.Record({
            'cycles': IDL.Nat,
            'total_transactions': IDL.Nat,
            'total_unique_holders': IDL.Nat,
            'total_supply': IDL.Nat,
        });
        const SupportedInterface = IDL.Variant({
            'Burn': IDL.Null,
            'Mint': IDL.Null,
            'Approval': IDL.Null,
        });
        const ManualReply_3 = IDL.Variant({ 'Ok': TokenMetadata, 'Err': NftError });
        return IDL.Service({
            'approve': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),
            'balanceOf': IDL.Func([IDL.Principal], [Result], ['query']),
            'burn': IDL.Func([IDL.Nat], [Result], []),
            'custodians': IDL.Func([], [IDL.Vec(IDL.Principal)], ['query']),
            'cycles': IDL.Func([], [IDL.Nat], ['query']),
            'dfx_info': IDL.Func([], [IDL.Text], ['query']),
            'dip721_approve': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),
            'dip721_balance_of': IDL.Func([IDL.Principal], [Result], ['query']),
            'dip721_burn': IDL.Func([IDL.Nat], [Result], []),
            'dip721_custodians': IDL.Func([], [IDL.Vec(IDL.Principal)], ['query']),
            'dip721_cycles': IDL.Func([], [IDL.Nat], ['query']),
            'dip721_is_approved_for_all': IDL.Func([IDL.Principal, IDL.Principal], [Result_1], ['query']),
            'dip721_logo': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),
            'dip721_metadata': IDL.Func([], [ManualReply], ['query']),
            'dip721_mint': IDL.Func([IDL.Principal, IDL.Nat, IDL.Vec(IDL.Tuple(IDL.Text, GenericValue))], [Result], []),
            'dip721_name': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),
            'dip721_operator_of': IDL.Func([IDL.Nat], [Result_2], ['query']),
            'dip721_operator_token_identifiers': IDL.Func([IDL.Principal], [ManualReply_1], ['query']),
            'dip721_operator_token_metadata': IDL.Func([IDL.Principal], [ManualReply_2], ['query']),
            'dip721_owner_of': IDL.Func([IDL.Nat], [Result_2], ['query']),
            'dip721_owner_token_identifiers': IDL.Func([IDL.Principal], [ManualReply_1], ['query']),
            'dip721_owner_token_metadata': IDL.Func([IDL.Principal], [ManualReply_2], ['query']),
            'dip721_set_approval_for_all': IDL.Func([IDL.Principal, IDL.Bool], [Result], []),
            'dip721_set_custodians': IDL.Func([IDL.Vec(IDL.Principal)], [], []),
            'dip721_set_logo': IDL.Func([IDL.Text], [], []),
            'dip721_set_name': IDL.Func([IDL.Text], [], []),
            'dip721_set_symbol': IDL.Func([IDL.Text], [], []),
            'dip721_stats': IDL.Func([], [Stats], ['query']),
            'dip721_supported_interfaces': IDL.Func([], [IDL.Vec(SupportedInterface)], ['query']),
            'dip721_symbol': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),
            'dip721_token_metadata': IDL.Func([IDL.Nat], [ManualReply_3], ['query']),
            'dip721_total_supply': IDL.Func([], [IDL.Nat], ['query']),
            'dip721_total_transactions': IDL.Func([], [IDL.Nat], ['query']),
            'dip721_total_unique_holders': IDL.Func([], [IDL.Nat], ['query']),
            'dip721_transfer': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),
            'dip721_transfer_from': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result], []),
            'git_commit_hash': IDL.Func([], [IDL.Text], ['query']),
            'isApprovedForAll': IDL.Func([IDL.Principal, IDL.Principal], [Result_1], ['query']),
            'logo': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),
            'metadata': IDL.Func([], [ManualReply], ['query']),
            'mint': IDL.Func([IDL.Principal, IDL.Nat, IDL.Vec(IDL.Tuple(IDL.Text, GenericValue))], [Result], []),
            'name': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),
            'operatorOf': IDL.Func([IDL.Nat], [Result_2], ['query']),
            'operatorTokenIdentifiers': IDL.Func([IDL.Principal], [ManualReply_1], ['query']),
            'operatorTokenMetadata': IDL.Func([IDL.Principal], [ManualReply_2], ['query']),
            'ownerOf': IDL.Func([IDL.Nat], [Result_2], ['query']),
            'ownerTokenIdentifiers': IDL.Func([IDL.Principal], [ManualReply_1], ['query']),
            'ownerTokenMetadata': IDL.Func([IDL.Principal], [ManualReply_2], ['query']),
            'rust_toolchain_info': IDL.Func([], [IDL.Text], ['query']),
            'setApprovalForAll': IDL.Func([IDL.Principal, IDL.Bool], [Result], []),
            'setCustodians': IDL.Func([IDL.Vec(IDL.Principal)], [], []),
            'setLogo': IDL.Func([IDL.Text], [], []),
            'setName': IDL.Func([IDL.Text], [], []),
            'setSymbol': IDL.Func([IDL.Text], [], []),
            'stats': IDL.Func([], [Stats], ['query']),
            'supportedInterfaces': IDL.Func([], [IDL.Vec(SupportedInterface)], ['query']),
            'symbol': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),
            'tokenMetadata': IDL.Func([IDL.Nat], [ManualReply_3], ['query']),
            'totalSupply': IDL.Func([], [IDL.Nat], ['query']),
            'totalTransactions': IDL.Func([], [IDL.Nat], ['query']),
            'totalUniqueHolders': IDL.Func([], [IDL.Nat], ['query']),
            'transfer': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),
            'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result], []),
        });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/ext.did.js":
    /*!***************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/ext.did.js ***!
      \***************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    /* eslint-disable @typescript-eslint/camelcase */
    /* eslint-disable camelcase */
    exports["default"] = ({ IDL }) => {
        const TokenIndex = IDL.Nat32;
        const AccountIdentifier = IDL.Text;
        const TokenIdentifier = IDL.Text;
        const Balance = IDL.Nat;
        const Time = IDL.Int;
        const SubAccount = IDL.Vec(IDL.Nat8);
        const Memo = IDL.Vec(IDL.Nat8);
        const Listing = IDL.Record({
            locked: IDL.Opt(Time),
            seller: IDL.Principal,
            price: IDL.Nat64,
        });
        const User = IDL.Variant({
            principal: IDL.Principal,
            address: AccountIdentifier,
        });
        const CommonError = IDL.Variant({
            InvalidToken: TokenIdentifier,
            Other: IDL.Text,
        });
        const BalanceRequest = IDL.Record({
            token: TokenIdentifier,
            user: User,
        });
        const BalanceResult = IDL.Variant({ ok: Balance, err: CommonError });
        const DetailsResult = IDL.Variant({
            ok: IDL.Tuple(AccountIdentifier, IDL.Opt(Listing)),
            err: CommonError,
        });
        const TokensResult = IDL.Variant({
            ok: IDL.Vec(TokenIndex),
            err: CommonError,
        });
        const TokenExtResult = IDL.Variant({
            ok: IDL.Vec(IDL.Tuple(TokenIndex, IDL.Opt(Listing), IDL.Opt(IDL.Vec(IDL.Nat8)))),
            err: CommonError,
        });
        const TransferRequest = IDL.Record({
            to: User,
            token: TokenIdentifier,
            notify: IDL.Bool,
            from: User,
            memo: Memo,
            subaccount: IDL.Opt(SubAccount),
            amount: Balance,
            fee: IDL.Nat,
        });
        const TransferResult = IDL.Variant({
            ok: Balance,
            err: IDL.Variant({
                CannotNotify: AccountIdentifier,
                InsufficientBalance: IDL.Null,
                InvalidToken: TokenIdentifier,
                Rejected: IDL.Null,
                Unauthorized: AccountIdentifier,
                Other: IDL.Text,
            }),
        });
        const Metadata = IDL.Variant({
            fungible: IDL.Record({
                decimals: IDL.Nat8,
                metadata: IDL.Opt(IDL.Vec(IDL.Nat8)),
                name: IDL.Text,
                symbol: IDL.Text,
            }),
            nonfungible: IDL.Record({ metadata: IDL.Opt(IDL.Vec(IDL.Nat8)) }),
        });
        const MetadataResult = IDL.Variant({ ok: Metadata, err: CommonError });
        const SupplyResult = IDL.Variant({ ok: Balance, err: CommonError });
        return IDL.Service({
            extensions: IDL.Func([], [IDL.Vec(IDL.Text)], ['query']),
            balance: IDL.Func([BalanceRequest], [BalanceResult], ['query']),
            details: IDL.Func([TokenIdentifier], [DetailsResult], ['query']),
            tokens: IDL.Func([AccountIdentifier], [TokensResult], ['query']),
            tokens_ext: IDL.Func([AccountIdentifier], [TokenExtResult], ['query']),
            transfer: IDL.Func([TransferRequest], [TransferResult], []),
            metadata: IDL.Func([TokenIdentifier], [MetadataResult], ['query']),
            supply: IDL.Func([TokenIdentifier], [SupplyResult], ['query']),
        });
    };
    const init = () => {
        return [];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/icpunks.did.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/icpunks.did.js ***!
      \*******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    /* eslint-disable camelcase */
    /* eslint-disable @typescript-eslint/camelcase */
    exports["default"] = ({ IDL }) => {
        const Property = IDL.Record({ value: IDL.Text, name: IDL.Text });
        const TokenDesc = IDL.Record({
            id: IDL.Nat,
            url: IDL.Text,
            owner: IDL.Principal,
            desc: IDL.Text,
            name: IDL.Text,
            properties: IDL.Vec(Property),
        });
        const TokenIndex = IDL.Nat;
        const ICPunk = IDL.Service({
            data_of: IDL.Func([TokenIndex], [TokenDesc], []),
            transfer_to: IDL.Func([IDL.Principal, TokenIndex], [IDL.Bool], []),
            user_tokens: IDL.Func([IDL.Principal], [IDL.Vec(IDL.Nat)], []),
        });
        return ICPunk;
    };
    const init = ({ IDL }) => {
        return [IDL.Text, IDL.Text, IDL.Nat, IDL.Principal];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/ledger.did.js":
    /*!******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/ledger.did.js ***!
      \******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    /* eslint-disable @typescript-eslint/class-name-casing */
    /* eslint-disable camelcase */
    /* eslint-disable @typescript-eslint/camelcase */
    exports["default"] = ({ IDL }) => {
        const AccountIdentifier = IDL.Text;
        const Duration = IDL.Record({ secs: IDL.Nat64, nanos: IDL.Nat32 });
        const ArchiveOptions = IDL.Record({
            max_message_size_bytes: IDL.Opt(IDL.Nat32),
            node_max_memory_size_bytes: IDL.Opt(IDL.Nat32),
            controller_id: IDL.Principal,
        });
        const ICPTs = IDL.Record({ e8s: IDL.Nat64 });
        const LedgerCanisterInitPayload = IDL.Record({
            send_whitelist: IDL.Vec(IDL.Tuple(IDL.Principal)),
            minting_account: AccountIdentifier,
            transaction_window: IDL.Opt(Duration),
            max_message_size_bytes: IDL.Opt(IDL.Nat32),
            archive_options: IDL.Opt(ArchiveOptions),
            initial_values: IDL.Vec(IDL.Tuple(AccountIdentifier, ICPTs)),
        });
        const AccountBalanceArgs = IDL.Record({ account: AccountIdentifier });
        const SubAccount = IDL.Vec(IDL.Nat8);
        const BlockHeight = IDL.Nat64;
        const NotifyCanisterArgs = IDL.Record({
            to_subaccount: IDL.Opt(SubAccount),
            from_subaccount: IDL.Opt(SubAccount),
            to_canister: IDL.Principal,
            max_fee: ICPTs,
            block_height: BlockHeight,
        });
        const Memo = IDL.Nat64;
        const TimeStamp = IDL.Record({ timestamp_nanos: IDL.Nat64 });
        const SendArgs = IDL.Record({
            to: AccountIdentifier,
            fee: ICPTs,
            memo: Memo,
            from_subaccount: IDL.Opt(SubAccount),
            created_at_time: IDL.Opt(TimeStamp),
            amount: ICPTs,
        });
        return IDL.Service({
            account_balance_dfx: IDL.Func([AccountBalanceArgs], [ICPTs], ['query']),
            notify_dfx: IDL.Func([NotifyCanisterArgs], [], []),
            send_dfx: IDL.Func([SendArgs], [BlockHeight], []),
        });
    };
    const init = ({ IDL }) => {
        const AccountIdentifier = IDL.Text;
        const Duration = IDL.Record({ secs: IDL.Nat64, nanos: IDL.Nat32 });
        const ArchiveOptions = IDL.Record({
            max_message_size_bytes: IDL.Opt(IDL.Nat32),
            node_max_memory_size_bytes: IDL.Opt(IDL.Nat32),
            controller_id: IDL.Principal,
        });
        const ICPTs = IDL.Record({ e8s: IDL.Nat64 });
        const LedgerCanisterInitPayload = IDL.Record({
            send_whitelist: IDL.Vec(IDL.Tuple(IDL.Principal)),
            minting_account: AccountIdentifier,
            transaction_window: IDL.Opt(Duration),
            max_message_size_bytes: IDL.Opt(IDL.Nat32),
            archive_options: IDL.Opt(ArchiveOptions),
            initial_values: IDL.Vec(IDL.Tuple(AccountIdentifier, ICPTs)),
        });
        return [LedgerCanisterInitPayload];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/nft_origyn.did.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/nft_origyn.did.js ***!
      \**********************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    /* eslint-disable @typescript-eslint/class-name-casing */
    /* eslint-disable camelcase */
    /* eslint-disable @typescript-eslint/camelcase */
    exports["default"] = ({ IDL }) => {
        const CandyValue = IDL.Rec();
        const Update = IDL.Rec();
        const Principal = IDL.Principal;
        const InitArgs = IDL.Record({
            'owner': Principal,
            'storage_space': IDL.Opt(IDL.Nat),
        });
        const TokenIdentifier = IDL.Text;
        const AccountIdentifier = IDL.Text;
        const User = IDL.Variant({
            'principal': IDL.Principal,
            'address': AccountIdentifier,
        });
        const BalanceRequest = IDL.Record({
            'token': TokenIdentifier,
            'user': User,
        });
        const Balance = IDL.Nat;
        const CommonError = IDL.Variant({
            'InvalidToken': TokenIdentifier,
            'Other': IDL.Text,
        });
        const BalanceResponse__1 = IDL.Variant({
            'ok': Balance,
            'err': CommonError,
        });
        const Property = IDL.Record({
            'value': CandyValue,
            'name': IDL.Text,
            'immutable': IDL.Bool,
        });
        CandyValue.fill(IDL.Variant({
            'Int': IDL.Int,
            'Nat': IDL.Nat,
            'Empty': IDL.Null,
            'Nat16': IDL.Nat16,
            'Nat32': IDL.Nat32,
            'Nat64': IDL.Nat64,
            'Blob': IDL.Vec(IDL.Nat8),
            'Bool': IDL.Bool,
            'Int8': IDL.Int8,
            'Nat8': IDL.Nat8,
            'Nats': IDL.Variant({
                'thawed': IDL.Vec(IDL.Nat),
                'frozen': IDL.Vec(IDL.Nat),
            }),
            'Text': IDL.Text,
            'Bytes': IDL.Variant({
                'thawed': IDL.Vec(IDL.Nat8),
                'frozen': IDL.Vec(IDL.Nat8),
            }),
            'Int16': IDL.Int16,
            'Int32': IDL.Int32,
            'Int64': IDL.Int64,
            'Option': IDL.Opt(CandyValue),
            'Floats': IDL.Variant({
                'thawed': IDL.Vec(IDL.Float64),
                'frozen': IDL.Vec(IDL.Float64),
            }),
            'Float': IDL.Float64,
            'Principal': IDL.Principal,
            'Array': IDL.Variant({
                'thawed': IDL.Vec(CandyValue),
                'frozen': IDL.Vec(CandyValue),
            }),
            'Class': IDL.Vec(Property),
        }));
        const Account = IDL.Variant({
            'account_id': IDL.Text,
            'principal': IDL.Principal,
            'extensible': CandyValue,
        });
        const ICTokenSpec = IDL.Record({
            'fee': IDL.Nat,
            'decimals': IDL.Nat,
            'canister': IDL.Principal,
            'standard': IDL.Variant({
                'EXTFungible': IDL.Null,
                'DIP20': IDL.Null,
                'Ledger': IDL.Null,
            }),
            'symbol': IDL.Text,
        });
        const TokenSpec = IDL.Variant({
            'ic': ICTokenSpec,
            'extensible': CandyValue,
        });
        const EscrowRecord = IDL.Record({
            'token': TokenSpec,
            'token_id': IDL.Text,
            'seller': Account,
            'lock_to_date': IDL.Opt(IDL.Int),
            'buyer': Account,
            'amount': IDL.Nat,
            'sale_id': IDL.Opt(IDL.Text),
        });
        const StakeRecord = IDL.Record({
            'staker': Account,
            'token_id': IDL.Text,
            'amount': IDL.Nat,
        });
        const BalanceResponse = IDL.Record({
            'nfts': IDL.Vec(IDL.Text),
            'sales': IDL.Vec(EscrowRecord),
            'stake': IDL.Vec(StakeRecord),
            'multi_canister': IDL.Opt(IDL.Vec(IDL.Principal)),
            'escrow': IDL.Vec(EscrowRecord),
        });
        const Errors = IDL.Variant({
            'nyi': IDL.Null,
            'storage_configuration_error': IDL.Null,
            'escrow_withdraw_payment_failed': IDL.Null,
            'token_not_found': IDL.Null,
            'owner_not_found': IDL.Null,
            'content_not_found': IDL.Null,
            'auction_ended': IDL.Null,
            'out_of_range': IDL.Null,
            'sale_id_does_not_match': IDL.Null,
            'sale_not_found': IDL.Null,
            'item_not_owned': IDL.Null,
            'property_not_found': IDL.Null,
            'validate_trx_wrong_host': IDL.Null,
            'withdraw_too_large': IDL.Null,
            'content_not_deserializable': IDL.Null,
            'bid_too_low': IDL.Null,
            'validate_deposit_wrong_amount': IDL.Null,
            'existing_sale_found': IDL.Null,
            'asset_mismatch': IDL.Null,
            'escrow_cannot_be_removed': IDL.Null,
            'deposit_burned': IDL.Null,
            'cannot_restage_minted_token': IDL.Null,
            'cannot_find_status_in_metadata': IDL.Null,
            'receipt_data_mismatch': IDL.Null,
            'validate_deposit_failed': IDL.Null,
            'unauthorized_access': IDL.Null,
            'item_already_minted': IDL.Null,
            'no_escrow_found': IDL.Null,
            'escrow_owner_not_the_owner': IDL.Null,
            'improper_interface': IDL.Null,
            'app_id_not_found': IDL.Null,
            'token_non_transferable': IDL.Null,
            'sale_not_over': IDL.Null,
            'update_class_error': IDL.Null,
            'malformed_metadata': IDL.Null,
            'token_id_mismatch': IDL.Null,
            'id_not_found_in_metadata': IDL.Null,
            'auction_not_started': IDL.Null,
            'library_not_found': IDL.Null,
            'attempt_to_stage_system_data': IDL.Null,
            'validate_deposit_wrong_buyer': IDL.Null,
            'not_enough_storage': IDL.Null,
            'sales_withdraw_payment_failed': IDL.Null,
        });
        const OrigynError = IDL.Record({
            'text': IDL.Text,
            'error': Errors,
            'number': IDL.Nat32,
            'flag_point': IDL.Text,
        });
        const Result_19 = IDL.Variant({
            'ok': BalanceResponse,
            'err': OrigynError,
        });
        const Result_18 = IDL.Variant({
            'ok': AccountIdentifier,
            'err': CommonError,
        });
        const Result_17 = IDL.Variant({ 'ok': Account, 'err': OrigynError });
        const EscrowReceipt = IDL.Record({
            'token': TokenSpec,
            'token_id': IDL.Text,
            'seller': Account,
            'buyer': Account,
            'amount': IDL.Nat,
        });
        const BidRequest = IDL.Record({
            'escrow_receipt': EscrowReceipt,
            'sale_id': IDL.Text,
        });
        const TransactionID = IDL.Variant({
            'nat': IDL.Nat,
            'text': IDL.Text,
            'extensible': CandyValue,
        });
        const AuctionConfig = IDL.Record({
            'start_price': IDL.Nat,
            'token': TokenSpec,
            'reserve': IDL.Opt(IDL.Nat),
            'start_date': IDL.Int,
            'min_increase': IDL.Variant({
                'amount': IDL.Nat,
                'percentage': IDL.Float64,
            }),
            'allow_list': IDL.Opt(IDL.Vec(IDL.Principal)),
            'buy_now': IDL.Opt(IDL.Nat),
            'ending': IDL.Variant({
                'waitForQuiet': IDL.Record({
                    'max': IDL.Nat,
                    'date': IDL.Int,
                    'fade': IDL.Float64,
                    'extention': IDL.Nat64,
                }),
                'date': IDL.Int,
            }),
        });
        const PricingConfig = IDL.Variant({
            'flat': IDL.Record({ 'token': TokenSpec, 'amount': IDL.Nat }),
            'extensible': IDL.Variant({ 'candyClass': IDL.Null }),
            'instant': IDL.Null,
            'auction': AuctionConfig,
            'dutch': IDL.Record({
                'start_price': IDL.Nat,
                'reserve': IDL.Opt(IDL.Nat),
                'decay_per_hour': IDL.Float64,
            }),
        });
        const BidResponse = IDL.Record({
            'token_id': IDL.Text,
            'txn_type': IDL.Variant({
                'escrow_deposit': IDL.Record({
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_network_updated': IDL.Record({
                    'network': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'escrow_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_managers_updated': IDL.Record({
                    'managers': IDL.Vec(IDL.Principal),
                    'extensible': CandyValue,
                }),
                'auction_bid': IDL.Record({
                    'token': TokenSpec,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Text,
                }),
                'burn': IDL.Null,
                'data': IDL.Null,
                'sale_ended': IDL.Record({
                    'token': TokenSpec,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Opt(IDL.Text),
                }),
                'mint': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'sale': IDL.Opt(IDL.Record({ 'token': TokenSpec, 'amount': IDL.Nat })),
                    'extensible': CandyValue,
                }),
                'extensible': CandyValue,
                'owner_transfer': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'extensible': CandyValue,
                }),
                'sale_opened': IDL.Record({
                    'pricing': PricingConfig,
                    'extensible': CandyValue,
                    'sale_id': IDL.Text,
                }),
                'canister_owner_updated': IDL.Record({
                    'owner': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'sale_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
            }),
            'timestamp': IDL.Int,
            'index': IDL.Nat,
        });
        const Result_16 = IDL.Variant({ 'ok': BidResponse, 'err': OrigynError });
        const canister_id = IDL.Principal;
        const definite_canister_settings = IDL.Record({
            'freezing_threshold': IDL.Nat,
            'controllers': IDL.Opt(IDL.Vec(IDL.Principal)),
            'memory_allocation': IDL.Nat,
            'compute_allocation': IDL.Nat,
        });
        const canister_status = IDL.Record({
            'status': IDL.Variant({
                'stopped': IDL.Null,
                'stopping': IDL.Null,
                'running': IDL.Null,
            }),
            'memory_size': IDL.Nat,
            'cycles': IDL.Nat,
            'settings': definite_canister_settings,
            'module_hash': IDL.Opt(IDL.Vec(IDL.Nat8)),
        });
        const ChunkRequest = IDL.Record({
            'token_id': IDL.Text,
            'chunk': IDL.Opt(IDL.Nat),
            'library_id': IDL.Text,
        });
        const AllocationRecordStable = IDL.Record({
            'allocated_space': IDL.Nat,
            'token_id': IDL.Text,
            'available_space': IDL.Nat,
            'canister': IDL.Principal,
            'chunks': IDL.Vec(IDL.Nat),
            'library_id': IDL.Text,
        });
        const ChunkContent = IDL.Variant({
            'remote': IDL.Record({
                'args': ChunkRequest,
                'canister': IDL.Principal,
            }),
            'chunk': IDL.Record({
                'total_chunks': IDL.Nat,
                'content': IDL.Vec(IDL.Nat8),
                'storage_allocation': AllocationRecordStable,
                'current_chunk': IDL.Opt(IDL.Nat),
            }),
        });
        const Result_15 = IDL.Variant({ 'ok': ChunkContent, 'err': OrigynError });
        const CollectionInfo = IDL.Record({
            'multi_canister_count': IDL.Opt(IDL.Nat),
            'managers': IDL.Opt(IDL.Vec(IDL.Principal)),
            'owner': IDL.Opt(IDL.Principal),
            'metadata': IDL.Opt(CandyValue),
            'logo': IDL.Opt(IDL.Text),
            'name': IDL.Opt(IDL.Text),
            'network': IDL.Opt(IDL.Principal),
            'fields': IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat)))),
            'token_ids_count': IDL.Opt(IDL.Nat),
            'available_space': IDL.Opt(IDL.Nat),
            'multi_canister': IDL.Opt(IDL.Vec(IDL.Principal)),
            'token_ids': IDL.Opt(IDL.Vec(IDL.Text)),
            'total_supply': IDL.Opt(IDL.Nat),
            'symbol': IDL.Opt(IDL.Text),
            'allocated_storage': IDL.Opt(IDL.Nat),
        });
        const Result_14 = IDL.Variant({ 'ok': CollectionInfo, 'err': OrigynError });
        const CollectionUpdateItem = IDL.Variant({
            'metadata': IDL.Opt(CandyValue),
            'logo': IDL.Opt(IDL.Text),
            'name': IDL.Opt(IDL.Text),
            'symbol': IDL.Opt(IDL.Text),
        });
        const CollectionUpdateRequest = IDL.Vec(CollectionUpdateItem);
        const Result_9 = IDL.Variant({ 'ok': IDL.Bool, 'err': OrigynError });
        const LogEntry = IDL.Record({
            'data': CandyValue,
            'event': IDL.Text,
            'timestamp': IDL.Int,
            'caller': IDL.Opt(IDL.Principal),
        });
        const EndSaleResponse = IDL.Record({
            'token_id': IDL.Text,
            'txn_type': IDL.Variant({
                'escrow_deposit': IDL.Record({
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_network_updated': IDL.Record({
                    'network': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'escrow_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_managers_updated': IDL.Record({
                    'managers': IDL.Vec(IDL.Principal),
                    'extensible': CandyValue,
                }),
                'auction_bid': IDL.Record({
                    'token': TokenSpec,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Text,
                }),
                'burn': IDL.Null,
                'data': IDL.Null,
                'sale_ended': IDL.Record({
                    'token': TokenSpec,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Opt(IDL.Text),
                }),
                'mint': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'sale': IDL.Opt(IDL.Record({ 'token': TokenSpec, 'amount': IDL.Nat })),
                    'extensible': CandyValue,
                }),
                'extensible': CandyValue,
                'owner_transfer': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'extensible': CandyValue,
                }),
                'sale_opened': IDL.Record({
                    'pricing': PricingConfig,
                    'extensible': CandyValue,
                    'sale_id': IDL.Text,
                }),
                'canister_owner_updated': IDL.Record({
                    'owner': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'sale_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
            }),
            'timestamp': IDL.Int,
            'index': IDL.Nat,
        });
        const Result_13 = IDL.Variant({
            'ok': EndSaleResponse,
            'err': OrigynError,
        });
        const DepositDetail = IDL.Record({
            'token': TokenSpec,
            'trx_id': TransactionID,
            'seller': Account,
            'buyer': Account,
            'amount': IDL.Nat,
            'sale_id': IDL.Opt(IDL.Text),
        });
        const EscrowRequest = IDL.Record({
            'token_id': IDL.Text,
            'deposit': DepositDetail,
            'lock_to_date': IDL.Opt(IDL.Int),
        });
        const TransactionRecord = IDL.Record({
            'token_id': IDL.Text,
            'txn_type': IDL.Variant({
                'escrow_deposit': IDL.Record({
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_network_updated': IDL.Record({
                    'network': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'escrow_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_managers_updated': IDL.Record({
                    'managers': IDL.Vec(IDL.Principal),
                    'extensible': CandyValue,
                }),
                'auction_bid': IDL.Record({
                    'token': TokenSpec,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Text,
                }),
                'burn': IDL.Null,
                'data': IDL.Null,
                'sale_ended': IDL.Record({
                    'token': TokenSpec,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Opt(IDL.Text),
                }),
                'mint': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'sale': IDL.Opt(IDL.Record({ 'token': TokenSpec, 'amount': IDL.Nat })),
                    'extensible': CandyValue,
                }),
                'extensible': CandyValue,
                'owner_transfer': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'extensible': CandyValue,
                }),
                'sale_opened': IDL.Record({
                    'pricing': PricingConfig,
                    'extensible': CandyValue,
                    'sale_id': IDL.Text,
                }),
                'canister_owner_updated': IDL.Record({
                    'owner': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'sale_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
            }),
            'timestamp': IDL.Int,
            'index': IDL.Nat,
        });
        const EscrowResponse = IDL.Record({
            'balance': IDL.Nat,
            'receipt': EscrowReceipt,
            'transaction': TransactionRecord,
        });
        const Result_12 = IDL.Variant({ 'ok': EscrowResponse, 'err': OrigynError });
        const Result_2 = IDL.Variant({ 'ok': IDL.Text, 'err': OrigynError });
        const StorageMetrics = IDL.Record({
            'available_space': IDL.Nat,
            'allocated_storage': IDL.Nat,
        });
        const Result_11 = IDL.Variant({ 'ok': StorageMetrics, 'err': OrigynError });
        const Result_10 = IDL.Variant({
            'ok': IDL.Vec(TransactionRecord),
            'err': OrigynError,
        });
        const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);
        const HttpRequest = IDL.Record({
            'url': IDL.Text,
            'method': IDL.Text,
            'body': IDL.Vec(IDL.Nat8),
            'headers': IDL.Vec(HeaderField),
        });
        const HeaderField__1 = IDL.Tuple(IDL.Text, IDL.Text);
        const StreamingCallbackToken = IDL.Record({
            'key': IDL.Text,
            'index': IDL.Nat,
            'content_encoding': IDL.Text,
        });
        const StreamingStrategy = IDL.Variant({
            'Callback': IDL.Record({
                'token': StreamingCallbackToken,
                'callback': IDL.Func([], [], []),
            }),
        });
        const HTTPResponse = IDL.Record({
            'body': IDL.Vec(IDL.Nat8),
            'headers': IDL.Vec(HeaderField__1),
            'streaming_strategy': IDL.Opt(StreamingStrategy),
            'status_code': IDL.Nat16,
        });
        const StreamingCallbackResponse = IDL.Record({
            'token': IDL.Opt(StreamingCallbackToken),
            'body': IDL.Vec(IDL.Nat8),
        });
        const ManageCommand = IDL.Variant({
            'UpdateOwner': IDL.Principal,
            'UpdateManagers': IDL.Vec(IDL.Principal),
            'UpdateNetwork': IDL.Opt(IDL.Principal),
        });
        const ManageStorageRequest = IDL.Variant({
            'add_storage_canisters': IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat, IDL.Tuple(IDL.Nat, IDL.Nat, IDL.Nat))),
        });
        const ManageStorageResponse = IDL.Variant({
            'add_storage_canisters': IDL.Tuple(IDL.Nat, IDL.Nat),
        });
        const Result_8 = IDL.Variant({
            'ok': ManageStorageResponse,
            'err': OrigynError,
        });
        const SalesConfig = IDL.Record({
            'pricing': PricingConfig,
            'escrow_receipt': IDL.Opt(EscrowReceipt),
        });
        const MarketTransferRequest = IDL.Record({
            'token_id': IDL.Text,
            'sales_config': SalesConfig,
        });
        const MarketTransferRequestReponse = IDL.Record({
            'token_id': IDL.Text,
            'txn_type': IDL.Variant({
                'escrow_deposit': IDL.Record({
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_network_updated': IDL.Record({
                    'network': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'escrow_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_managers_updated': IDL.Record({
                    'managers': IDL.Vec(IDL.Principal),
                    'extensible': CandyValue,
                }),
                'auction_bid': IDL.Record({
                    'token': TokenSpec,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Text,
                }),
                'burn': IDL.Null,
                'data': IDL.Null,
                'sale_ended': IDL.Record({
                    'token': TokenSpec,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Opt(IDL.Text),
                }),
                'mint': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'sale': IDL.Opt(IDL.Record({ 'token': TokenSpec, 'amount': IDL.Nat })),
                    'extensible': CandyValue,
                }),
                'extensible': CandyValue,
                'owner_transfer': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'extensible': CandyValue,
                }),
                'sale_opened': IDL.Record({
                    'pricing': PricingConfig,
                    'extensible': CandyValue,
                    'sale_id': IDL.Text,
                }),
                'canister_owner_updated': IDL.Record({
                    'owner': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'sale_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
            }),
            'timestamp': IDL.Int,
            'index': IDL.Nat,
        });
        const Result_7 = IDL.Variant({
            'ok': MarketTransferRequestReponse,
            'err': OrigynError,
        });
        const Metadata = IDL.Variant({
            'fungible': IDL.Record({
                'decimals': IDL.Nat8,
                'metadata': IDL.Opt(IDL.Vec(IDL.Nat8)),
                'name': IDL.Text,
                'symbol': IDL.Text,
            }),
            'nonfungible': IDL.Record({ 'metadata': IDL.Opt(IDL.Vec(IDL.Nat8)) }),
        });
        const Result_6 = IDL.Variant({ 'ok': Metadata, 'err': CommonError });
        const AuctionStateStable = IDL.Record({
            'status': IDL.Variant({
                'closed': IDL.Null,
                'open': IDL.Null,
                'not_started': IDL.Null,
            }),
            'participants': IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Int)),
            'current_bid_amount': IDL.Nat,
            'winner': IDL.Opt(Account),
            'end_date': IDL.Int,
            'wait_for_quiet_count': IDL.Opt(IDL.Nat),
            'current_escrow': IDL.Opt(EscrowReceipt),
            'allow_list': IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Bool))),
            'min_next_bid': IDL.Nat,
            'config': PricingConfig,
        });
        const SaleStatusStable = IDL.Record({
            'token_id': IDL.Text,
            'sale_type': IDL.Variant({ 'auction': AuctionStateStable }),
            'sale_id': IDL.Text,
        });
        const NFTInfoStable = IDL.Record({
            'metadata': CandyValue,
            'current_sale': IDL.Opt(SaleStatusStable),
        });
        const Result_5 = IDL.Variant({ 'ok': NFTInfoStable, 'err': OrigynError });
        const NftError = IDL.Variant({
            'UnauthorizedOperator': IDL.Null,
            'SelfTransfer': IDL.Null,
            'TokenNotFound': IDL.Null,
            'UnauthorizedOwner': IDL.Null,
            'TxNotFound': IDL.Null,
            'SelfApprove': IDL.Null,
            'OperatorNotFound': IDL.Null,
            'ExistedNFT': IDL.Null,
            'OwnerNotFound': IDL.Null,
            'Other': IDL.Text,
        });
        const OwnerOfResponse = IDL.Variant({
            'Ok': IDL.Opt(IDL.Principal),
            'Err': NftError,
        });
        const OwnerTransferRequest = IDL.Record({
            'to': Account,
            'token_id': IDL.Text,
            'from': Account,
        });
        const OwnerTransferResponse = IDL.Record({
            'transaction': TransactionRecord,
            'assets': IDL.Vec(CandyValue),
        });
        const Result_4 = IDL.Variant({
            'ok': OwnerTransferResponse,
            'err': OrigynError,
        });
        const StageChunkArg = IDL.Record({
            'content': IDL.Vec(IDL.Nat8),
            'token_id': IDL.Text,
            'chunk': IDL.Nat,
            'filedata': CandyValue,
            'library_id': IDL.Text,
        });
        const StageLibraryResponse = IDL.Record({ 'canister': IDL.Principal });
        const Result_3 = IDL.Variant({
            'ok': StageLibraryResponse,
            'err': OrigynError,
        });
        const Memo = IDL.Vec(IDL.Nat8);
        const SubAccount = IDL.Vec(IDL.Nat8);
        const TransferRequest = IDL.Record({
            'to': User,
            'token': TokenIdentifier,
            'notify': IDL.Bool,
            'from': User,
            'memo': Memo,
            'subaccount': IDL.Opt(SubAccount),
            'amount': Balance,
        });
        const TransferResponse = IDL.Variant({
            'ok': Balance,
            'err': IDL.Variant({
                'CannotNotify': AccountIdentifier,
                'InsufficientBalance': IDL.Null,
                'InvalidToken': TokenIdentifier,
                'Rejected': IDL.Null,
                'Unauthorized': AccountIdentifier,
                'Other': IDL.Text,
            }),
        });
        const Result__1 = IDL.Variant({ 'Ok': IDL.Nat, 'Err': NftError });
        const UpdateMode = IDL.Variant({
            'Set': CandyValue,
            'Lock': CandyValue,
            'Next': IDL.Vec(Update),
        });
        Update.fill(IDL.Record({ 'mode': UpdateMode, 'name': IDL.Text }));
        const UpdateRequest = IDL.Record({
            'id': IDL.Text,
            'update': IDL.Vec(Update),
        });
        const NFTUpdateRequest = IDL.Variant({
            'update': IDL.Record({
                'token_id': IDL.Text,
                'update': UpdateRequest,
                'app_id': IDL.Text,
            }),
            'replace': IDL.Record({ 'token_id': IDL.Text, 'data': CandyValue }),
        });
        const NFTUpdateResponse = IDL.Bool;
        const Result_1 = IDL.Variant({
            'ok': NFTUpdateResponse,
            'err': OrigynError,
        });
        const WithdrawDescription = IDL.Record({
            'token': TokenSpec,
            'token_id': IDL.Text,
            'seller': Account,
            'withdraw_to': Account,
            'buyer': Account,
            'amount': IDL.Nat,
        });
        const WithdrawRequest = IDL.Variant({
            'sale': WithdrawDescription,
            'escrow': WithdrawDescription,
        });
        const WithdrawResponse = IDL.Record({
            'token_id': IDL.Text,
            'txn_type': IDL.Variant({
                'escrow_deposit': IDL.Record({
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_network_updated': IDL.Record({
                    'network': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'escrow_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
                'canister_managers_updated': IDL.Record({
                    'managers': IDL.Vec(IDL.Principal),
                    'extensible': CandyValue,
                }),
                'auction_bid': IDL.Record({
                    'token': TokenSpec,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Text,
                }),
                'burn': IDL.Null,
                'data': IDL.Null,
                'sale_ended': IDL.Record({
                    'token': TokenSpec,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                    'sale_id': IDL.Opt(IDL.Text),
                }),
                'mint': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'sale': IDL.Opt(IDL.Record({ 'token': TokenSpec, 'amount': IDL.Nat })),
                    'extensible': CandyValue,
                }),
                'extensible': CandyValue,
                'owner_transfer': IDL.Record({
                    'to': Account,
                    'from': Account,
                    'extensible': CandyValue,
                }),
                'sale_opened': IDL.Record({
                    'pricing': PricingConfig,
                    'extensible': CandyValue,
                    'sale_id': IDL.Text,
                }),
                'canister_owner_updated': IDL.Record({
                    'owner': IDL.Principal,
                    'extensible': CandyValue,
                }),
                'sale_withdraw': IDL.Record({
                    'fee': IDL.Nat,
                    'token': TokenSpec,
                    'token_id': IDL.Text,
                    'trx_id': TransactionID,
                    'seller': Account,
                    'extensible': CandyValue,
                    'buyer': Account,
                    'amount': IDL.Nat,
                }),
            }),
            'timestamp': IDL.Int,
            'index': IDL.Nat,
        });
        const Result = IDL.Variant({ 'ok': WithdrawResponse, 'err': OrigynError });
        const Nft_Canister = IDL.Service({
            '__advance_time': IDL.Func([IDL.Int], [IDL.Int], []),
            '__set_time_mode': IDL.Func([IDL.Variant({ 'test': IDL.Null, 'standard': IDL.Null })], [IDL.Bool], []),
            'balance': IDL.Func([BalanceRequest], [BalanceResponse__1], ['query']),
            'balanceEXT': IDL.Func([BalanceRequest], [BalanceResponse__1], ['query']),
            'balanceOfDip721': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),
            'balance_of_nft_origyn': IDL.Func([Account], [Result_19], ['query']),
            'bearer': IDL.Func([TokenIdentifier], [Result_18], ['query']),
            'bearerEXT': IDL.Func([TokenIdentifier], [Result_18], ['query']),
            'bearer_batch_nft_origyn': IDL.Func([IDL.Vec(IDL.Text)], [IDL.Vec(Result_17)], ['query']),
            'bearer_nft_origyn': IDL.Func([IDL.Text], [Result_17], ['query']),
            'bid_nft_origyn': IDL.Func([BidRequest], [Result_16], []),
            'canister_status': IDL.Func([IDL.Record({ 'canister_id': canister_id })], [canister_status], []),
            'chunk_nft_origyn': IDL.Func([ChunkRequest], [Result_15], ['query']),
            'collection_nft_origyn': IDL.Func([
                IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat)))),
            ], [Result_14], ['query']),
            'collection_update_origyn': IDL.Func([CollectionUpdateRequest], [Result_9], []),
            'current_log': IDL.Func([], [IDL.Vec(LogEntry)], ['query']),
            'cycles': IDL.Func([], [IDL.Nat], ['query']),
            'end_sale_nft_origyn': IDL.Func([IDL.Text], [Result_13], []),
            'escrow_nft_origyn': IDL.Func([EscrowRequest], [Result_12], []),
            'getEXTTokenIdentifier': IDL.Func([IDL.Text], [IDL.Text], ['query']),
            'get_access_key': IDL.Func([], [Result_2], ['query']),
            'get_canister_managers_nft_origyn': IDL.Func([], [IDL.Vec(Principal)], ['query']),
            'get_canister_network_nft_origyn': IDL.Func([], [IDL.Opt(Principal)], ['query']),
            'get_canister_owner_nft_origyn': IDL.Func([], [Principal], ['query']),
            'get_nat_as_token_id_origyn': IDL.Func([IDL.Nat], [IDL.Text], ['query']),
            'get_owner_soulbound': IDL.Func([CandyValue], [IDL.Bool], []),
            'get_storage_metrics': IDL.Func([], [Result_11], ['query']),
            'get_token_id_as_nat_origyn': IDL.Func([IDL.Text], [IDL.Nat], ['query']),
            'harvest_log': IDL.Func([IDL.Nat], [IDL.Vec(IDL.Vec(LogEntry))], []),
            'history_nft_origyn': IDL.Func([IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat)], [Result_10], ['query']),
            'http_access_key': IDL.Func([], [Result_2], []),
            'http_request': IDL.Func([HttpRequest], [HTTPResponse], ['query']),
            'http_request_streaming_callback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),
            'log_history_page': IDL.Func([IDL.Nat], [IDL.Vec(LogEntry)], ['query']),
            'log_history_page_chunk': IDL.Func([IDL.Nat, IDL.Nat, IDL.Nat], [IDL.Vec(LogEntry)], ['query']),
            'log_history_size': IDL.Func([], [IDL.Nat], ['query']),
            'manage_nft_origyn': IDL.Func([ManageCommand], [Result_9], []),
            'manage_storage_nft_origyn': IDL.Func([ManageStorageRequest], [Result_8], []),
            'market_transfer_batch_nft_origyn': IDL.Func([IDL.Vec(MarketTransferRequest)], [IDL.Vec(Result_7)], []),
            'market_transfer_nft_origyn': IDL.Func([MarketTransferRequest], [Result_7], []),
            'metadata': IDL.Func([TokenIdentifier], [Result_6], ['query']),
            'mint__batch_nft_origyn': IDL.Func([IDL.Vec(IDL.Tuple(IDL.Text, Account))], [IDL.Vec(Result_2)], []),
            'mint_nft_origyn': IDL.Func([IDL.Text, Account], [Result_2], []),
            'nftStreamingCallback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),
            'nft_batch_origyn': IDL.Func([IDL.Vec(IDL.Text)], [IDL.Vec(Result_5)], ['query']),
            'nft_origyn': IDL.Func([IDL.Text], [Result_5], ['query']),
            'nuke_log': IDL.Func([], [], []),
            'ownerOf': IDL.Func([IDL.Nat], [OwnerOfResponse], ['query']),
            'ownerOfDIP721': IDL.Func([IDL.Nat], [OwnerOfResponse], ['query']),
            'owner_transfer_nft_origyn': IDL.Func([OwnerTransferRequest], [Result_4], []),
            'set_log_harvester_id': IDL.Func([IDL.Principal], [], []),
            'stage_batch_nft_origyn': IDL.Func([IDL.Vec(IDL.Record({ 'metadata': CandyValue }))], [IDL.Vec(Result_2)], []),
            'stage_library_nft_origyn': IDL.Func([StageChunkArg], [Result_3], []),
            'stage_nft_origyn': IDL.Func([IDL.Record({ 'metadata': CandyValue })], [Result_2], []),
            'transfer': IDL.Func([TransferRequest], [TransferResponse], []),
            'transferEXT': IDL.Func([TransferRequest], [TransferResponse], []),
            'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result__1], []),
            'transferFromDip721': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result__1], []),
            'update_app_nft_origyn': IDL.Func([NFTUpdateRequest], [Result_1], []),
            'whoami': IDL.Func([], [IDL.Principal], ['query']),
            'withdraw_nft_origyn': IDL.Func([WithdrawRequest], [Result], []),
        });
        return Nft_Canister;
    };
    const init = ({ IDL }) => {
        const Principal = IDL.Principal;
        const InitArgs = IDL.Record({
            'owner': Principal,
            'storage_space': IDL.Opt(IDL.Nat),
        });
        return [InitArgs];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/wicp.did.js":
    /*!****************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/wicp.did.js ***!
      \****************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const TxError = IDL.Variant({
            'InsufficientAllowance': IDL.Null,
            'InsufficientBalance': IDL.Null,
            'ErrorOperationStyle': IDL.Null,
            'Unauthorized': IDL.Null,
            'LedgerTrap': IDL.Null,
            'ErrorTo': IDL.Null,
            'Other': IDL.Null,
            'BlockUsed': IDL.Null,
            'AmountTooSmall': IDL.Null,
        });
        const TxReceipt = IDL.Variant({ 'Ok': IDL.Nat, 'Err': TxError });
        const Metadata = IDL.Record({
            'fee': IDL.Nat,
            'decimals': IDL.Nat8,
            'owner': IDL.Principal,
            'logo': IDL.Text,
            'name': IDL.Text,
            'totalSupply': IDL.Nat,
            'symbol': IDL.Text,
        });
        const TokenInfo = IDL.Record({
            'holderNumber': IDL.Nat64,
            'deployTime': IDL.Nat64,
            'metadata': Metadata,
            'historySize': IDL.Nat64,
            'cycles': IDL.Nat64,
            'feeTo': IDL.Principal,
        });
        return IDL.Service({
            'allowance': IDL.Func([IDL.Principal, IDL.Principal], [IDL.Nat], ['query']),
            'approve': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),
            'balanceOf': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),
            'decimals': IDL.Func([], [IDL.Nat8], ['query']),
            'getAllowanceSize': IDL.Func([], [IDL.Nat64], ['query']),
            'getHolders': IDL.Func([IDL.Nat64, IDL.Nat64], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),
            'getLogo': IDL.Func([], [IDL.Text], ['query']),
            'getMetadata': IDL.Func([], [Metadata], ['query']),
            'getTokenInfo': IDL.Func([], [TokenInfo], ['query']),
            'getUserApprovals': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),
            'historySize': IDL.Func([], [IDL.Nat64], ['query']),
            'mint': IDL.Func([IDL.Opt(IDL.Vec(IDL.Nat8)), IDL.Nat64], [TxReceipt], []),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'owner': IDL.Func([], [IDL.Principal], ['query']),
            'setFee': IDL.Func([IDL.Nat], [], []),
            'setFeeTo': IDL.Func([IDL.Principal], [], []),
            'setLogo': IDL.Func([IDL.Text], [], []),
            'setName': IDL.Func([IDL.Text], [], []),
            'setOwner': IDL.Func([IDL.Principal], [], []),
            'symbol': IDL.Func([], [IDL.Text], ['query']),
            'totalSupply': IDL.Func([], [IDL.Nat], ['query']),
            'transfer': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),
            'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [TxReceipt], []),
            'withdraw': IDL.Func([IDL.Nat64, IDL.Text], [TxReceipt], []),
        });
    };
    const init = ({ IDL }) => {
        return [
            IDL.Text,
            IDL.Text,
            IDL.Text,
            IDL.Nat8,
            IDL.Nat,
            IDL.Principal,
            IDL.Nat,
            IDL.Principal,
            IDL.Principal,
        ];
    };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/idls/xtc.did.js":
    /*!***************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/idls/xtc.did.js ***!
      \***************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.init = void 0;
    exports["default"] = ({ IDL }) => {
        const TxError = IDL.Variant({
            'InsufficientAllowance': IDL.Null,
            'InsufficientBalance': IDL.Null,
            'ErrorOperationStyle': IDL.Null,
            'Unauthorized': IDL.Null,
            'LedgerTrap': IDL.Null,
            'ErrorTo': IDL.Null,
            'Other': IDL.Null,
            'BlockUsed': IDL.Null,
            'AmountTooSmall': IDL.Null,
        });
        const TxReceipt = IDL.Variant({ 'Ok': IDL.Nat, 'Err': TxError });
        const TransactionId = IDL.Nat64;
        const BurnError = IDL.Variant({
            'InsufficientBalance': IDL.Null,
            'InvalidTokenContract': IDL.Null,
            'NotSufficientLiquidity': IDL.Null,
        });
        const BurnResult = IDL.Variant({ 'Ok': TransactionId, 'Err': BurnError });
        const TransactionStatus = IDL.Variant({
            'FAILED': IDL.Null,
            'SUCCEEDED': IDL.Null,
        });
        const EventDetail = IDL.Variant({
            'Approve': IDL.Record({ 'to': IDL.Principal, 'from': IDL.Principal }),
            'Burn': IDL.Record({ 'to': IDL.Principal, 'from': IDL.Principal }),
            'Mint': IDL.Record({ 'to': IDL.Principal }),
            'CanisterCreated': IDL.Record({
                'from': IDL.Principal,
                'canister': IDL.Principal,
            }),
            'CanisterCalled': IDL.Record({
                'from': IDL.Principal,
                'method_name': IDL.Text,
                'canister': IDL.Principal,
            }),
            'Transfer': IDL.Record({ 'to': IDL.Principal, 'from': IDL.Principal }),
            'TransferFrom': IDL.Record({
                'to': IDL.Principal,
                'from': IDL.Principal,
                'caller': IDL.Principal,
            }),
        });
        const Event = IDL.Record({
            'fee': IDL.Nat64,
            'status': TransactionStatus,
            'kind': EventDetail,
            'cycles': IDL.Nat64,
            'timestamp': IDL.Nat64,
        });
        const EventsConnection = IDL.Record({
            'data': IDL.Vec(Event),
            'next_offset': TransactionId,
            'next_canister_id': IDL.Opt(IDL.Principal),
        });
        const Metadata = IDL.Record({
            'fee': IDL.Nat,
            'decimals': IDL.Nat8,
            'owner': IDL.Principal,
            'logo': IDL.Text,
            'name': IDL.Text,
            'totalSupply': IDL.Nat,
            'symbol': IDL.Text,
        });
        const Operation = IDL.Variant({
            'transferFrom': IDL.Null,
            'burn': IDL.Null,
            'mint': IDL.Null,
            'approve': IDL.Null,
            'canisterCalled': IDL.Null,
            'transfer': IDL.Null,
            'canisterCreated': IDL.Null,
        });
        const Time = IDL.Int;
        const TxRecord = IDL.Record({
            'op': Operation,
            'to': IDL.Principal,
            'fee': IDL.Nat,
            'status': TransactionStatus,
            'from': IDL.Principal,
            'timestamp': Time,
            'caller': IDL.Opt(IDL.Principal),
            'index': IDL.Nat,
            'amount': IDL.Nat,
        });
        const MintError = IDL.Variant({ 'NotSufficientLiquidity': IDL.Null });
        const MintResult = IDL.Variant({ 'Ok': TransactionId, 'Err': MintError });
        const Stats = IDL.Record({
            'fee': IDL.Nat,
            'transfers_count': IDL.Nat64,
            'balance': IDL.Nat64,
            'mints_count': IDL.Nat64,
            'transfers_from_count': IDL.Nat64,
            'canisters_created_count': IDL.Nat64,
            'supply': IDL.Nat,
            'burns_count': IDL.Nat64,
            'approvals_count': IDL.Nat64,
            'proxy_calls_count': IDL.Nat64,
            'history_events': IDL.Nat64,
        });
        const ResultCall = IDL.Variant({
            'Ok': IDL.Record({ 'return': IDL.Vec(IDL.Nat8) }),
            'Err': IDL.Text,
        });
        const CreateResult = IDL.Variant({
            'Ok': IDL.Record({ 'canister_id': IDL.Principal }),
            'Err': IDL.Text,
        });
        const ResultSend = IDL.Variant({ 'Ok': IDL.Null, 'Err': IDL.Text });
        return IDL.Service({
            'allowance': IDL.Func([IDL.Principal, IDL.Principal], [IDL.Nat], ['query']),
            'approve': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),
            'balance': IDL.Func([IDL.Opt(IDL.Principal)], [IDL.Nat64], []),
            'balanceOf': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),
            'burn': IDL.Func([IDL.Record({ 'canister_id': IDL.Principal, 'amount': IDL.Nat64 })], [BurnResult], []),
            'decimals': IDL.Func([], [IDL.Nat8], ['query']),
            'events': IDL.Func([IDL.Record({ 'offset': IDL.Opt(IDL.Nat64), 'limit': IDL.Nat16 })], [EventsConnection], ['query']),
            'getMetadata': IDL.Func([], [Metadata], ['query']),
            'getTransaction': IDL.Func([IDL.Nat], [TxRecord], []),
            'getTransactions': IDL.Func([IDL.Nat, IDL.Nat], [IDL.Vec(TxRecord)], []),
            'get_transaction': IDL.Func([TransactionId], [IDL.Opt(Event)], []),
            'halt': IDL.Func([], [], []),
            'historySize': IDL.Func([], [IDL.Nat], ['query']),
            'logo': IDL.Func([], [IDL.Text], ['query']),
            'mint': IDL.Func([IDL.Principal, IDL.Nat], [MintResult], []),
            'name': IDL.Func([], [IDL.Text], ['query']),
            'nameErc20': IDL.Func([], [IDL.Text], ['query']),
            'stats': IDL.Func([], [Stats], ['query']),
            'symbol': IDL.Func([], [IDL.Text], ['query']),
            'totalSupply': IDL.Func([], [IDL.Nat], ['query']),
            'transfer': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),
            'transferErc20': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),
            'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [TxReceipt], []),
            'wallet_balance': IDL.Func([], [IDL.Record({ 'amount': IDL.Nat64 })], ['query']),
            'wallet_call': IDL.Func([
                IDL.Record({
                    'args': IDL.Vec(IDL.Nat8),
                    'cycles': IDL.Nat64,
                    'method_name': IDL.Text,
                    'canister': IDL.Principal,
                }),
            ], [ResultCall], []),
            'wallet_create_canister': IDL.Func([
                IDL.Record({
                    'controller': IDL.Opt(IDL.Principal),
                    'cycles': IDL.Nat64,
                }),
            ], [CreateResult], []),
            'wallet_create_wallet': IDL.Func([
                IDL.Record({
                    'controller': IDL.Opt(IDL.Principal),
                    'cycles': IDL.Nat64,
                }),
            ], [CreateResult], []),
            'wallet_send': IDL.Func([IDL.Record({ 'canister': IDL.Principal, 'amount': IDL.Nat64 })], [ResultSend], []),
        });
    };
    const init = () => { return []; };
    exports.init = init;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/index.js":
    /*!********************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/index.js ***!
      \********************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __exportStar = (this && this.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.HttpAgent = exports.Principal = exports.standards = exports.TokenInterfaces = exports.NFTInterfaces = void 0;
    __exportStar(__webpack_require__(/*! ./registries */ "./node_modules/@psychedelic/dab-js/dist/registries/index.js"), exports);
    __exportStar(__webpack_require__(/*! ./interfaces/nft */ "./node_modules/@psychedelic/dab-js/dist/interfaces/nft.js"), exports);
    __exportStar(__webpack_require__(/*! ./interfaces/token */ "./node_modules/@psychedelic/dab-js/dist/interfaces/token.js"), exports);
    exports.NFTInterfaces = __importStar(__webpack_require__(/*! ./interfaces/nft */ "./node_modules/@psychedelic/dab-js/dist/interfaces/nft.js"));
    exports.TokenInterfaces = __importStar(__webpack_require__(/*! ./interfaces/token */ "./node_modules/@psychedelic/dab-js/dist/interfaces/token.js"));
    var standards_1 = __webpack_require__(/*! ./constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    Object.defineProperty(exports, "standards", ({ enumerable: true, get: function () { return __importDefault(standards_1).default; } }));
    var principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    Object.defineProperty(exports, "Principal", ({ enumerable: true, get: function () { return principal_1.Principal; } }));
    var agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    Object.defineProperty(exports, "HttpAgent", ({ enumerable: true, get: function () { return agent_1.HttpAgent; } }));
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/interfaces/nft.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/interfaces/nft.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/interfaces/token.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/interfaces/token.js ***!
      \*******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/registries/address_book.js":
    /*!**************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/registries/address_book.js ***!
      \**************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.removeAddress = exports.addAddress = exports.getAddresses = exports.getAddressBookActor = void 0;
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const address_book_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/address_book.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/address_book.did.js"));
    const CANISTER_ID = 'i73cm-daaaa-aaaah-abhea-cai';
    const getAddressBookActor = (agent) => {
        const actor = agent_1.Actor.createActor(address_book_did_1.default, { agent, canisterId: CANISTER_ID });
        return actor;
    };
    exports.getAddressBookActor = getAddressBookActor;
    const getAddresses = (agent) => __awaiter(void 0, void 0, void 0, function* () {
        const actor = (0, exports.getAddressBookActor)(agent);
        const addresses = yield actor.get_all();
        return addresses.map(address => ({
            name: address.name,
            description: address.description,
            emoji: address.emoji,
            value: address.value,
        }));
    });
    exports.getAddresses = getAddresses;
    const addAddress = (agent, newAddress) => __awaiter(void 0, void 0, void 0, function* () {
        const actor = (0, exports.getAddressBookActor)(agent);
        const addResponse = yield actor.add({
            name: newAddress.name,
            description: newAddress.description,
            emoji: newAddress.emoji,
            value: newAddress.value,
        });
        return addResponse;
    });
    exports.addAddress = addAddress;
    const removeAddress = (agent, addressName) => __awaiter(void 0, void 0, void 0, function* () {
        const actor = (0, exports.getAddressBookActor)(agent);
        const removeResponse = yield actor.remove(addressName);
        return removeResponse;
    });
    exports.removeAddress = removeAddress;
    exports["default"] = {
        getAddressBookActor: exports.getAddressBookActor,
        getAddresses: exports.getAddresses,
        addAddress: exports.addAddress,
        removeAddress: exports.removeAddress,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/registries/canister_registry.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/registries/canister_registry.js ***!
      \*******************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.getAll = exports.getMultipleCanisterInfo = exports.getCanisterInfo = exports.CanisterRegistry = void 0;
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
    const canister_registry_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/canister_registry.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/canister_registry.did.js"));
    const constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@psychedelic/dab-js/dist/constants/index.js");
    const standard_registry_1 = __importDefault(__webpack_require__(/*! ./standard_registry */ "./node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js"));
    const actorFactory_1 = __webpack_require__(/*! ../utils/actorFactory */ "./node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");
    const registry_1 = __webpack_require__(/*! ../utils/registry */ "./node_modules/@psychedelic/dab-js/dist/utils/registry.js");
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const CANISTER_ID = 'curr3-vaaaa-aaaah-abbdq-cai';
    const DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });
    const formatBackwardsCompatible = (metadata) => {
        if (!metadata) {
            return metadata;
        }
        const { thumbnail, name, description, frontend, details } = metadata;
        return { url: (frontend === null || frontend === void 0 ? void 0 : frontend[0]) || '', name, description, version: Number(details.version), logo_url: thumbnail };
    };
    class CanisterRegistry extends standard_registry_1.default {
        constructor(agent) {
            super(CANISTER_ID, agent);
            this.getAll = () => __awaiter(this, void 0, void 0, function* () {
                const canistersMetadata = yield this.actor.get_all();
                return canistersMetadata.map(registry_1.formatMetadata);
            });
            this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT, canisterId: CANISTER_ID, IDL: canister_registry_did_1.default });
        }
    }
    exports.CanisterRegistry = CanisterRegistry;
    const getCanisterInfo = ({ canisterId, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {
        const canisterRegistry = new CanisterRegistry(agent);
        const canister = yield canisterRegistry.get(principal_1.Principal.from(canisterId).toString());
        const formattedCanister = formatBackwardsCompatible(canister);
        return formattedCanister && Object.assign(Object.assign({}, formattedCanister), { canisterId: canisterId.toString() });
    });
    exports.getCanisterInfo = getCanisterInfo;
    const getMultipleCanisterInfo = ({ canisterIds, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {
        const canistersMetadata = yield Promise.all(canisterIds.map((canisterId) => (0, exports.getCanisterInfo)({ canisterId, agent })));
        if (canistersMetadata.length === 0)
            return [];
        return canistersMetadata.filter(canister => !!canister);
    });
    exports.getMultipleCanisterInfo = getMultipleCanisterInfo;
    const getAll = (agent) => __awaiter(void 0, void 0, void 0, function* () {
        const allCanisters = yield new CanisterRegistry(agent).getAll();
        return allCanisters.map(formatBackwardsCompatible);
    });
    exports.getAll = getAll;
    exports["default"] = {
        getCanisterInfo: exports.getCanisterInfo,
        getMultipleCanisterInfo: exports.getMultipleCanisterInfo,
        getAll: (agent) => new CanisterRegistry(agent).getAll,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/registries/index.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/registries/index.js ***!
      \*******************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (this && this.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    __exportStar(__webpack_require__(/*! ./nfts_registry */ "./node_modules/@psychedelic/dab-js/dist/registries/nfts_registry.js"), exports);
    __exportStar(__webpack_require__(/*! ./canister_registry */ "./node_modules/@psychedelic/dab-js/dist/registries/canister_registry.js"), exports);
    __exportStar(__webpack_require__(/*! ./token_registry */ "./node_modules/@psychedelic/dab-js/dist/registries/token_registry.js"), exports);
    __exportStar(__webpack_require__(/*! ./address_book */ "./node_modules/@psychedelic/dab-js/dist/registries/address_book.js"), exports);
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/registries/nfts_registry.js":
    /*!***************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/registries/nfts_registry.js ***!
      \***************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.getCachedUserNFTs = exports.getBatchedNFTs = exports.getAllUserNFTs = exports.getAllNFTS = exports.getNFTInfo = exports.getNFTActor = exports.getUserCollectionTokens = exports.NFTRegistry = void 0;
    const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
    const ext_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/ext */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ext.js"));
    const ic_punks_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/ic_punks */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ic_punks.js"));
    const nft_origyn_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/nft_origyn */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/nft_origyn.js"));
    const departure_labs_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/departure_labs */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/departure_labs.js"));
    const dip_721_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/dip_721 */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721.js"));
    const standards_1 = __webpack_require__(/*! ../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    const constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@psychedelic/dab-js/dist/constants/index.js");
    const nft_registry_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/nft_registry.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/nft_registry.did.js"));
    const standard_registry_1 = __importDefault(__webpack_require__(/*! ./standard_registry */ "./node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js"));
    const actorFactory_1 = __webpack_require__(/*! ../utils/actorFactory */ "./node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");
    const registry_1 = __webpack_require__(/*! ../utils/registry */ "./node_modules/@psychedelic/dab-js/dist/utils/registry.js");
    const ccc_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/ccc */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ccc.js"));
    const CANISTER_ID = 'ctqxp-yyaaa-aaaah-abbda-cai';
    const BATCH_AMOUNT = 5;
    const NFT_STANDARDS = {
        [standards_1.NFT.ext]: ext_1.default,
        [standards_1.NFT.icpunks]: ic_punks_1.default,
        [standards_1.NFT.nftOrigyn]: nft_origyn_1.default,
        [standards_1.NFT.departuresLabs]: departure_labs_1.default,
        [standards_1.NFT.erc721]: dip_721_1.default,
        [standards_1.NFT.dip721]: dip_721_1.default,
        [standards_1.NFT.c3]: ccc_1.default
    };
    const DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });
    class NFTRegistry extends standard_registry_1.default {
        constructor(agent) {
            super(CANISTER_ID, agent);
            this.getAll = () => __awaiter(this, void 0, void 0, function* () {
                const canistersMetadata = yield this.actor.get_all();
                return canistersMetadata.map(registry_1.formatMetadata);
            });
            this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT, canisterId: CANISTER_ID, IDL: nft_registry_did_1.default });
        }
    }
    exports.NFTRegistry = NFTRegistry;
    const getUserCollectionTokens = (collection, user, agent = DEFAULT_AGENT, callback = () => { }, debug = false) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const NFTActor = (0, exports.getNFTActor)({
                canisterId: collection.principal_id.toString(),
                agent,
                standard: collection.standard
            });
            const details = yield NFTActor.getUserTokens(user);
            const collectionDetails = {
                name: collection.name,
                canisterId: collection.principal_id.toString(),
                standard: collection.standard,
                description: collection.description,
                icon: collection.icon,
                tokens: details.map((detail) => (Object.assign(Object.assign({}, detail), { collection: collection.name }))),
            };
            if (callback) {
                yield (callback === null || callback === void 0 ? void 0 : callback(collectionDetails));
            }
            return collectionDetails;
        }
        catch (e) {
            if (debug) {
                console.error(e);
            }
            return {
                name: collection.name,
                canisterId: collection.principal_id.toString(),
                standard: collection.standard,
                tokens: [],
            };
        }
    });
    exports.getUserCollectionTokens = getUserCollectionTokens;
    const standardNormaliser = ({ standard }) => {
        const userStandardNormalised = standard.toUpperCase();
        const systemStandardNormalised = standards_1.NFT.dip721.toUpperCase();
        const startsWithDip721 = userStandardNormalised.startsWith(systemStandardNormalised);
        const hasSuffix = userStandardNormalised.split(systemStandardNormalised).filter(v => v).length > 0;
        const hasDeprecatedDip721Term = startsWithDip721 && hasSuffix;
        if (hasDeprecatedDip721Term) {
            console.warn(`Warning! Use the term DIP721, not ${standard}, suffixed and others are being deprecated and support will be dropped soon!`);
            return standards_1.NFT.dip721;
        }
        return userStandardNormalised;
    };
    const getNFTActor = ({ canisterId, agent, standard }) => {
        // We might need to override deprecated standards
        // which is computed by the standardNormaliser
        const standardNormalised = standardNormaliser({
            standard,
        });
        if (!(standardNormalised in NFT_STANDARDS)) {
            console.error(`Standard ${standardNormalised} is not implemented`);
            throw new Error(`standard is not supported: ${standardNormalised}`);
        }
        return new NFT_STANDARDS[standardNormalised](canisterId, agent);
    };
    exports.getNFTActor = getNFTActor;
    const getNFTInfo = ({ nftCanisterId, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {
        const registry = new NFTRegistry(agent);
        const result = yield registry.get(nftCanisterId);
        if (!result)
            return result;
        return Object.assign(Object.assign({}, result), { icon: result.thumbnail, standard: result.details.standard });
    });
    exports.getNFTInfo = getNFTInfo;
    const getAllNFTS = ({ agent = DEFAULT_AGENT } = {}) => __awaiter(void 0, void 0, void 0, function* () {
        const registry = new NFTRegistry(agent);
        const allNFTs = yield registry.getAll();
        return allNFTs.map((nft) => (Object.assign(Object.assign({}, nft), { icon: nft.thumbnail, standard: nft.details.standard })));
    });
    exports.getAllNFTS = getAllNFTS;
    const getAllUserNFTs = ({ user, agent = DEFAULT_AGENT, debug = false, }) => __awaiter(void 0, void 0, void 0, function* () {
        const NFTCollections = yield (0, exports.getAllNFTS)({ agent });
        const userPrincipal = user instanceof principal_1.Principal ? user : principal_1.Principal.fromText(user);
        const result = yield Promise.all(NFTCollections.map((collection) => (0, exports.getUserCollectionTokens)(collection, userPrincipal, agent, () => { }, debug)));
        return result.filter((element) => element.tokens.length);
    });
    exports.getAllUserNFTs = getAllUserNFTs;
    const getBatchedNFTs = ({ principal, callback, batchSize = BATCH_AMOUNT, onFinish, agent = DEFAULT_AGENT, }) => __awaiter(void 0, void 0, void 0, function* () {
        const NFTCollections = yield (0, exports.getAllNFTS)({ agent });
        let result = [];
        for (let i = 0; i < NFTCollections.length; i += batchSize) {
            const batch = NFTCollections.slice(i, i + batchSize);
            const batchResult = yield Promise.all(batch.map(collection => (0, exports.getUserCollectionTokens)(collection, principal, agent, callback)));
            result = [...result, ...batchResult];
        }
        if (onFinish) {
            yield (onFinish === null || onFinish === void 0 ? void 0 : onFinish(result));
        }
        return result.filter((element) => { var _a; return (_a = element === null || element === void 0 ? void 0 : element.tokens) === null || _a === void 0 ? void 0 : _a.length; });
    });
    exports.getBatchedNFTs = getBatchedNFTs;
    const getCachedUserNFTs = ({ userPID, refresh }) => __awaiter(void 0, void 0, void 0, function* () {
        const url = `${constants_1.KYASSHU_URL}/dab/user/nfts/${userPID}`;
        const result = yield axios_1.default.get(url, { params: { refresh } });
        return result.data;
    });
    exports.getCachedUserNFTs = getCachedUserNFTs;
    exports["default"] = {
        getBatchedNFTs: exports.getBatchedNFTs,
        getNFTActor: exports.getNFTActor,
        getNFTInfo: exports.getNFTInfo,
        getAllNFTS: exports.getAllNFTS,
        getAllUserNFTs: exports.getAllUserNFTs,
        getCachedUserNFTs: exports.getCachedUserNFTs,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js ***!
      \*******************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@psychedelic/dab-js/dist/constants/index.js");
    const registry_standard_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/registry_standard.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/registry_standard.did.js"));
    const registry_1 = __webpack_require__(/*! ../utils/registry */ "./node_modules/@psychedelic/dab-js/dist/utils/registry.js");
    const cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
    const DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });
    class Registry {
        constructor(canisterId, agent = DEFAULT_AGENT) {
            this.name = () => __awaiter(this, void 0, void 0, function* () {
                return this.actor.name();
            });
            this.add = (metadata) => __awaiter(this, void 0, void 0, function* () {
                return this.actor.add(metadata !== null && metadata !== void 0 ? metadata : []);
            });
            this.get = (principalId) => __awaiter(this, void 0, void 0, function* () {
                const data = yield this.actor.get(principal_1.Principal.fromText(principalId));
                if (data.length === 0)
                    return undefined;
                return (0, registry_1.formatMetadata)(data[0]);
            });
            this.remove = (principalId) => __awaiter(this, void 0, void 0, function* () {
                return this.actor.remove(principal_1.Principal.fromText(principalId));
            });
            this.actor = agent_1.Actor.createActor(registry_standard_did_1.default, {
                agent: agent,
                canisterId,
            });
            this.canisterId = canisterId;
        }
    }
    exports["default"] = Registry;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/registries/token_registry.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/registries/token_registry.js ***!
      \****************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.getTokens = exports.TokenRegistry = exports.getTokenActor = exports.TOKEN_STANDARDS = void 0;
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
    const token_registry_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/token_registry.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dab_registries/token_registry.did.js"));
    const standard_registry_1 = __importDefault(__webpack_require__(/*! ./standard_registry */ "./node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js"));
    const actorFactory_1 = __webpack_require__(/*! ../utils/actorFactory */ "./node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");
    const registry_1 = __webpack_require__(/*! ../utils/registry */ "./node_modules/@psychedelic/dab-js/dist/utils/registry.js");
    const constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@psychedelic/dab-js/dist/constants/index.js");
    const token_standards_1 = __webpack_require__(/*! ../standard_wrappers/token_standards */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/index.js");
    const standards_1 = __webpack_require__(/*! ../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    const CANISTER_ID = 'b7hhy-tyaaa-aaaah-abbja-cai';
    const DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });
    exports.TOKEN_STANDARDS = Object.values(standards_1.TOKEN);
    const getTokenActor = ({ canisterId, agent, standard, }) => {
        if (!exports.TOKEN_STANDARDS.includes(standard)) {
            console.error(`Standard ${standard} is not implemented`);
            throw new Error(`standard is not supported: ${standard}`);
        }
        return (0, token_standards_1.createTokenActor)(canisterId, agent, standard);
    };
    exports.getTokenActor = getTokenActor;
    class TokenRegistry extends standard_registry_1.default {
        constructor(agent) {
            super(CANISTER_ID, agent);
            this.getAll = () => __awaiter(this, void 0, void 0, function* () {
                const tokenCanistersMetadata = yield this.actor.get_all();
                return tokenCanistersMetadata.map(registry_1.formatMetadata);
            });
            this.actor = (0, actorFactory_1.generateActor)({
                agent: agent || DEFAULT_AGENT,
                canisterId: CANISTER_ID,
                IDL: token_registry_did_1.default,
            });
        }
    }
    exports.TokenRegistry = TokenRegistry;
    const getTokens = ({ agent = DEFAULT_AGENT } = {}) => __awaiter(void 0, void 0, void 0, function* () {
        const tokenRegistry = new TokenRegistry(agent);
        const tokenCanisters = yield tokenRegistry.getAll();
        return tokenCanisters.map((token) => (Object.assign(Object.assign({}, token), { logo: token.thumbnail, name: token.name, description: token.description, website: token.frontend.length ? token.frontend[0] : '', principal_id: token.principal_id, standard: token.details.standard, total_supply: [token.details.total_supply], symbol: token.details.symbol })));
    });
    exports.getTokens = getTokens;
    exports["default"] = {
        getTokenActor: exports.getTokenActor,
        getTokens: exports.getTokens,
        addToken: ({ agent, tokenInfo }) => __awaiter(void 0, void 0, void 0, function* () { return new TokenRegistry(agent).add(tokenInfo); }),
        // editToken: async ({ agent, tokenInfo }) => new TokenRegistry(agent).edit(tokenInfo),
        removeToken: ({ agent, canisterId }) => __awaiter(void 0, void 0, void 0, function* () { return new TokenRegistry(agent).remove(canisterId); }),
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ccc.js":
    /*!**************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ccc.js ***!
      \**************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const c3_did_1 = __importDefault(__webpack_require__(/*! ../../idls/c3.did */ "./node_modules/@psychedelic/dab-js/dist/idls/c3.did.js"));
    const default_1 = __importDefault(__webpack_require__(/*! ./default */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    class CCC extends default_1.default {
        constructor(canisterId, agent) {
            super(canisterId, agent);
            this.standard = standards_1.NFT.c3;
            this.serializeTokenData = (tokenData, prinId) => {
                return {
                    index: BigInt(tokenData.id),
                    canister: this.canisterId,
                    url: `https://${prinId.toText()}.raw.ic0.app/token/${tokenData.id}`,
                    name: `${tokenData.id}`,
                    metadata: tokenData,
                    standard: this.standard,
                };
            };
            this.actor = agent_1.Actor.createActor(c3_did_1.default, {
                agent,
                canisterId,
            });
        }
        getMetadata() {
            throw new Error('Method not implemented.');
        }
        getUserTokens(principal) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokensIndexes = yield this.actor.getAllNFT(principal);
                const tokensData = yield Promise.all(tokensIndexes.map((item) => __awaiter(this, void 0, void 0, function* () {
                    const tokenIndex = item[0];
                    const principal = item[1];
                    const userTokensResult = yield this.actor.getTokenById(tokenIndex);
                    if ('err' in userTokensResult)
                        throw new Error(Object.keys(userTokensResult.err)[0]);
                    return { detail: userTokensResult.ok, principal };
                })));
                return tokensData.map((token) => this.serializeTokenData(token.detail, token.principal));
            });
        }
        transfer(to, tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const from = yield this.agent.getPrincipal();
                const transferResult = yield this.actor.transferFrom(from, to, BigInt(tokenIndex));
                if ('err' in transferResult)
                    throw new Error(Object.keys(transferResult.err)[0]);
            });
        }
        details(tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenData = yield this.actor.getTokenById(BigInt(tokenIndex));
                if ('err' in tokenData)
                    throw new Error(Object.keys(tokenData.err)[0]);
                const prinId = yield this.actor.getNftStoreCIDByIndex(BigInt(tokenIndex));
                if (!prinId)
                    throw new Error('Error tokenIndex');
                return this.serializeTokenData(tokenData.ok, prinId);
            });
        }
    }
    exports["default"] = CCC;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js":
    /*!******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js ***!
      \******************************************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    class NFT {
        constructor(canisterId, agent) {
            this.agent = agent;
            this.canisterId = canisterId;
        }
    }
    exports["default"] = NFT;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/departure_labs.js":
    /*!*************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/departure_labs.js ***!
      \*************************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const departure_labs_did_1 = __importDefault(__webpack_require__(/*! ../../idls/departure_labs.did */ "./node_modules/@psychedelic/dab-js/dist/idls/departure_labs.did.js"));
    const default_1 = __importDefault(__webpack_require__(/*! ./default */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    class DepartureLabs extends default_1.default {
        constructor(canisterId, agent) {
            super(canisterId, agent);
            this.standard = standards_1.NFT.departuresLabs;
            this.serializeTokenData = (tokenData) => ({
                index: BigInt(tokenData.id),
                canister: this.canisterId,
                url: `https://${this.canisterId}.raw.ic0.app/nft/${tokenData.id}`,
                metadata: tokenData,
                standard: this.standard,
            });
            this.actor = agent_1.Actor.createActor(departure_labs_did_1.default, {
                agent,
                canisterId,
            });
        }
        getMetadata() {
            throw new Error('Method not implemented.');
        }
        getUserTokens(principal) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokensIndexes = yield this.actor.balanceOf(principal);
                const tokensData = yield Promise.all(tokensIndexes.map((tokenIndex) => __awaiter(this, void 0, void 0, function* () {
                    const userTokensResult = yield this.actor.tokenMetadataByIndex(tokenIndex);
                    if ('err' in userTokensResult)
                        throw new Error(Object.keys(userTokensResult.err)[0]);
                    return userTokensResult.ok;
                })));
                return tokensData.map((token) => this.serializeTokenData(token));
            });
        }
        transfer(to, tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const transferResult = yield this.actor.transfer(to, tokenIndex.toString(10));
                if ('err' in transferResult)
                    throw new Error(Object.keys(transferResult.err)[0]);
            });
        }
        details(tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenData = yield this.actor.tokenMetadataByIndex(tokenIndex.toString(10));
                if ('err' in tokenData)
                    throw new Error(Object.keys(tokenData.err)[0]);
                return this.serializeTokenData(tokenData.ok);
            });
        }
    }
    exports["default"] = DepartureLabs;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721.js":
    /*!******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721.js ***!
      \******************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const dip_721_did_1 = __importDefault(__webpack_require__(/*! ../../idls/dip_721.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dip_721.did.js"));
    const default_1 = __importDefault(__webpack_require__(/*! ./default */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    const extractMetadataValue = (metadata) => {
        const metadataKey = Object.keys(metadata)[0];
        const value = metadata[metadataKey];
        return typeof value === 'object' ? JSON.stringify(value) : value;
    };
    const deprecationWarningForDip721LegacyRequests = ({ methodName }) => `Oops! An attempt to ${methodName} failed, a fallback to legacy will be used. Legacy DIP721 contract support will be dropped soon, the contract should be updated`;
    class ERC721 extends default_1.default {
        constructor(canisterId, agent) {
            super(canisterId, agent);
            this.standard = standards_1.NFT.dip721;
            this.actor = agent_1.Actor.createActor(dip_721_did_1.default, {
                agent,
                canisterId,
            });
        }
        backwardsCompatibleGuard(legacyMethod, newMethod) {
            return (params = []) => __awaiter(this, void 0, void 0, function* () {
                let res;
                try {
                    res = yield this.actor[newMethod](...params);
                }
                catch (err) {
                    deprecationWarningForDip721LegacyRequests({
                        methodName: newMethod,
                    });
                    res = yield this.actor[legacyMethod](...params);
                }
                return res;
            });
        }
        getUserTokens(principal) {
            return __awaiter(this, void 0, void 0, function* () {
                const guardedGetUserTokens = this.backwardsCompatibleGuard('ownerTokenMetadata', 'dip721_owner_token_metadata');
                const userTokensResult = yield guardedGetUserTokens([principal]);
                const tokens = userTokensResult['Ok'] || [];
                if (!tokens.length)
                    return [];
                const formattedTokenData = tokens.map((token) => {
                    var _a, _b;
                    const tokenIndex = token.token_identifier;
                    const formatedMetadata = this.formatMetadata(token);
                    if (!formatedMetadata)
                        return;
                    const operator = (_b = (_a = token.operator) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toText();
                    return this.serializeTokenData(formatedMetadata, tokenIndex, principal.toText(), operator);
                }).filter((token) => token);
                return formattedTokenData;
            });
        }
        transfer(to, tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const guardedTransfer = this.backwardsCompatibleGuard('transfer', 'dip721_transfer');
                const transferResult = yield guardedTransfer([to, BigInt(tokenIndex)]);
                if ('Err' in transferResult)
                    throw new Error(`${Object.keys(transferResult.Err)[0]}: ${Object.values(transferResult.Err)[0]}`);
            });
        }
        details(tokenIndex) {
            var _a, _b, _c, _d, _e, _f;
            return __awaiter(this, void 0, void 0, function* () {
                const guardedDetails = this.backwardsCompatibleGuard('tokenMetadata', 'dip721_token_metadata');
                const metadataResult = yield guardedDetails([BigInt(tokenIndex)]);
                if ('Err' in metadataResult)
                    throw new Error(`${Object.keys(metadataResult.Err)[0]}: ${Object.values(metadataResult.Err)[0]}`);
                const metadata = metadataResult === null || metadataResult === void 0 ? void 0 : metadataResult.Ok;
                const formatedMetadata = this.formatMetadata(metadata);
                const owner = (_c = (_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.owner) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toText) === null || _c === void 0 ? void 0 : _c.call(_b);
                const operator = (_f = (_e = (_d = metadata === null || metadata === void 0 ? void 0 : metadata.operator) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.toText) === null || _f === void 0 ? void 0 : _f.call(_e);
                return this.serializeTokenData(formatedMetadata, tokenIndex, owner, operator);
            });
        }
        getMetadata() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const guardedGetMetadata = this.backwardsCompatibleGuard('metadata', 'dip721_get_metadata');
                const metadata = yield guardedGetMetadata();
                return {
                    icon: metadata === null || metadata === void 0 ? void 0 : metadata.logo[0],
                    name: ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.name) === null || _a === void 0 ? void 0 : _a[0]) || '',
                    standard: this.standard,
                    canisterId: this.canisterId,
                    tokens: [],
                    description: '',
                };
            });
        }
        serializeTokenData(metadata, tokenIndex, owner, operator) {
            var _a, _b;
            return {
                index: BigInt(tokenIndex),
                canister: this.canisterId,
                metadata,
                owner,
                url: ((_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.location) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.TextContent) || '',
                standard: this.standard,
                operator,
            };
        }
        formatMetadata(metadata) {
            const metadataResult = { properties: new Array() };
            if (!(metadata === null || metadata === void 0 ? void 0 : metadata.properties) || !Array.isArray(metadata.properties)) {
                console.warn(`Oops! Failed to format the metadata properties for token, field is missing or invalid. See ${JSON.stringify(metadata)}`);
                console.log(metadata);
                return;
            }
            metadata.properties.forEach((prop) => {
                const propertyName = prop[0];
                metadataResult[propertyName] = { value: prop[1] };
                const value = (() => {
                    try {
                        return extractMetadataValue(prop[1]);
                    }
                    catch (err) {
                        console.warn(`Oops! Failed to extract metadata value for property ${propertyName}, is that a valid key value pair?`);
                        console.error(err);
                    }
                })();
                metadataResult.properties = [
                    ...metadataResult.properties,
                    { name: prop[0], value },
                ];
            });
            // Filter out reserved props from the unique traits
            metadataResult.properties = metadataResult.properties.filter(({ name }) => !['location', 'thumbnail', 'contentHash', 'contentType'].includes(name));
            return metadataResult;
        }
    }
    exports["default"] = ERC721;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ext.js":
    /*!**************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ext.js ***!
      \**************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    /* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const ext_did_1 = __importDefault(__webpack_require__(/*! ../../idls/ext.did */ "./node_modules/@psychedelic/dab-js/dist/idls/ext.did.js"));
    const default_1 = __importDefault(__webpack_require__(/*! ./default */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));
    const account_1 = __webpack_require__(/*! ../../utils/account */ "./node_modules/@psychedelic/dab-js/dist/utils/account.js");
    const number_1 = __webpack_require__(/*! ../../utils/number */ "./node_modules/@psychedelic/dab-js/dist/utils/number.js");
    const canisters_1 = __webpack_require__(/*! ../../constants/canisters */ "./node_modules/@psychedelic/dab-js/dist/constants/canisters.js");
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    const getTokenIdentifier = (canister, index) => {
        const padding = Buffer.from('\x0Atid');
        const array = new Uint8Array([
            ...padding,
            ...principal_1.Principal.fromText(canister).toUint8Array(),
            ...(0, number_1.to32bits)(index),
        ]);
        return principal_1.Principal.fromUint8Array(array).toText();
    };
    const extImageUrl = (canisterId, index, tokenIdentifier) => ({
        [canisters_1.NFT_CANISTERS.WRAPPED_PUNKS]: `https://${canisters_1.NFT_CANISTERS.IC_PUNKS}.raw.ic0.app/Token/${index}`,
        [canisters_1.NFT_CANISTERS.WRAPPED_DRIP]: `https://${canisters_1.NFT_CANISTERS.IC_DRIP}.raw.ic0.app?tokenId=${index}`,
    }[canisterId] ||
        `https://${canisterId}.raw.ic0.app/?type=thumbnail&tokenid=${tokenIdentifier}`);
    class EXT extends default_1.default {
        constructor(canisterId, agent) {
            super(canisterId, agent);
            this.standard = standards_1.NFT.ext;
            this.actor = agent_1.Actor.createActor(ext_did_1.default, {
                agent,
                canisterId,
            });
        }
        getUserTokens(principal) {
            return __awaiter(this, void 0, void 0, function* () {
                const accountId = (0, account_1.getAccountId)(principal);
                const userTokensResult = yield this.actor.tokens_ext(accountId);
                if ('err' in userTokensResult)
                    throw new Error(`${Object.keys(userTokensResult.err)[0]}: ${Object.values(userTokensResult.err)[0]}`);
                const tokens = userTokensResult.ok || [];
                return tokens.map((token) => {
                    const metadata = token[2];
                    const tokenIndex = token[0];
                    return this.serializeTokenData(metadata, getTokenIdentifier(this.canisterId, tokenIndex), tokenIndex);
                });
            });
        }
        getMetadata() {
            throw new Error('Method not implemented.');
        }
        transfer(to, tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenIdentifier = getTokenIdentifier(this.canisterId, tokenIndex);
                const from = yield this.agent.getPrincipal();
                const dummyMemmo = new Array(32).fill(0);
                const transferResult = yield this.actor.transfer({
                    to: { principal: to },
                    from: { principal: from },
                    token: tokenIdentifier,
                    amount: BigInt(1),
                    memo: dummyMemmo,
                    notify: false,
                    subaccount: [],
                    fee: BigInt(0),
                });
                if ('err' in transferResult)
                    throw new Error(`${Object.keys(transferResult.err)[0]}: ${Object.values(transferResult.err)[0]}`);
            });
        }
        details(tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenIdentifier = getTokenIdentifier(this.canisterId, tokenIndex);
                const metadataResult = yield this.actor.metadata(tokenIdentifier);
                if ('err' in metadataResult)
                    throw new Error(`${Object.keys(metadataResult.err)[0]}: ${Object.values(metadataResult.err)[0]}`);
                const { metadata = {} } = 'nonfungible' in metadataResult.ok ? metadataResult.ok.nonfungible : {};
                return this.serializeTokenData(metadata, tokenIdentifier, tokenIndex);
            });
        }
        serializeTokenData(metadata, tokenIdentifier, tokenIndex) {
            return {
                id: tokenIdentifier,
                index: BigInt(tokenIndex),
                canister: this.canisterId,
                metadata: metadata.length ? metadata[0] : undefined,
                url: extImageUrl(this.canisterId, tokenIndex, tokenIdentifier),
                standard: this.standard,
            };
        }
    }
    exports["default"] = EXT;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ic_punks.js":
    /*!*******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ic_punks.js ***!
      \*******************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const icpunks_did_1 = __importDefault(__webpack_require__(/*! ../../idls/icpunks.did */ "./node_modules/@psychedelic/dab-js/dist/idls/icpunks.did.js"));
    const default_1 = __importDefault(__webpack_require__(/*! ./default */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));
    const canisters_1 = __webpack_require__(/*! ../../constants/canisters */ "./node_modules/@psychedelic/dab-js/dist/constants/canisters.js");
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    const getICPBunnyCanisterId = (index) => canisters_1.NFT_CANISTERS.ICP_BUNNY_STORAGE[index % 10];
    const imageUrl = (canisterId, index, tokenDataUrl) => ({
        [canisters_1.NFT_CANISTERS.ICP_BUNNY_MAIN]: `https://${getICPBunnyCanisterId(index)}.raw.ic0.app/Token/${index}`,
    }[canisterId] || `https://${canisterId}.raw.ic0.app${tokenDataUrl}`);
    class ICPUNKS extends default_1.default {
        constructor(canisterId, agent) {
            super(canisterId, agent);
            this.standard = standards_1.NFT.icpunks;
            this.serializeTokenData = (tokenData) => ({
                index: BigInt(tokenData.id),
                canister: this.canisterId,
                url: imageUrl(this.canisterId, Number.parseInt(tokenData.id.toString(), 10), tokenData.url),
                name: tokenData.name,
                metadata: tokenData,
                standard: this.standard,
            });
            this.actor = agent_1.Actor.createActor(icpunks_did_1.default, {
                agent,
                canisterId,
            });
        }
        getMetadata() {
            throw new Error('Method not implemented.');
        }
        getUserTokens(principal) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokensIndexes = yield this.actor.user_tokens(principal);
                const tokensData = yield Promise.all(tokensIndexes.map((tokenIndex) => this.actor.data_of(tokenIndex)));
                return tokensData.map((token) => this.serializeTokenData(token));
            });
        }
        transfer(to, tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const success = yield this.actor.transfer_to(to, BigInt(tokenIndex));
                if (!success) {
                    throw new Error('Error transfering token');
                }
            });
        }
        details(tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenData = yield this.actor.data_of(BigInt(tokenIndex));
                return this.serializeTokenData(tokenData);
            });
        }
    }
    exports["default"] = ICPUNKS;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/nft_origyn.js":
    /*!*********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/nft_origyn.js ***!
      \*********************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const nft_origyn_did_1 = __importDefault(__webpack_require__(/*! ../../idls/nft_origyn.did */ "./node_modules/@psychedelic/dab-js/dist/idls/nft_origyn.did.js"));
    const default_1 = __importDefault(__webpack_require__(/*! ./default */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    class NFTOrigyn extends default_1.default {
        constructor(canisterId, agent) {
            super(canisterId, agent);
            this.standard = standards_1.NFT.nftOrigyn;
            this.serializeTokenData = (tokenData) => {
                if ('err' in tokenData)
                    throw new Error(Object.keys(tokenData.err)[0]);
                const metadata = tokenData.ok.metadata;
                const tokenID = metadata.Class.find(({ name }) => name === "id").value.Text;
                return {
                    index: tokenID,
                    canister: this.canisterId,
                    url: `https://${this.canisterId}.raw.ic0.app/-/${tokenID}`,
                    name: tokenID,
                    metadata: metadata,
                    standard: this.standard,
                };
            };
            this.actor = agent_1.Actor.createActor(nft_origyn_did_1.default, {
                agent,
                canisterId,
            });
        }
        getUserTokens(principal) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokensIndexes = yield this.actor.balance_of_nft_origyn({ principal });
                if ('err' in tokensIndexes) {
                    throw new Error(Object.keys(tokensIndexes.err)[0]);
                }
                const tokensData = yield Promise.all(tokensIndexes.ok.nfts.map((item) => __awaiter(this, void 0, void 0, function* () {
                    const userTokensResult = yield this.actor.nft_origyn(item);
                    if ('err' in userTokensResult)
                        throw new Error(Object.keys(userTokensResult.err)[0]);
                    return { detail: userTokensResult, principal };
                })));
                return tokensData.map((token) => this.serializeTokenData(token.detail));
            });
        }
        getMetadata() {
            throw new Error('Method not implemented.');
        }
        transfer(to, tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const from = yield this.agent.getPrincipal();
                const balance = yield this.actor.balance_of_nft_origyn({ principal: to });
                if ('err' in balance) {
                    throw new Error(Object.keys(balance.err)[0]);
                }
                const escrow = balance.ok.escrow.find(({ token_id }) => token_id === tokenIndex);
                if (!escrow) {
                    // This error occurs if no pending escrows for this NFT exist (see market_transfer_nft_origyn comment)
                    throw new Error("No pending escrows for transfer.");
                }
                // market transfer relies on escrow(payment) existing for NFT, to only be able to sell NFTs directly thru canister
                // there is owner_transfer_nft_origyn which take "from" and "to" params, but that method is not preferred
                const transferResult = yield this.actor.market_transfer_nft_origyn({
                    'token_id': tokenIndex,
                    'sales_config': {
                        pricing: { 'instant': null },
                        escrow_receipt: [escrow]
                    },
                });
                if ('err' in transferResult)
                    throw new Error(Object.keys(transferResult.err)[0]);
            });
        }
        details(tokenIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenData = yield this.actor.nft_origyn(tokenIndex);
                return this.serializeTokenData(tokenData);
            });
        }
    }
    exports["default"] = NFTOrigyn;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/dip20Methods.js":
    /*!*************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/dip20Methods.js ***!
      \*************************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    /* eslint-disable @typescript-eslint/camelcase */
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const methods_1 = __webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");
    const getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {
        const metadataResult = yield actor._getMetadata();
        return {
            fungible: {
                symbol: metadataResult.symbol,
                decimals: metadataResult.decimals,
                name: metadataResult.name,
                logo: metadataResult.logo,
                fee: metadataResult.fee,
                totalSupply: metadataResult.totalSupply,
                owner: metadataResult.owner,
            },
        };
    });
    const send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {
        const transferResult = yield actor._transfer(principal_1.Principal.fromText(to), amount);
        if ('Ok' in transferResult)
            return { transactionId: transferResult.Ok.toString() };
        throw new Error(Object.keys(transferResult.Err)[0]);
    });
    const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
        const decimals = yield getDecimals(actor);
        const value = (yield actor._balanceOf(user)).toString();
        return { value, decimals };
    });
    const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw new Error('BURN NOT SUPPORTED');
    });
    const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/extMethods.js":
    /*!***********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/extMethods.js ***!
      \***********************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const methods_1 = __webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");
    const getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {
        actor._balance;
        const token = agent_1.Actor.canisterIdOf(actor).toText();
        const extensions = yield actor._extensions();
        if (!extensions.includes('@ext/common'))
            throw new Error('The provided canister does not implement commont extension');
        const metadataResult = yield actor._metadata(token);
        if ('ok' in metadataResult)
            return metadataResult.ok;
        throw new Error(Object.keys(metadataResult.err)[0]);
    });
    const send = (actor, { to, from, amount }) => __awaiter(void 0, void 0, void 0, function* () {
        const dummyMemmo = new Array(32).fill(0);
        const token = agent_1.Actor.canisterIdOf(actor).toText();
        const data = {
            to: { principal: principal_1.Principal.fromText(to) },
            from: { principal: principal_1.Principal.from(from) },
            amount,
            token,
            memo: dummyMemmo,
            notify: false,
            subaccount: [],
            fee: BigInt(0),
        };
        const transferResult = yield actor._transfer(data);
        if ('ok' in transferResult)
            return { amount: transferResult.ok.toString() };
        throw new Error(Object.keys(transferResult.err)[0]);
    });
    const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
        const token = agent_1.Actor.canisterIdOf(actor).toText();
        const balanceResult = yield actor._balance({
            token,
            user: { principal: user },
        });
        const decimals = yield getDecimals(actor);
        if ('ok' in balanceResult)
            return { value: balanceResult.ok.toString(), decimals };
        throw new Error(Object.keys(balanceResult.err)[0]);
    });
    const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw new Error('BURN NOT SUPPORTED');
    });
    const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpStandardMethods.js":
    /*!*******************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpStandardMethods.js ***!
      \*******************************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    /* eslint-disable @typescript-eslint/camelcase */
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const methods_1 = __webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");
    const account_1 = __webpack_require__(/*! ../../utils/account */ "./node_modules/@psychedelic/dab-js/dist/utils/account.js");
    const validations_1 = __webpack_require__(/*! ../../utils/validations */ "./node_modules/@psychedelic/dab-js/dist/utils/validations.js");
    const registries_1 = __webpack_require__(/*! ../../registries */ "./node_modules/@psychedelic/dab-js/dist/registries/index.js");
    const getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c;
        const agent = agent_1.Actor.agentOf(_actor);
        try {
            const tokenRegistry = new registries_1.TokenRegistry(agent);
            const token = yield tokenRegistry.get(agent_1.Actor.canisterIdOf(_actor).toString());
            const { fee = 0.002, decimals = 8 } = (token === null || token === void 0 ? void 0 : token.details) || {};
            const numberFee = Number((_a = fee === null || fee === void 0 ? void 0 : fee.toString) === null || _a === void 0 ? void 0 : _a.call(fee));
            const numberDecimals = Number((_b = decimals === null || decimals === void 0 ? void 0 : decimals.toString) === null || _b === void 0 ? void 0 : _b.call(decimals));
            const parsedFee = numberFee * Math.pow(10, numberDecimals);
            return {
                fungible: {
                    symbol: ((_c = token === null || token === void 0 ? void 0 : token.details) === null || _c === void 0 ? void 0 : _c.symbol) || 'ICP',
                    name: (token === null || token === void 0 ? void 0 : token.name) || 'ICP',
                    decimals: numberDecimals,
                    fee: parsedFee,
                },
            };
        }
        catch (e) {
            console.error('Error while fetching token metadata, falling back to default values', e);
            // Fallback to default ICP values when dab is unavailable
            return {
                fungible: {
                    symbol: 'ICP',
                    name: 'ICP',
                    decimals: 8,
                    fee: 10000,
                },
            };
            ;
        }
    });
    const send = (actor, { to, amount, opts }) => __awaiter(void 0, void 0, void 0, function* () {
        const metadata = yield getMetadata(actor);
        const { fee = 0.002, decimals = BigInt(8) } = (metadata === null || metadata === void 0 ? void 0 : metadata.fungible) || {};
        const defaultArgs = {
            fee: BigInt(fee * Math.pow(10, parseInt(decimals.toString(), 10))),
            memo: BigInt(0),
        };
        const response = yield actor._send_dfx({
            to: (0, validations_1.validatePrincipalId)(to) ? (0, account_1.getAccountId)(principal_1.Principal.fromText(to)) : to,
            fee: { e8s: (opts === null || opts === void 0 ? void 0 : opts.fee) || defaultArgs.fee },
            amount: { e8s: amount },
            memo: (opts === null || opts === void 0 ? void 0 : opts.memo) ? BigInt(opts.memo) : defaultArgs.memo,
            from_subaccount: [],
            created_at_time: [],
        });
        return { height: yield response.toString() };
    });
    const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const account = (0, account_1.getAccountId)(user);
            const balance = yield actor._account_balance_dfx({ account });
            return { value: balance.e8s.toString(), decimals: 8 };
        }
        catch (e) {
            return {
                value: 'Error',
                decimals: 8,
                error: 'Error while fetching your balance',
            };
        }
    });
    const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw new Error('BURN NOT SUPPORTED');
    });
    const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/index.js":
    /*!******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/index.js ***!
      \******************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.parseBalance = exports.createTokenActor = void 0;
    const actorFactory_1 = __webpack_require__(/*! ../../utils/actorFactory */ "./node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");
    const methods_1 = __importDefault(__webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js"));
    const xtcMethods_1 = __importDefault(__webpack_require__(/*! ./xtcMethods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/xtcMethods.js"));
    const extMethods_1 = __importDefault(__webpack_require__(/*! ./extMethods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/extMethods.js"));
    const dip20Methods_1 = __importDefault(__webpack_require__(/*! ./dip20Methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/dip20Methods.js"));
    const ext_did_1 = __importDefault(__webpack_require__(/*! ../../idls/ext.did */ "./node_modules/@psychedelic/dab-js/dist/idls/ext.did.js"));
    const xtc_did_1 = __importDefault(__webpack_require__(/*! ../../idls/xtc.did */ "./node_modules/@psychedelic/dab-js/dist/idls/xtc.did.js"));
    const dip_20_did_1 = __importDefault(__webpack_require__(/*! ../../idls/dip_20.did */ "./node_modules/@psychedelic/dab-js/dist/idls/dip_20.did.js"));
    const ledger_did_1 = __importDefault(__webpack_require__(/*! ../../idls/ledger.did */ "./node_modules/@psychedelic/dab-js/dist/idls/ledger.did.js"));
    const standards_1 = __webpack_require__(/*! ../../constants/standards */ "./node_modules/@psychedelic/dab-js/dist/constants/standards.js");
    const wicp_did_1 = __importDefault(__webpack_require__(/*! ../../idls/wicp.did */ "./node_modules/@psychedelic/dab-js/dist/idls/wicp.did.js"));
    const wicpMethods_1 = __importDefault(__webpack_require__(/*! ./wicpMethods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/wicpMethods.js"));
    const rosettaMethods_1 = __importDefault(__webpack_require__(/*! ./rosettaMethods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/rosettaMethods.js"));
    const icpStandardMethods_1 = __importDefault(__webpack_require__(/*! ./icpStandardMethods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpStandardMethods.js"));
    const getMethods = (standard) => ({
        [standards_1.TOKEN.xtc]: xtcMethods_1.default,
        [standards_1.TOKEN.ext]: extMethods_1.default,
        [standards_1.TOKEN.dip20]: dip20Methods_1.default,
        [standards_1.TOKEN.wicp]: wicpMethods_1.default,
        [standards_1.TOKEN.rosetta]: rosettaMethods_1.default,
        [standards_1.TOKEN.icp]: icpStandardMethods_1.default,
    }[standard] || methods_1.default);
    const getIdl = (standard) => {
        const idl = {
            [standards_1.TOKEN.xtc]: xtc_did_1.default,
            [standards_1.TOKEN.ext]: ext_did_1.default,
            [standards_1.TOKEN.dip20]: dip_20_did_1.default,
            [standards_1.TOKEN.wicp]: wicp_did_1.default,
            [standards_1.TOKEN.rosetta]: ledger_did_1.default,
            [standards_1.TOKEN.icp]: ledger_did_1.default
        }[standard];
        if (!idl)
            throw new Error(`Standard ${standard} Not Implemented`);
        return idl;
    };
    const createTokenActor = (canisterId, agent, standard) => __awaiter(void 0, void 0, void 0, function* () {
        const idl = getIdl(standard);
        const actor = new ((0, actorFactory_1.createExtendedActorClass)(agent, getMethods(standard), canisterId, idl))();
        return actor;
    });
    exports.createTokenActor = createTokenActor;
    const parseBalance = (balance) => {
        return (parseInt(balance.value, 10) / Math.pow(10, balance.decimals)).toString();
    };
    exports.parseBalance = parseBalance;
    exports["default"] = {};
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js":
    /*!********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js ***!
      \********************************************************************************************/
    /***/ (function(__unused_webpack_module, exports) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.parseAmountToSend = exports.getDecimalsFromMetadata = void 0;
    const send = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw Error('Standard Not Implemented');
    });
    const getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
        throw Error('Standard Not Implemented');
    });
    const getBalance = (_actor, _user) => __awaiter(void 0, void 0, void 0, function* () {
        throw Error('Standard Not Implemented');
    });
    const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw Error('Standard Not Implemented');
    });
    const getDecimals = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
        throw Error('Standard Not Implemented');
    });
    const getDecimalsFromMetadata = (metadata) => {
        return 'fungible' in metadata ? metadata.fungible.decimals : 0;
    };
    exports.getDecimalsFromMetadata = getDecimalsFromMetadata;
    const parseAmountToSend = (amount, decimals) => {
        return BigInt(parseFloat(amount) * Math.pow(10, decimals));
    };
    exports.parseAmountToSend = parseAmountToSend;
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/rosettaMethods.js":
    /*!***************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/rosettaMethods.js ***!
      \***************************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    /* eslint-disable @typescript-eslint/camelcase */
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js"));
    const methods_1 = __webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");
    const account_1 = __webpack_require__(/*! ../../utils/account */ "./node_modules/@psychedelic/dab-js/dist/utils/account.js");
    const validations_1 = __webpack_require__(/*! ../../utils/validations */ "./node_modules/@psychedelic/dab-js/dist/utils/validations.js");
    const DECIMALS = 8;
    const NET_ID = {
        blockchain: 'Internet Computer',
        network: '00000000000000020101',
    };
    const ROSETTA_URL = 'https://rosetta-api.internetcomputer.org';
    const getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            fungible: {
                symbol: 'ICP',
                decimals: DECIMALS,
                name: 'ICP',
                fee: 10000,
            },
        };
    });
    const send = (actor, { to, amount, opts }) => __awaiter(void 0, void 0, void 0, function* () {
        const defaultArgs = {
            fee: BigInt(10000),
            memo: BigInt(0),
        };
        const response = yield actor._send_dfx({
            to: (0, validations_1.isValidPrincipal)(to) ? (0, account_1.getAccountId)(principal_1.Principal.fromText(to)) : to,
            fee: { e8s: (opts === null || opts === void 0 ? void 0 : opts.fee) || defaultArgs.fee },
            amount: { e8s: amount },
            memo: (opts === null || opts === void 0 ? void 0 : opts.memo) ? BigInt(opts.memo) : defaultArgs.memo,
            from_subaccount: [],
            created_at_time: [],
        });
        return { height: yield response.toString() };
    });
    const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
        const accountId = (0, account_1.getAccountId)(user);
        const decimals = yield getDecimals(actor);
        const response = yield (0, cross_fetch_1.default)(`${ROSETTA_URL}/account/balance`, {
            method: 'POST',
            body: JSON.stringify({
                network_identifier: NET_ID,
                account_identifier: {
                    address: accountId,
                },
            }),
            headers: {
                'Content-Type': 'application/json',
                Accept: '*/*',
            },
        });
        if (!response.ok) {
            return { value: 'Error', decimals, error: response.statusText };
        }
        const { balances } = yield response.json();
        const [{ value, currency }] = balances;
        return { value, decimals: currency.decimals };
    });
    const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw new Error('BURN NOT SUPPORTED');
    });
    const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/wicpMethods.js":
    /*!************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/wicpMethods.js ***!
      \************************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    /* eslint-disable @typescript-eslint/camelcase */
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const methods_1 = __webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");
    const getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {
        const metadataResult = yield actor._getMetadata();
        return {
            fungible: {
                symbol: metadataResult.symbol,
                decimals: metadataResult.decimals,
                name: metadataResult.name,
                logo: metadataResult.logo,
                fee: metadataResult.fee,
                totalSupply: metadataResult.totalSupply,
                owner: metadataResult.owner,
            },
        };
    });
    const send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {
        const transferResult = yield actor._transfer(principal_1.Principal.fromText(to), amount);
        if ('Ok' in transferResult)
            return { transactionId: transferResult.Ok.toString() };
        throw new Error(Object.keys(transferResult.Err)[0]);
    });
    const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
        const decimals = yield getDecimals(actor);
        const value = (yield actor._balanceOf(user)).toString();
        return { value, decimals };
    });
    const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
        throw new Error('BURN NOT SUPPORTED');
    });
    const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/xtcMethods.js":
    /*!***********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/xtcMethods.js ***!
      \***********************************************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    /* eslint-disable @typescript-eslint/camelcase */
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const methods_1 = __webpack_require__(/*! ./methods */ "./node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");
    const getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {
        const metadataResult = yield actor._getMetadata();
        return {
            fungible: {
                symbol: metadataResult.symbol,
                decimals: metadataResult.decimals,
                name: metadataResult.name,
                logo: metadataResult.logo,
                fee: metadataResult.fee,
                totalSupply: metadataResult.totalSupply,
                owner: metadataResult.owner,
            },
        };
    });
    const send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {
        const transferResult = yield actor._transferErc20(principal_1.Principal.fromText(to), amount);
        if ('Ok' in transferResult)
            return { transactionId: transferResult.Ok.toString() };
        throw new Error(Object.keys(transferResult.Err)[0]);
    });
    const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
        const decimals = yield getDecimals(actor);
        const value = (yield actor._balanceOf(user)).toString();
        return { value, decimals };
    });
    const burnXTC = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {
        const decimals = yield getDecimals(actor);
        const parsedAmount = (0, methods_1.parseAmountToSend)(amount, decimals);
        return actor._burn({ canister_id: to, amount: parsedAmount });
    });
    const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
    exports["default"] = {
        send,
        getMetadata,
        getBalance,
        burnXTC,
        getDecimals,
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/utils/account.js":
    /*!****************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/utils/account.js ***!
      \****************************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    /* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
    
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.getAccountId = void 0;
    const crypto_js_1 = __importDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));
    const buffer_crc32_1 = __importDefault(__webpack_require__(/*! buffer-crc32 */ "./node_modules/buffer-crc32/index.js"));
    const ACCOUNT_DOMAIN_SEPERATOR = '\x0Aaccount-id';
    const SUB_ACCOUNT_ZERO = Buffer.alloc(32);
    const byteArrayToWordArray = (byteArray) => {
        const wordArray = [];
        let i;
        for (i = 0; i < byteArray.length; i += 1) {
            wordArray[(i / 4) | 0] |= byteArray[i] << (24 - 8 * i);
        }
        // eslint-disable-next-line
        const result = crypto_js_1.default.lib.WordArray.create(wordArray, byteArray.length);
        return result;
    };
    const wordToByteArray = (word, length) => {
        const byteArray = [];
        const xFF = 0xff;
        if (length > 0)
            byteArray.push(word >>> 24);
        if (length > 1)
            byteArray.push((word >>> 16) & xFF);
        if (length > 2)
            byteArray.push((word >>> 8) & xFF);
        if (length > 3)
            byteArray.push(word & xFF);
        return byteArray;
    };
    const wordArrayToByteArray = (wordArray, length) => {
        if (wordArray.hasOwnProperty('sigBytes') &&
            wordArray.hasOwnProperty('words')) {
            length = wordArray.sigBytes;
            wordArray = wordArray.words;
        }
        let result = [];
        let bytes;
        let i = 0;
        while (length > 0) {
            bytes = wordToByteArray(wordArray[i], Math.min(4, length));
            length -= bytes.length;
            result = [...result, bytes];
            i++;
        }
        return [].concat.apply([], result);
    };
    const intToHex = (val) => val < 0 ? (Number(val) >>> 0).toString(16) : Number(val).toString(16);
    // We generate a CRC32 checksum, and trnasform it into a hexString
    const generateChecksum = (hash) => {
        const crc = buffer_crc32_1.default.unsigned(Buffer.from(hash));
        const hex = intToHex(crc);
        return hex.padStart(8, '0');
    };
    /*
        Used dfinity/keysmith/account/account.go as a base for the ID generation
    */
    const getAccountId = (principal, subAccount) => {
        const sha = crypto_js_1.default.algo.SHA224.create();
        sha.update(ACCOUNT_DOMAIN_SEPERATOR); // Internally parsed with UTF-8, like go does
        sha.update(byteArrayToWordArray(principal.toUint8Array()));
        const subBuffer = Buffer.from(SUB_ACCOUNT_ZERO);
        if (subAccount) {
            subBuffer.writeUInt32BE(subAccount);
        }
        sha.update(byteArrayToWordArray(subBuffer));
        const hash = sha.finalize();
        /// While this is backed by an array of length 28, it's canonical representation
        /// is a hex string of length 64. The first 8 characters are the CRC-32 encoded
        /// hash of the following 56 characters of hex. Both, upper and lower case
        /// characters are valid in the input string and can even be mixed.
        /// [ic/rs/rosetta-api/ledger_canister/src/account_identifier.rs]
        const byteArray = wordArrayToByteArray(hash, 28);
        const checksum = generateChecksum(byteArray);
        const val = checksum + hash.toString();
        return val;
    };
    exports.getAccountId = getAccountId;
    exports["default"] = {};
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js":
    /*!*********************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js ***!
      \*********************************************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.generateActor = exports.createExtendedActorClass = void 0;
    const agent_1 = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    const createExtendedActorClass = (agent, methods, canisterId, IDLFactory) => {
        class ExtendedActor extends agent_1.Actor.createActorClass(IDLFactory) {
            constructor() {
                const principalCanisterId = typeof canisterId === 'string' ? principal_1.Principal.fromText(canisterId) : canisterId;
                super({ agent, canisterId: principalCanisterId });
                Object.keys(this).forEach(methodName => {
                    this[`_${methodName}`] = this[methodName];
                });
                Object.keys(methods).forEach(methodName => {
                    this[methodName] = ((...args) => methods[methodName](this, ...args));
                });
            }
        }
        return ExtendedActor;
    };
    exports.createExtendedActorClass = createExtendedActorClass;
    function generateActor({ agent, canisterId, IDL }) {
        return agent_1.Actor.createActor(IDL, {
            agent,
            canisterId: principal_1.Principal.fromText(canisterId),
        });
    }
    exports.generateActor = generateActor;
    exports["default"] = { createExtendedActorClass: exports.createExtendedActorClass, generateActor };
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/utils/number.js":
    /*!***************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/utils/number.js ***!
      \***************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.from32bits = exports.to32bits = void 0;
    /* eslint-disable prefer-template */
    /* eslint-disable no-bitwise */
    const to32bits = (num) => {
        const b = new ArrayBuffer(4);
        new DataView(b).setUint32(0, num);
        return Array.from(new Uint8Array(b));
    };
    exports.to32bits = to32bits;
    const from32bits = (ba) => {
        let value;
        for (let i = 0; i < 4; i += 1) {
            value = (value << 8) | ba[i];
        }
        return value;
    };
    exports.from32bits = from32bits;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/utils/registry.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/utils/registry.js ***!
      \*****************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.formatMetadata = exports.formatRegistryDetails = exports.parseDetailValue = void 0;
    const BOOLEAN_DETAIL_TYPE = ["True", "False"];
    const parseDetailValue = (detailValue) => {
        const key = Object.keys(detailValue)[0];
        const value = BOOLEAN_DETAIL_TYPE.includes(key) ? Boolean(key) : Object.values(detailValue)[0];
        if (Array.isArray(value)) {
            return value.map((v) => typeof value === 'number' ? v : (0, exports.parseDetailValue)(v));
        }
        return value;
    };
    exports.parseDetailValue = parseDetailValue;
    const formatRegistryDetails = (details) => {
        const formattedDetails = {};
        for (const [key, detailValue] of details) {
            formattedDetails[key] = (0, exports.parseDetailValue)(detailValue);
        }
        return formattedDetails;
    };
    exports.formatRegistryDetails = formatRegistryDetails;
    const formatMetadata = (metadata) => (Object.assign(Object.assign({}, metadata), { details: (0, exports.formatRegistryDetails)(metadata.details) }));
    exports.formatMetadata = formatMetadata;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/dist/utils/validations.js":
    /*!********************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/dist/utils/validations.js ***!
      \********************************************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.validateToken = exports.validateCanisterId = exports.validateAccountId = exports.validatePrincipalId = exports.isValidPrincipal = exports.ALPHANUM_REGEX = exports.PRINCIPAL_REGEX = exports.CANISTER_MAX_LENGTH = void 0;
    const principal_1 = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    exports.CANISTER_MAX_LENGTH = 27;
    exports.PRINCIPAL_REGEX = /(\w{5}-){10}\w{3}/;
    exports.ALPHANUM_REGEX = /^[a-zA-Z0-9]+$/;
    const isValidPrincipal = (text) => {
        try {
            return principal_1.Principal.fromText(text).toText() === text;
        }
        catch (e) {
            return false;
        }
    };
    exports.isValidPrincipal = isValidPrincipal;
    const validatePrincipalId = (text) => {
        try {
            return Boolean(exports.PRINCIPAL_REGEX.test(text) && (0, exports.isValidPrincipal)(text));
        }
        catch (e) {
            return false;
        }
    };
    exports.validatePrincipalId = validatePrincipalId;
    const validateAccountId = (text) => text.length === 64 && exports.ALPHANUM_REGEX.test(text);
    exports.validateAccountId = validateAccountId;
    const validateCanisterId = (text) => {
        try {
            return Boolean(text.length <= exports.CANISTER_MAX_LENGTH && (0, exports.isValidPrincipal)(text));
        }
        catch (e) {
            return false;
        }
    };
    exports.validateCanisterId = validateCanisterId;
    const validateToken = (metadata) => Boolean(!!metadata.decimal && !!metadata.name && !!metadata.symbol);
    exports.validateToken = validateToken;
    
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/actor.js":
    /*!***************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/actor.js ***!
      \***************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Actor: () => (/* binding */ Actor),
    /* harmony export */   ActorCallError: () => (/* binding */ ActorCallError),
    /* harmony export */   CanisterInstallMode: () => (/* binding */ CanisterInstallMode),
    /* harmony export */   QueryCallRejectedError: () => (/* binding */ QueryCallRejectedError),
    /* harmony export */   UpdateCallRejectedError: () => (/* binding */ UpdateCallRejectedError)
    /* harmony export */ });
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _canisters_management__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canisters/management */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/errors.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./polling */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/index.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./request_id */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js");
    
    
    
    
    
    
    
    
    class ActorCallError extends _errors__WEBPACK_IMPORTED_MODULE_3__.AgentError {
        constructor(canisterId, methodName, type, props) {
            super([
                `Call failed:`,
                `  Canister: ${canisterId.toText()}`,
                `  Method: ${methodName} (${type})`,
                ...Object.getOwnPropertyNames(props).map(n => `  "${n}": ${JSON.stringify(props[n])}`),
            ].join('\n'));
            this.canisterId = canisterId;
            this.methodName = methodName;
            this.type = type;
            this.props = props;
        }
    }
    class QueryCallRejectedError extends ActorCallError {
        constructor(canisterId, methodName, result) {
            var _a;
            super(canisterId, methodName, 'query', {
                Status: result.status,
                Code: (_a = _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
                Message: result.reject_message,
            });
            this.result = result;
        }
    }
    class UpdateCallRejectedError extends ActorCallError {
        constructor(canisterId, methodName, requestId, response) {
            super(canisterId, methodName, 'update', {
                'Request ID': (0,_request_id__WEBPACK_IMPORTED_MODULE_7__.toHex)(requestId),
                'HTTP status code': response.status.toString(),
                'HTTP status text': response.statusText,
            });
            this.requestId = requestId;
            this.response = response;
        }
    }
    /**
     * The mode used when installing a canister.
     */
    var CanisterInstallMode;
    (function (CanisterInstallMode) {
        CanisterInstallMode["Install"] = "install";
        CanisterInstallMode["Reinstall"] = "reinstall";
        CanisterInstallMode["Upgrade"] = "upgrade";
    })(CanisterInstallMode || (CanisterInstallMode = {}));
    const metadataSymbol = Symbol.for('ic-agent-metadata');
    /**
     * An actor base class. An actor is an object containing only functions that will
     * return a promise. These functions are derived from the IDL definition.
     */
    class Actor {
        constructor(metadata) {
            this[metadataSymbol] = Object.freeze(metadata);
        }
        /**
         * Get the Agent class this Actor would call, or undefined if the Actor would use
         * the default agent (global.ic.agent).
         * @param actor The actor to get the agent of.
         */
        static agentOf(actor) {
            return actor[metadataSymbol].config.agent;
        }
        /**
         * Get the interface of an actor, in the form of an instance of a Service.
         * @param actor The actor to get the interface of.
         */
        static interfaceOf(actor) {
            return actor[metadataSymbol].service;
        }
        static canisterIdOf(actor) {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__.Principal.from(actor[metadataSymbol].config.canisterId);
        }
        static async install(fields, config) {
            const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;
            // Need to transform the arg into a number array.
            const arg = fields.arg ? [...fields.arg] : [];
            // Same for module.
            const wasmModule = [...fields.module];
            const canisterId = typeof config.canisterId === 'string'
                ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__.Principal.fromText(config.canisterId)
                : config.canisterId;
            await (0,_canisters_management__WEBPACK_IMPORTED_MODULE_2__.getManagementCanister)(config).install_code({
                mode: { [mode]: null },
                arg,
                wasm_module: wasmModule,
                canister_id: canisterId,
            });
        }
        static async createCanister(config) {
            const { canister_id: canisterId } = await (0,_canisters_management__WEBPACK_IMPORTED_MODULE_2__.getManagementCanister)(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
            return canisterId;
        }
        static async createAndInstallCanister(interfaceFactory, fields, config) {
            const canisterId = await this.createCanister(config);
            await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
            return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
        }
        static createActorClass(interfaceFactory) {
            const service = interfaceFactory({ IDL: _dfinity_candid__WEBPACK_IMPORTED_MODULE_4__.IDL });
            class CanisterActor extends Actor {
                constructor(config) {
                    const canisterId = typeof config.canisterId === 'string'
                        ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__.Principal.fromText(config.canisterId)
                        : config.canisterId;
                    super({
                        config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
                        service,
                    });
                    for (const [methodName, func] of service._fields) {
                        this[methodName] = _createActorMethod(this, methodName, func);
                    }
                }
            }
            return CanisterActor;
        }
        static createActor(interfaceFactory, configuration) {
            return new (this.createActorClass(interfaceFactory))(configuration);
        }
    }
    // IDL functions can have multiple return values, so decoding always
    // produces an array. Ensure that functions with single or zero return
    // values behave as expected.
    function decodeReturnValue(types, msg) {
        const returnValues = _dfinity_candid__WEBPACK_IMPORTED_MODULE_4__.IDL.decode(types, buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(msg));
        switch (returnValues.length) {
            case 0:
                return undefined;
            case 1:
                return returnValues[0];
            default:
                return returnValues;
        }
    }
    const DEFAULT_ACTOR_CONFIG = {
        pollingStrategyFactory: _polling__WEBPACK_IMPORTED_MODULE_5__.strategy.defaultStrategy,
    };
    function _createActorMethod(actor, methodName, func) {
        let caller;
        if (func.annotations.includes('query')) {
            caller = async (options, ...args) => {
                var _a, _b;
                // First, if there's a config transformation, call it.
                options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
                const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();
                const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
                const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_4__.IDL.encode(func.argTypes, args);
                const result = await agent.query(cid, { methodName, arg });
                switch (result.status) {
                    case "rejected" /* Rejected */:
                        throw new QueryCallRejectedError(cid, methodName, result);
                    case "replied" /* Replied */:
                        return decodeReturnValue(func.retTypes, result.reply.arg);
                }
            };
        }
        else {
            caller = async (options, ...args) => {
                var _a, _b;
                // First, if there's a config transformation, call it.
                options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
                const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();
                const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
                const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__.Principal.from(canisterId);
                const ecid = effectiveCanisterId !== undefined ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_6__.Principal.from(effectiveCanisterId) : cid;
                const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_4__.IDL.encode(func.argTypes, args);
                const { requestId, response } = await agent.call(cid, {
                    methodName,
                    arg,
                    effectiveCanisterId: ecid,
                });
                if (!response.ok) {
                    throw new UpdateCallRejectedError(cid, methodName, requestId, response);
                }
                const pollStrategy = pollingStrategyFactory();
                const responseBytes = await (0,_polling__WEBPACK_IMPORTED_MODULE_5__.pollForResponse)(agent, ecid, requestId, pollStrategy);
                if (responseBytes !== undefined) {
                    return decodeReturnValue(func.retTypes, responseBytes);
                }
                else if (func.retTypes.length === 0) {
                    return undefined;
                }
                else {
                    throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);
                }
            };
        }
        const handler = (...args) => caller({}, ...args);
        handler.withOptions =
            (options) => (...args) => caller(options, ...args);
        return handler;
    }
    //# sourceMappingURL=actor.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/api.js":
    /*!*******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/api.js ***!
      \*******************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ReplicaRejectCode: () => (/* binding */ ReplicaRejectCode)
    /* harmony export */ });
    /**
     * Codes used by the replica for rejecting a message.
     * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.
     */
    var ReplicaRejectCode;
    (function (ReplicaRejectCode) {
        ReplicaRejectCode[ReplicaRejectCode["SysFatal"] = 1] = "SysFatal";
        ReplicaRejectCode[ReplicaRejectCode["SysTransient"] = 2] = "SysTransient";
        ReplicaRejectCode[ReplicaRejectCode["DestinationInvalid"] = 3] = "DestinationInvalid";
        ReplicaRejectCode[ReplicaRejectCode["CanisterReject"] = 4] = "CanisterReject";
        ReplicaRejectCode[ReplicaRejectCode["CanisterError"] = 5] = "CanisterError";
    })(ReplicaRejectCode || (ReplicaRejectCode = {}));
    //# sourceMappingURL=api.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js ***!
      \**************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Expiry: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry),
    /* harmony export */   HttpAgent: () => (/* binding */ HttpAgent),
    /* harmony export */   RequestStatusResponseStatus: () => (/* binding */ RequestStatusResponseStatus),
    /* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeExpiryTransform),
    /* harmony export */   makeNonceTransform: () => (/* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)
    /* harmony export */ });
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../auth */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/auth.js");
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../cbor */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/cbor.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../request_id */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var _transforms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transforms */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js");
    /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js");
    
    
    
    
    
    
    
    
    
    var RequestStatusResponseStatus;
    (function (RequestStatusResponseStatus) {
        RequestStatusResponseStatus["Received"] = "received";
        RequestStatusResponseStatus["Processing"] = "processing";
        RequestStatusResponseStatus["Replied"] = "replied";
        RequestStatusResponseStatus["Rejected"] = "rejected";
        RequestStatusResponseStatus["Unknown"] = "unknown";
        RequestStatusResponseStatus["Done"] = "done";
    })(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
    // Default delta for ingress expiry is 5 minutes.
    const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;
    // Root public key for the IC, encoded as hex
    const IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +
        'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +
        '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +
        'b01291091c5f87b98883463f98091a0baaae';
    function getDefaultFetch() {
        const result = typeof window === 'undefined'
            ? typeof __webpack_require__.g === 'undefined'
                ? typeof self === 'undefined'
                    ? undefined
                    : self.fetch.bind(self)
                : __webpack_require__.g.fetch.bind(__webpack_require__.g)
            : window.fetch.bind(window);
        if (!result) {
            throw new Error('Could not find default `fetch` implementation.');
        }
        return result;
    }
    // A HTTP agent allows users to interact with a client of the internet computer
    // using the available methods. It exposes an API that closely follows the
    // public view of the internet computer, and is not intended to be exposed
    // directly to the majority of users due to its low-level interface.
    //
    // There is a pipeline to apply transformations to the request before sending
    // it to the client. This is to decouple signature, nonce generation and
    // other computations so that this class can stay as simple as possible while
    // allowing extensions.
    class HttpAgent {
        constructor(options = {}) {
            this._pipeline = [];
            this._rootKeyFetched = false;
            this.rootKey = (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobFromHex)(IC_ROOT_KEY);
            if (options.source) {
                if (!(options.source instanceof HttpAgent)) {
                    throw new Error("An Agent's source can only be another HttpAgent");
                }
                this._pipeline = [...options.source._pipeline];
                this._identity = options.source._identity;
                this._fetch = options.source._fetch;
                this._host = options.source._host;
                this._credentials = options.source._credentials;
            }
            else {
                this._fetch = options.fetch || getDefaultFetch() || fetch.bind(__webpack_require__.g);
            }
            if (options.host !== undefined) {
                if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {
                    this._host = new URL(window.location.protocol + '//' + options.host);
                }
                else {
                    this._host = new URL(options.host);
                }
            }
            else if (options.source !== undefined) {
                // Safe to ignore here.
                this._host = options.source._host;
            }
            else {
                const location = typeof window !== 'undefined' ? window.location : undefined;
                if (!location) {
                    throw new Error('Must specify a host to connect to.');
                }
                this._host = new URL(location + '');
            }
            if (options.credentials) {
                const { name, password } = options.credentials;
                this._credentials = `${name}${password ? ':' + password : ''}`;
            }
            this._identity = Promise.resolve(options.identity || new _auth__WEBPACK_IMPORTED_MODULE_1__.AnonymousIdentity());
        }
        addTransform(fn, priority = fn.priority || 0) {
            // Keep the pipeline sorted at all time, by priority.
            const i = this._pipeline.findIndex(x => (x.priority || 0) < priority);
            this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));
        }
        async getPrincipal() {
            return (await this._identity).getPrincipal();
        }
        async call(canisterId, options, identity) {
            const id = (await (identity !== undefined ? await identity : await this._identity));
            const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.from(canisterId);
            const ecid = options.effectiveCanisterId
                ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.from(options.effectiveCanisterId)
                : canister;
            const sender = id.getPrincipal() || _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.anonymous();
            const submit = {
                request_type: _types__WEBPACK_IMPORTED_MODULE_7__.SubmitRequestType.Call,
                canister_id: canister,
                method_name: options.methodName,
                arg: options.arg,
                sender: sender,
                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let transformedRequest = (await this._transform({
                request: {
                    body: null,
                    method: 'POST',
                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                },
                endpoint: "call" /* Call */,
                body: submit,
            }));
            // Apply transform for identity.
            transformedRequest = await id.transformRequest(transformedRequest);
            const body = _cbor__WEBPACK_IMPORTED_MODULE_2__.encode(transformedRequest.body);
            // Run both in parallel. The fetch is quite expensive, so we have plenty of time to
            // calculate the requestId locally.
            const [response, requestId] = await Promise.all([
                this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })),
                (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(submit),
            ]);
            if (!response.ok) {
                throw new Error(`Server returned an error:\n` +
                    `  Code: ${response.status} (${response.statusText})\n` +
                    `  Body: ${await response.text()}\n`);
            }
            return {
                requestId,
                response: {
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                },
            };
        }
        async query(canisterId, fields, identity) {
            const id = await (identity !== undefined ? await identity : await this._identity);
            const canister = typeof canisterId === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.fromText(canisterId) : canisterId;
            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.anonymous();
            const request = {
                request_type: "query" /* Query */,
                canister_id: canister,
                method_name: fields.methodName,
                arg: fields.arg,
                sender: sender,
                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
            };
            // TODO: remove this any. This can be a Signed or UnSigned request.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let transformedRequest = await this._transform({
                request: {
                    method: 'POST',
                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                },
                endpoint: "read" /* Query */,
                body: request,
            });
            // Apply transform for identity.
            transformedRequest = await id.transformRequest(transformedRequest);
            const body = _cbor__WEBPACK_IMPORTED_MODULE_2__.encode(transformedRequest.body);
            const response = await this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
            if (!response.ok) {
                throw new Error(`Server returned an error:\n` +
                    `  Code: ${response.status} (${response.statusText})\n` +
                    `  Body: ${await response.text()}\n`);
            }
            return _cbor__WEBPACK_IMPORTED_MODULE_2__.decode(buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(await response.arrayBuffer()));
        }
        async readState(canisterId, fields, identity) {
            const canister = typeof canisterId === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.fromText(canisterId) : canisterId;
            const id = await (identity !== undefined ? await identity : await this._identity);
            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.anonymous();
            // TODO: remove this any. This can be a Signed or UnSigned request.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let transformedRequest = await this._transform({
                request: {
                    method: 'POST',
                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                },
                endpoint: "read_state" /* ReadState */,
                body: {
                    request_type: "read_state" /* ReadState */,
                    paths: fields.paths,
                    sender: sender,
                    ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
                },
            });
            // Apply transform for identity.
            transformedRequest = await id.transformRequest(transformedRequest);
            const body = _cbor__WEBPACK_IMPORTED_MODULE_2__.encode(transformedRequest.body);
            const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
            if (!response.ok) {
                throw new Error(`Server returned an error:\n` +
                    `  Code: ${response.status} (${response.statusText})\n` +
                    `  Body: ${await response.text()}\n`);
            }
            return _cbor__WEBPACK_IMPORTED_MODULE_2__.decode(buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(await response.arrayBuffer()));
        }
        async status() {
            const headers = this._credentials
                ? {
                    Authorization: 'Basic ' + btoa(this._credentials),
                }
                : {};
            const response = await this._fetch('' + new URL(`/api/v2/status`, this._host), { headers });
            if (!response.ok) {
                throw new Error(`Server returned an error:\n` +
                    `  Code: ${response.status} (${response.statusText})\n` +
                    `  Body: ${await response.text()}\n`);
            }
            const buffer = await response.arrayBuffer();
            return _cbor__WEBPACK_IMPORTED_MODULE_2__.decode(new Uint8Array(buffer));
        }
        async fetchRootKey() {
            if (!this._rootKeyFetched) {
                // Hex-encoded version of the replica root key
                this.rootKey = (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobFromUint8Array)((await this.status()).root_key);
                this._rootKeyFetched = true;
            }
            return this.rootKey;
        }
        _transform(request) {
            let p = Promise.resolve(request);
            for (const fn of this._pipeline) {
                p = p.then(r => fn(r).then(r2 => r2 || r));
            }
            return p;
        }
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js":
    /*!*******************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js ***!
      \*******************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Expiry: () => (/* binding */ Expiry),
    /* harmony export */   makeExpiryTransform: () => (/* binding */ makeExpiryTransform),
    /* harmony export */   makeNonceTransform: () => (/* binding */ makeNonceTransform)
    /* harmony export */ });
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simple-cbor */ "./node_modules/simple-cbor/src/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    
    
    const NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);
    const REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);
    class Expiry {
        constructor(deltaInMSec) {
            // Use bigint because it can overflow the maximum number allowed in a double float.
            this._value =
                (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) *
                    NANOSECONDS_PER_MILLISECONDS;
        }
        toCBOR() {
            // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).
            return simple_cbor__WEBPACK_IMPORTED_MODULE_0__.value.u64(this._value.toString(16), 16);
        }
        toHash() {
            return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.lebEncode)(this._value);
        }
    }
    /**
     * Create a Nonce transform, which takes a function that returns a Buffer, and adds it
     * as the nonce to every call requests.
     * @param nonceFn A function that returns a buffer. By default uses a semi-random method.
     */
    function makeNonceTransform(nonceFn = _dfinity_candid__WEBPACK_IMPORTED_MODULE_1__.makeNonce) {
        return async (request) => {
            // Nonce are only useful for async calls, to prevent replay attacks. Other types of
            // calls don't need Nonce so we just skip creating one.
            if (request.endpoint === "call" /* Call */) {
                request.body.nonce = nonceFn();
            }
        };
    }
    /**
     * Create a transform that adds a delay (by default 5 minutes) to the expiry.
     *
     * @param delayInMilliseconds The delay to add to the call time, in milliseconds.
     */
    function makeExpiryTransform(delayInMilliseconds) {
        return async (request) => {
            request.body.ingress_expiry = new Expiry(delayInMilliseconds);
        };
    }
    //# sourceMappingURL=transforms.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js ***!
      \**************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   SubmitRequestType: () => (/* binding */ SubmitRequestType)
    /* harmony export */ });
    // tslint:enable:camel-case
    // The types of values allowed in the `request_type` field for submit requests.
    var SubmitRequestType;
    (function (SubmitRequestType) {
        SubmitRequestType["Call"] = "call";
    })(SubmitRequestType || (SubmitRequestType = {}));
    //# sourceMappingURL=types.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/index.js":
    /*!*********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/index.js ***!
      \*********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Expiry: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.Expiry),
    /* harmony export */   HttpAgent: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.HttpAgent),
    /* harmony export */   ProxyAgent: () => (/* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyAgent),
    /* harmony export */   ProxyMessageKind: () => (/* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyMessageKind),
    /* harmony export */   ProxyStubAgent: () => (/* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyStubAgent),
    /* harmony export */   ReplicaRejectCode: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.ReplicaRejectCode),
    /* harmony export */   RequestStatusResponseStatus: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus),
    /* harmony export */   getDefaultAgent: () => (/* binding */ getDefaultAgent),
    /* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform),
    /* harmony export */   makeNonceTransform: () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform)
    /* harmony export */ });
    /* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/api.js");
    /* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/index.js");
    /* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proxy */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/proxy.js");
    
    
    
    function getDefaultAgent() {
        const agent = typeof window === 'undefined'
            ? typeof __webpack_require__.g === 'undefined'
                ? typeof self === 'undefined'
                    ? undefined
                    : self.ic.agent
                : __webpack_require__.g.ic.agent
            : window.ic.agent;
        if (!agent) {
            throw new Error('No Agent could be found.');
        }
        return agent;
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/proxy.js":
    /*!*********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/proxy.js ***!
      \*********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ProxyAgent: () => (/* binding */ ProxyAgent),
    /* harmony export */   ProxyMessageKind: () => (/* binding */ ProxyMessageKind),
    /* harmony export */   ProxyStubAgent: () => (/* binding */ ProxyStubAgent)
    /* harmony export */ });
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    
    var ProxyMessageKind;
    (function (ProxyMessageKind) {
        ProxyMessageKind["Error"] = "err";
        ProxyMessageKind["GetPrincipal"] = "gp";
        ProxyMessageKind["GetPrincipalResponse"] = "gpr";
        ProxyMessageKind["Query"] = "q";
        ProxyMessageKind["QueryResponse"] = "qr";
        ProxyMessageKind["Call"] = "c";
        ProxyMessageKind["CallResponse"] = "cr";
        ProxyMessageKind["ReadState"] = "rs";
        ProxyMessageKind["ReadStateResponse"] = "rsr";
        ProxyMessageKind["Status"] = "s";
        ProxyMessageKind["StatusResponse"] = "sr";
    })(ProxyMessageKind || (ProxyMessageKind = {}));
    // A Stub Agent that forwards calls to another Agent implementation.
    class ProxyStubAgent {
        constructor(_frontend, _agent) {
            this._frontend = _frontend;
            this._agent = _agent;
        }
        onmessage(msg) {
            switch (msg.type) {
                case ProxyMessageKind.GetPrincipal:
                    this._agent.getPrincipal().then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.GetPrincipalResponse,
                            response: response.toText(),
                        });
                    });
                    break;
                case ProxyMessageKind.Query:
                    this._agent.query(...msg.args).then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.QueryResponse,
                            response,
                        });
                    });
                    break;
                case ProxyMessageKind.Call:
                    this._agent.call(...msg.args).then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.CallResponse,
                            response,
                        });
                    });
                    break;
                case ProxyMessageKind.ReadState:
                    this._agent.readState(...msg.args).then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.ReadStateResponse,
                            response,
                        });
                    });
                    break;
                case ProxyMessageKind.Status:
                    this._agent.status().then(response => {
                        this._frontend({
                            id: msg.id,
                            type: ProxyMessageKind.StatusResponse,
                            response,
                        });
                    });
                    break;
                default:
                    throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
            }
        }
    }
    // An Agent that forwards calls to a backend. The calls are serialized
    class ProxyAgent {
        constructor(_backend) {
            this._backend = _backend;
            this._nextId = 0;
            this._pendingCalls = new Map();
            this.rootKey = null;
        }
        onmessage(msg) {
            const id = msg.id;
            const maybePromise = this._pendingCalls.get(id);
            if (!maybePromise) {
                throw new Error('A proxy get the same message twice...');
            }
            this._pendingCalls.delete(id);
            const [resolve, reject] = maybePromise;
            switch (msg.type) {
                case ProxyMessageKind.Error:
                    return reject(msg.error);
                case ProxyMessageKind.GetPrincipalResponse:
                case ProxyMessageKind.CallResponse:
                case ProxyMessageKind.QueryResponse:
                case ProxyMessageKind.ReadStateResponse:
                case ProxyMessageKind.StatusResponse:
                    return resolve(msg.response);
                default:
                    throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
            }
        }
        async getPrincipal() {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.GetPrincipal,
            }).then(principal => {
                if (typeof principal !== 'string') {
                    throw new Error('Invalid principal received.');
                }
                return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(principal);
            });
        }
        readState(canisterId, fields) {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.ReadState,
                args: [canisterId.toString(), fields],
            });
        }
        call(canisterId, fields) {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.Call,
                args: [canisterId.toString(), fields],
            });
        }
        status() {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.Status,
            });
        }
        query(canisterId, fields) {
            return this._sendAndWait({
                id: this._nextId++,
                type: ProxyMessageKind.Query,
                args: [canisterId.toString(), fields],
            });
        }
        async _sendAndWait(msg) {
            return new Promise((resolve, reject) => {
                this._pendingCalls.set(msg.id, [resolve, reject]);
                this._backend(msg);
            });
        }
        async fetchRootKey() {
            // Hex-encoded version of the replica root key
            const rootKey = (await this.status()).root_key;
            this.rootKey = rootKey;
            return rootKey;
        }
    }
    //# sourceMappingURL=proxy.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/auth.js":
    /*!**************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/auth.js ***!
      \**************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   AnonymousIdentity: () => (/* binding */ AnonymousIdentity),
    /* harmony export */   SignIdentity: () => (/* binding */ SignIdentity),
    /* harmony export */   createIdentityDescriptor: () => (/* binding */ createIdentityDescriptor),
    /* harmony export */   isIdentityDescriptor: () => (/* binding */ isIdentityDescriptor)
    /* harmony export */ });
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request_id */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    
    
    
    
    const domainSeparator = buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(new TextEncoder().encode('\x0Aic-request'));
    /**
     * An Identity that can sign blobs.
     */
    class SignIdentity {
        /**
         * Get the principal represented by this identity. Normally should be a
         * `Principal.selfAuthenticating()`.
         */
        getPrincipal() {
            if (!this._principal) {
                this._principal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.selfAuthenticating(this.getPublicKey().toDer());
            }
            return this._principal;
        }
        /**
         * Transform a request into a signed version of the request. This is done last
         * after the transforms on the body of a request. The returned object can be
         * anything, but must be serializable to CBOR.
         * @param request - internet computer request to transform
         */
        async transformRequest(request) {
            const { body } = request, fields = __rest(request, ["body"]);
            const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.requestIdOf)(body);
            return Object.assign(Object.assign({}, fields), { body: {
                    content: body,
                    sender_pubkey: this.getPublicKey().toDer(),
                    sender_sig: await this.sign((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromBuffer)(buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([domainSeparator, requestId]))),
                } });
        }
    }
    class AnonymousIdentity {
        getPrincipal() {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.anonymous();
        }
        async transformRequest(request) {
            return Object.assign(Object.assign({}, request), { body: { content: request.body } });
        }
    }
    /**
     * Create an IdentityDescriptor from a @dfinity/authentication Identity
     * @param identity - identity describe in returned descriptor
     */
    function createIdentityDescriptor(identity) {
        const identityIndicator = 'getPublicKey' in identity
            ? { type: 'PublicKeyIdentity', publicKey: identity.getPublicKey().toDer().toString('hex') }
            : { type: 'AnonymousIdentity' };
        return identityIndicator;
    }
    /**
     * Type Guard for whether the unknown value is an IdentityDescriptor or not.
     * @param value - value to type guard
     */
    function isIdentityDescriptor(value) {
        var _a, _b;
        switch ((_a = value) === null || _a === void 0 ? void 0 : _a.type) {
            case 'AnonymousIdentity':
                return true;
            case 'PublicKeyIdentity':
                if (typeof ((_b = value) === null || _b === void 0 ? void 0 : _b.publicKey) !== 'string') {
                    return false;
                }
                return true;
        }
        return false;
    }
    //# sourceMappingURL=auth.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/asset.js":
    /*!*************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/asset.js ***!
      \*************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   createAssetCanisterActor: () => (/* binding */ createAssetCanisterActor)
    /* harmony export */ });
    /* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actor */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/actor.js");
    /* harmony import */ var _asset_idl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset_idl */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js");
    
    
    /* tslint:enable */
    /**
     * Create a management canister actor.
     * @param config
     */
    function createAssetCanisterActor(config) {
        return _actor__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_asset_idl__WEBPACK_IMPORTED_MODULE_1__["default"], config);
    }
    //# sourceMappingURL=asset.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js":
    /*!*****************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js ***!
      \*****************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /**
     * This file is generated from the candid for asset management.
     */
    /* tslint:disable */
    // @ts-ignore
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (({ IDL }) => {
        return IDL.Service({
            retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ['query']),
            store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], []),
        });
    });
    //# sourceMappingURL=asset_idl.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management.js":
    /*!******************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management.js ***!
      \******************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   getManagementCanister: () => (/* binding */ getManagementCanister)
    /* harmony export */ });
    /* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actor */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/actor.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _management_idl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./management_idl */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js");
    
    
    
    /* tslint:enable */
    /**
     * Create a management canister actor.
     * @param config
     */
    function getManagementCanister(config) {
        function transform(methodName, args, callConfig) {
            const first = args[0];
            let effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromHex('');
            if (first && typeof first === 'object' && first.canister_id) {
                effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.from(first.canister_id);
            }
            return { effectiveCanisterId };
        }
        return _actor__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_management_idl__WEBPACK_IMPORTED_MODULE_2__["default"], Object.assign(Object.assign(Object.assign({}, config), { canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromHex('') }), {
            callTransform: transform,
            queryTransform: transform,
        }));
    }
    //# sourceMappingURL=management.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js":
    /*!**********************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js ***!
      \**********************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /**
     * This file is generated from the candid for asset management.
     */
    /* tslint:disable */
    // @ts-ignore
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (({ IDL }) => {
        const canister_id = IDL.Principal;
        const wasm_module = IDL.Vec(IDL.Nat8);
        const CanisterSettings = IDL.Record({
            compute_allocation: IDL.Opt(IDL.Nat),
            memory_allocation: IDL.Opt(IDL.Nat),
        });
        return IDL.Service({
            provisional_create_canister_with_cycles: IDL.Func([IDL.Record({ amount: IDL.Opt(IDL.Nat), settings: IDL.Opt(CanisterSettings) })], [IDL.Record({ canister_id: canister_id })], []),
            create_canister: IDL.Func([], [IDL.Record({ canister_id: canister_id })], []),
            install_code: IDL.Func([
                IDL.Record({
                    mode: IDL.Variant({ install: IDL.Null, reinstall: IDL.Null, upgrade: IDL.Null }),
                    canister_id: canister_id,
                    wasm_module: wasm_module,
                    arg: IDL.Vec(IDL.Nat8),
                }),
            ], [], []),
            set_controller: IDL.Func([IDL.Record({ canister_id: canister_id, new_controller: IDL.Principal })], [], []),
        });
    });
    //# sourceMappingURL=management_idl.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/cbor.js":
    /*!**************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/cbor.js ***!
      \**************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   CborTag: () => (/* binding */ CborTag),
    /* harmony export */   decode: () => (/* binding */ decode),
    /* harmony export */   encode: () => (/* binding */ encode)
    /* harmony export */ });
    /* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! borc */ "./node_modules/borc/src/index.js");
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! simple-cbor */ "./node_modules/simple-cbor/src/index.js");
    /* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    // tslint:disable:max-classes-per-file
    // This file is based on:
    // tslint:disable-next-line: max-line-length
    // https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses
    
    
    
    
    
    // We are using hansl/simple-cbor for CBOR serialization, to avoid issues with
    // encoding the uint64 values that the HTTP handler of the client expects for
    // canister IDs. However, simple-cbor does not yet provide deserialization so
    // we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR
    // decoder.
    class PrincipalEncoder {
        get name() {
            return 'Principal';
        }
        get priority() {
            return 0;
        }
        match(value) {
            return value && value._isPrincipal === true;
        }
        encode(v) {
            return simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.bytes(v.toUint8Array().buffer);
        }
    }
    class BufferEncoder {
        get name() {
            return 'Buffer';
        }
        get priority() {
            return 1;
        }
        match(value) {
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.isBuffer(value);
        }
        encode(v) {
            return simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.bytes(new Uint8Array(v));
        }
    }
    class BigIntEncoder {
        get name() {
            return 'BigInt';
        }
        get priority() {
            return 1;
        }
        match(value) {
            return typeof value === `bigint`;
        }
        encode(v) {
            // Always use a bigint encoding.
            if (v > BigInt(0)) {
                return simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.tagged(2, simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.bytes((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromHex)(v.toString(16))));
            }
            else {
                return simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.tagged(3, simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.bytes((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromHex)((BigInt('-1') * v).toString(16))));
            }
        }
    }
    const serializer = simple_cbor__WEBPACK_IMPORTED_MODULE_2__.SelfDescribeCborSerializer.withDefaultEncoders(true);
    serializer.addEncoder(new PrincipalEncoder());
    serializer.addEncoder(new BufferEncoder());
    serializer.addEncoder(new BigIntEncoder());
    var CborTag;
    (function (CborTag) {
        CborTag[CborTag["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
        CborTag[CborTag["Semantic"] = 55799] = "Semantic";
    })(CborTag || (CborTag = {}));
    const encode = (value) => {
        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromBuffer)(buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(serializer.serialize(value)));
    };
    function decodePositiveBigInt(buf) {
        const len = buf.byteLength;
        let res = BigInt(0);
        for (let i = 0; i < len; i++) {
            // tslint:disable-next-line:no-bitwise
            res = res * BigInt(0x100) + BigInt(buf[i]);
        }
        return res;
    }
    function decode(input) {
        const decoder = new borc__WEBPACK_IMPORTED_MODULE_0__.Decoder({
            size: input.byteLength,
            tags: {
                // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).
                2: val => decodePositiveBigInt(val),
                3: val => -decodePositiveBigInt(val),
                [CborTag.Semantic]: (value) => value,
            },
        });
        const result = decoder.decodeFirst(input);
        return result;
    }
    //# sourceMappingURL=cbor.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/certificate.js":
    /*!*********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/certificate.js ***!
      \*********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Certificate: () => (/* binding */ Certificate),
    /* harmony export */   UnverifiedCertificateError: () => (/* binding */ UnverifiedCertificateError),
    /* harmony export */   hashTreeToString: () => (/* binding */ hashTreeToString),
    /* harmony export */   lookupPathEx: () => (/* binding */ lookupPathEx),
    /* harmony export */   lookup_path: () => (/* binding */ lookup_path),
    /* harmony export */   reconstruct: () => (/* binding */ reconstruct)
    /* harmony export */ });
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cbor */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/cbor.js");
    /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/errors.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./request_id */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/bls */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js");
    
    
    
    
    
    
    
    /**
     * A certificate needs to be verified (using {@link Certificate.prototype.verify})
     * before it can be used.
     */
    class UnverifiedCertificateError extends _errors__WEBPACK_IMPORTED_MODULE_3__.AgentError {
        constructor() {
            super(`Cannot lookup unverified certificate. Call 'verify()' first.`);
        }
    }
    /**
     * Make a human readable string out of a hash tree.
     * @param tree
     */
    function hashTreeToString(tree) {
        const indent = (s) => s
            .split('\n')
            .map(x => '  ' + x)
            .join('\n');
        function labelToString(label) {
            const decoder = new TextDecoder(undefined, { fatal: true });
            try {
                return JSON.stringify(decoder.decode(label));
            }
            catch (e) {
                return `data(...${label.byteLength} bytes)`;
            }
        }
        switch (tree[0]) {
            case 0:
                return '()';
            case 1: {
                const left = hashTreeToString(tree[1]);
                const right = hashTreeToString(tree[2]);
                return `sub(\n left:\n${indent(left)}\n---\n right:\n${indent(right)}\n)`;
            }
            case 2: {
                const label = labelToString(tree[1]);
                const sub = hashTreeToString(tree[2]);
                return `label(\n label:\n${indent(label)}\n sub:\n${indent(sub)}\n)`;
            }
            case 3: {
                return `leaf(...${tree[1].byteLength} bytes)`;
            }
            case 4: {
                return `pruned(${(0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobToHex)((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobFromUint8Array)(new Uint8Array(tree[1])))}`;
            }
            default: {
                return `unknown(${JSON.stringify(tree[0])})`;
            }
        }
    }
    function isBufferEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    class Certificate {
        constructor(response, _agent = (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)()) {
            this._agent = _agent;
            this.verified = false;
            this._rootKey = null;
            this.cert = _cbor__WEBPACK_IMPORTED_MODULE_2__.decode(response.certificate);
        }
        lookupEx(path) {
            this.checkState();
            return lookupPathEx(path, this.cert.tree);
        }
        lookup(path) {
            this.checkState();
            return lookup_path(path, this.cert.tree);
        }
        async verify() {
            const rootHash = await reconstruct(this.cert.tree);
            const derKey = await this._checkDelegation(this.cert.delegation);
            const sig = this.cert.signature;
            const key = extractDER(derKey);
            const msg = buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([domain_sep('ic-state-root'), rootHash]);
            const res = await (0,_utils_bls__WEBPACK_IMPORTED_MODULE_6__.blsVerify)(key, sig, msg);
            this.verified = res;
            return res;
        }
        checkState() {
            if (!this.verified) {
                throw new UnverifiedCertificateError();
            }
        }
        async _checkDelegation(d) {
            if (!d) {
                if (!this._rootKey) {
                    if (this._agent.rootKey) {
                        this._rootKey = this._agent.rootKey;
                        return this._rootKey;
                    }
                    throw new Error(`Agent does not have a rootKey. Do you need to call 'fetchRootKey'?`);
                }
                return this._rootKey;
            }
            const cert = new Certificate(d, this._agent);
            if (!(await cert.verify())) {
                throw new Error('fail to verify delegation certificate');
            }
            const lookup = cert.lookupEx(['subnet', d.subnet_id, 'public_key']);
            if (!lookup) {
                throw new Error(`Could not find subnet key for subnet 0x${d.subnet_id.toString('hex')}`);
            }
            return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(lookup);
        }
    }
    const DER_PREFIX = buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100', 'hex');
    const KEY_LENGTH = 96;
    function extractDER(buf) {
        const expectedLength = DER_PREFIX.length + KEY_LENGTH;
        if (buf.length !== expectedLength) {
            throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
        }
        const prefix = buf.slice(0, DER_PREFIX.length);
        if (!isBufferEqual(prefix, DER_PREFIX)) {
            throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);
        }
        return buf.slice(DER_PREFIX.length);
    }
    /**
     * @param t
     */
    async function reconstruct(t) {
        switch (t[0]) {
            case 0 /* Empty */:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hash)(domain_sep('ic-hashtree-empty'));
            case 4 /* Pruned */:
                return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(t[1]);
            case 3 /* Leaf */:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hash)(buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([
                    domain_sep('ic-hashtree-leaf'),
                    buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(t[1]),
                ]));
            case 2 /* Labeled */:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hash)(buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([
                    domain_sep('ic-hashtree-labeled'),
                    buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(t[1]),
                    buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(await reconstruct(t[2])),
                ]));
            case 1 /* Fork */:
                return (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hash)(buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([
                    domain_sep('ic-hashtree-fork'),
                    buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(await reconstruct(t[1])),
                    buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(await reconstruct(t[2])),
                ]));
            default:
                throw new Error('unreachable');
        }
    }
    function domain_sep(s) {
        const buf = buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(1);
        buf.writeUInt8(s.length, 0);
        return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buf, buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(s)]);
    }
    /**
     *
     * @param path
     * @param tree
     */
    function lookupPathEx(path, tree) {
        const maybeReturn = lookup_path(path.map(p => {
            if (typeof p === 'string') {
                return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobFromText)(p);
            }
            else {
                return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobFromUint8Array)(new Uint8Array(p));
            }
        }), tree);
        return maybeReturn && (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobToUint8Array)((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_5__.blobFromBuffer)(maybeReturn));
    }
    /**
     * @param path
     * @param tree
     */
    function lookup_path(path, tree) {
        if (path.length === 0) {
            switch (tree[0]) {
                case 3 /* Leaf */: {
                    return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(tree[1]);
                }
                default: {
                    return undefined;
                }
            }
        }
        const t = find_label(path[0], flatten_forks(tree));
        if (t) {
            return lookup_path(path.slice(1), t);
        }
    }
    function flatten_forks(t) {
        switch (t[0]) {
            case 0 /* Empty */:
                return [];
            case 1 /* Fork */:
                return flatten_forks(t[1]).concat(flatten_forks(t[2]));
            default:
                return [t];
        }
    }
    function find_label(l, trees) {
        if (trees.length === 0) {
            return undefined;
        }
        for (const t of trees) {
            if (t[0] === 2 /* Labeled */) {
                const p = buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(t[1]);
                if (isBufferEqual(l, p)) {
                    return t[2];
                }
            }
        }
    }
    //# sourceMappingURL=certificate.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/errors.js":
    /*!****************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/errors.js ***!
      \****************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   AgentError: () => (/* binding */ AgentError)
    /* harmony export */ });
    /**
     * An error that happens in the Agent. This is the root of all errors and should be used
     * everywhere in the Agent code (this package).
     *
     * @todo https://github.com/dfinity/agent-js/issues/420
     */
    class AgentError extends Error {
    }
    //# sourceMappingURL=errors.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js":
    /*!***************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js ***!
      \***************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Actor: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.Actor),
    /* harmony export */   ActorCallError: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ActorCallError),
    /* harmony export */   AnonymousIdentity: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_2__.AnonymousIdentity),
    /* harmony export */   CanisterInstallMode: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.CanisterInstallMode),
    /* harmony export */   Cbor: () => (/* reexport module object */ _cbor__WEBPACK_IMPORTED_MODULE_11__),
    /* harmony export */   Certificate: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.Certificate),
    /* harmony export */   Expiry: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.Expiry),
    /* harmony export */   HttpAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.HttpAgent),
    /* harmony export */   ProxyAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyAgent),
    /* harmony export */   ProxyMessageKind: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyMessageKind),
    /* harmony export */   ProxyStubAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyStubAgent),
    /* harmony export */   QueryCallRejectedError: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.QueryCallRejectedError),
    /* harmony export */   ReplicaRejectCode: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode),
    /* harmony export */   RequestStatusResponseStatus: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus),
    /* harmony export */   SignIdentity: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_2__.SignIdentity),
    /* harmony export */   SubmitRequestType: () => (/* reexport safe */ _agent_http_types__WEBPACK_IMPORTED_MODULE_5__.SubmitRequestType),
    /* harmony export */   UnverifiedCertificateError: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.UnverifiedCertificateError),
    /* harmony export */   UpdateCallRejectedError: () => (/* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.UpdateCallRejectedError),
    /* harmony export */   blsVerify: () => (/* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_9__.blsVerify),
    /* harmony export */   createAssetCanisterActor: () => (/* reexport safe */ _canisters_asset__WEBPACK_IMPORTED_MODULE_6__.createAssetCanisterActor),
    /* harmony export */   createIdentityDescriptor: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_2__.createIdentityDescriptor),
    /* harmony export */   getDefaultAgent: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent),
    /* harmony export */   getManagementCanister: () => (/* reexport safe */ _canisters_management__WEBPACK_IMPORTED_MODULE_7__.getManagementCanister),
    /* harmony export */   hash: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_8__.hash),
    /* harmony export */   hashTreeToString: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.hashTreeToString),
    /* harmony export */   isIdentityDescriptor: () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_2__.isIdentityDescriptor),
    /* harmony export */   lookupPathEx: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.lookupPathEx),
    /* harmony export */   lookup_path: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.lookup_path),
    /* harmony export */   makeExpiryTransform: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform),
    /* harmony export */   makeNonceTransform: () => (/* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform),
    /* harmony export */   polling: () => (/* reexport module object */ _polling__WEBPACK_IMPORTED_MODULE_10__),
    /* harmony export */   reconstruct: () => (/* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_3__.reconstruct),
    /* harmony export */   requestIdOf: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_8__.requestIdOf),
    /* harmony export */   toHex: () => (/* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_8__.toHex),
    /* harmony export */   verify: () => (/* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_9__.verify)
    /* harmony export */ });
    /* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/actor.js");
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./auth */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/auth.js");
    /* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./certificate */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/certificate.js");
    /* harmony import */ var _agent_http_transforms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./agent/http/transforms */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js");
    /* harmony import */ var _agent_http_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./agent/http/types */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/http/types.js");
    /* harmony import */ var _canisters_asset__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./canisters/asset */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/asset.js");
    /* harmony import */ var _canisters_management__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./canisters/management */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/canisters/management.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./request_id */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/bls */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js");
    /* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polling */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/index.js");
    /* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cbor */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/cbor.js");
    
    
    
    
    
    
    
    
    
    
    
    
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/index.js":
    /*!***********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/index.js ***!
      \***********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   defaultStrategy: () => (/* reexport safe */ _strategy__WEBPACK_IMPORTED_MODULE_4__.defaultStrategy),
    /* harmony export */   pollForResponse: () => (/* binding */ pollForResponse),
    /* harmony export */   strategy: () => (/* reexport module object */ _strategy__WEBPACK_IMPORTED_MODULE_4__)
    /* harmony export */ });
    /* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../agent */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/agent/index.js");
    /* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../certificate */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/certificate.js");
    /* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../request_id */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var _strategy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./strategy */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js");
    
    
    
    
    
    
    /**
     * Polls the IC to check the status of the given request then
     * returns the response bytes once the request has been processed.
     * @param agent The agent to use to poll read_state.
     * @param canisterId The effective canister ID.
     * @param requestId The Request ID to poll status for.
     * @param strategy A polling strategy.
     */
    async function pollForResponse(agent, canisterId, requestId, strategy) {
        const path = [(0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromText)('request_status'), requestId];
        const state = await agent.readState(canisterId, { paths: [path] });
        const cert = new _certificate__WEBPACK_IMPORTED_MODULE_1__.Certificate(state, agent);
        const verified = await cert.verify();
        if (!verified) {
            throw new Error('Fail to verify certificate');
        }
        const maybeBuf = cert.lookup([...path, (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromText)('status')]);
        let status;
        if (typeof maybeBuf === 'undefined') {
            // Missing requestId means we need to wait
            status = _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown;
        }
        else {
            status = maybeBuf.toString();
        }
        switch (status) {
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Replied: {
                return cert.lookup([...path, (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromText)('reply')]);
            }
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Received:
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown:
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Processing:
                // Execute the polling strategy, then retry.
                await strategy(canisterId, requestId, status);
                return pollForResponse(agent, canisterId, requestId, strategy);
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Rejected: {
                const rejectCode = cert.lookup([...path, (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromText)('reject_code')]).toString();
                const rejectMessage = cert.lookup([...path, (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromText)('reject_message')]).toString();
                throw new Error(`Call was rejected:\n` +
                    `  Request ID: ${(0,_request_id__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\n` +
                    `  Reject code: ${rejectCode}\n` +
                    `  Reject text: ${rejectMessage}\n`);
            }
            case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Done:
                // This is _technically_ not an error, but we still didn't see the `Replied` status so
                // we don't know the result and cannot decode it.
                throw new Error(`Call was marked as done but we never saw the reply:\n` +
                    `  Request ID: ${(0,_request_id__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\n`);
        }
        throw new Error('unreachable');
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/polling/strategy.js ***!
      \**************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   backoff: () => (/* binding */ backoff),
    /* harmony export */   chain: () => (/* binding */ chain),
    /* harmony export */   conditionalDelay: () => (/* binding */ conditionalDelay),
    /* harmony export */   defaultStrategy: () => (/* binding */ defaultStrategy),
    /* harmony export */   maxAttempts: () => (/* binding */ maxAttempts),
    /* harmony export */   once: () => (/* binding */ once),
    /* harmony export */   throttle: () => (/* binding */ throttle),
    /* harmony export */   timeout: () => (/* binding */ timeout)
    /* harmony export */ });
    /* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/index.js");
    
    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;
    /**
     * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second
     * with an exponential backoff factor of 1.2. Timeout after 5 minutes.
     */
    function defaultStrategy() {
        return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
    }
    /**
     * Predicate that returns true once.
     */
    function once() {
        let first = true;
        return async () => {
            if (first) {
                first = false;
                return true;
            }
            return false;
        };
    }
    /**
     * Delay the polling once.
     * @param condition A predicate that indicates when to delay.
     * @param timeInMsec The amount of time to delay.
     */
    function conditionalDelay(condition, timeInMsec) {
        return async (canisterId, requestId, status) => {
            if (await condition(canisterId, requestId, status)) {
                return new Promise(resolve => setTimeout(resolve, timeInMsec));
            }
        };
    }
    /**
     * Error out after a maximum number of polling has been done.
     * @param count The maximum attempts to poll.
     */
    function maxAttempts(count) {
        let attempts = count;
        return async (canisterId, requestId, status) => {
            if (--attempts <= 0) {
                throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` +
                    `  Request ID: ${(0,___WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\n` +
                    `  Request status: ${status}\n`);
            }
        };
    }
    /**
     * Throttle polling.
     * @param throttleInMsec Amount in millisecond to wait between each polling.
     */
    function throttle(throttleInMsec) {
        return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));
    }
    /**
     * Reject a call after a certain amount of time.
     * @param timeInMsec Time in milliseconds before the polling should be rejected.
     */
    function timeout(timeInMsec) {
        const end = Date.now() + timeInMsec;
        return async (canisterId, requestId, status) => {
            if (Date.now() > end) {
                throw new Error(`Request timed out after ${timeInMsec} msec:\n` +
                    `  Request ID: ${(0,___WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\n` +
                    `  Request status: ${status}\n`);
            }
        };
    }
    /**
     * A strategy that throttle, but using an exponential backoff strategy.
     * @param startingThrottleInMsec The throttle in milliseconds to start with.
     * @param backoffFactor The factor to multiple the throttle time between every poll. For
     *   example if using 2, the throttle will double between every run.
     */
    function backoff(startingThrottleInMsec, backoffFactor) {
        let currentThrottling = startingThrottleInMsec;
        return () => new Promise(resolve => setTimeout(() => {
            currentThrottling *= backoffFactor;
            resolve();
        }, currentThrottling));
    }
    /**
     * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,
     * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.
     * @param strategies A strategy list to chain.
     */
    function chain(...strategies) {
        return async (canisterId, requestId, status) => {
            for (const a of strategies) {
                await a(canisterId, requestId, status);
            }
        };
    }
    //# sourceMappingURL=strategy.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js":
    /*!********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/request_id.js ***!
      \********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   hash: () => (/* binding */ hash),
    /* harmony export */   requestIdOf: () => (/* binding */ requestIdOf),
    /* harmony export */   toHex: () => (/* binding */ toHex)
    /* harmony export */ });
    /* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha256 */ "./node_modules/js-sha256/src/sha256.js");
    /* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha256__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borc */ "./node_modules/borc/src/index.js");
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    
    
    
    
    
    /**
     * get RequestId as hex-encoded blob.
     * @param requestId - RequestId to hex
     */
    function toHex(requestId) {
        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobToHex)(requestId);
    }
    /**
     * sha256 hash the provided Buffer
     * @param data - input to hash function
     */
    function hash(data) {
        const hashed = js_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256.create().update(data).arrayBuffer();
        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromUint8Array)(new Uint8Array(hashed));
    }
    function hashValue(value) {
        if (value instanceof borc__WEBPACK_IMPORTED_MODULE_1__.Tagged) {
            return hashValue(value.value);
        }
        else if (typeof value === 'string') {
            return hashString(value);
        }
        else if (typeof value === 'number') {
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(value));
        }
        else if (buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(value)) {
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromUint8Array)(new Uint8Array(value)));
        }
        else if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromUint8Array)(new Uint8Array(value)));
        }
        else if (Array.isArray(value)) {
            const vals = value.map(hashValue);
            return hash(buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.concat(vals));
        }
        else if (value instanceof _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal) {
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromUint8Array)(value.toUint8Array()));
        }
        else if (typeof value === 'object' &&
            value !== null &&
            typeof value.toHash === 'function') {
            return hashValue(value.toHash());
            // TODO This should be move to a specific async method as the webauthn flow required
            // the flow to be synchronous to ensure Safari touch id works.
            // } else if (value instanceof Promise) {
            //   return value.then(x => hashValue(x));
        }
        else if (typeof value === 'bigint') {
            // Do this check much later than the other bigint check because this one is much less
            // type-safe.
            // So we want to try all the high-assurance type guards before this 'probable' one.
            return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(value));
        }
        throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {
            // include so logs/callers can understand the confusing value.
            // (when stringified in error message, prototype info is lost)
            value,
        });
    }
    const hashString = (value) => {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(value);
        return hash(buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.from(encoded));
    };
    /**
     * Concatenate many blobs.
     * @param bs - blobs to concatenate
     */
    function concat(bs) {
        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.blobFromBuffer)(buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.concat(bs));
    }
    /**
     * Get the RequestId of the provided ic-ref request.
     * RequestId is the result of the representation-independent-hash function.
     * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map
     * @param request - ic-ref request to hash into RequestId
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function requestIdOf(request) {
        const hashed = Object.entries(request)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => {
            const hashedKey = hashString(key);
            const hashedValue = hashValue(value);
            return [hashedKey, hashedValue];
        });
        const traversed = hashed;
        const sorted = traversed.sort(([k1], [k2]) => {
            return buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.compare(buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.from(k1), buffer___WEBPACK_IMPORTED_MODULE_2__.Buffer.from(k2));
        });
        const concatenated = concat(sorted.map(concat));
        const requestId = hash(concatenated);
        return requestId;
    }
    //# sourceMappingURL=request_id.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js":
    /*!*******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/utils/bls.js ***!
      \*******************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   blsVerify: () => (/* binding */ blsVerify),
    /* harmony export */   verify: () => (/* binding */ verify)
    /* harmony export */ });
    /* harmony import */ var _vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/bls/bls */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js");
    
    let verify;
    /**
     *
     * @param pk primary key: Uint8Array
     * @param sig signature: Uint8Array
     * @param msg message: Uint8Array
     * @returns Promise resolving a boolean
     */
    async function blsVerify(pk, sig, msg) {
        if (!verify) {
            await (0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__["default"])();
            if ((0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__.bls_init)() !== 0) {
                throw new Error('Cannot initialize BLS');
            }
            verify = (pk1, sig1, msg1) => {
                // Reorder things from what the WASM expects (sig, m, w).
                return (0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__.bls_verify)(sig1, msg1, pk1) === 0;
            };
        }
        return verify(pk, sig, msg);
    }
    //# sourceMappingURL=bls.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js":
    /*!************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js ***!
      \************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   bls_init: () => (/* binding */ bls_init),
    /* harmony export */   bls_verify: () => (/* binding */ bls_verify),
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
    
    /* tslint:disable */
    /* eslint-disable */
    let wasm;
    // This WASM is generated from the BLS Rust code of the Agent RS (see
    // http://github.com/dfinity/agent-rs/)
    // Once the WASM is compiled, simply base64 encode it and include it in this string.
    const wasmBytesBase64 = `
        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
        ASAGQYg9aiAGQZgjaiACQcABbGoQfwNAIAdBf0YEQCAGQYg9aiAGQcjEAGoQcyAGQZgjaiAGQYg9akHAARBnGgwICyAH
        QeYASw0DIAZBiMAAaiAGQZgjaiAGQbgVaiAHaiwAABAfIAdBf2ohByAGQYg9ahAYIAZBiD1qEBggBkGIPWoQGCAGQYg9
        ahAYIAZBiD1qIAZBiMAAahAMDAALAAtB5wBB5wBBoITAABA8AAsgAkEIQcCEwAAQPAALIAdB5wBB0ITAABA8AAUgBkHI
        xABqIAZBmCNqIAdqIgIQfyACQcABaiICIAZByMQAahB/IAIgBkGIwABqEAwgB0HAAWohBwwBCwALAAsgBkGYI2oQSwsgB
        kEoaiAGQZgjahB/IAZBKGoQRyAMEAlBACEHIAZBqAZqQTAQchogBkGwDGpBoKfAABBfAkACQAJAAkACQANAAkAgB0EwRg
        RAIAYgBi0AqAZBH3E6AKgGIAZByM8AaiAGQagGahBdIAENAUEAQQBB8ILAABA8AAsgASAHRg0CIAZBqAZqIAdqIAAgB2o
        tAAA6AAAgB0EBaiEHDAELC0EAIQcCQCAALAAAIgJBAE4EQCAAQTBqIQAgAUEwIAFBMEsbQVBqIQIDQCAHQTBGBEAgBkHY
        2wBqIAZBqAZqEF0gBkHoAWoQSyAGQegBaiAGQcjPAGoQtAEgBkGoAmoiACAGQdjbAGoQtAEgBkHoAmoQaSAGQegBahBEI
        AZBuBVqIAZB6AFqEE0gBkGYI2ogABCFASAGQZgjahADIAZBmCNqIAZBuBVqEFkNAyAGQegBahCUAQwDCyACIAdGDQQgBk
        GoBmogB2ogACAHai0AADoAACAHQQFqIQcMAAsACyAGQZgjahBLIAZB0NUAakE4EHIaIAZBATYCiFYgBkGYI2ogBkHIzwB
        qELQBIAZBmCNqEEQgBkGYJGoQaSAGQdjbAGogBkGYI2oQTQJAIAZB2NsAaiAGQdDVAGoQXEEBRwRAIAZBmCNqEJQBDAEL
        IAZBuBVqIAZB2NsAaiAGQdDVAGoQIyAGQbgVahBYBEAgBkG4FWoQQSAGQbgVahBECyAGQdgjaiAGQbgVahClAQsgAkEgc
        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
        gBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQLIANBCGoLtA8BA38jAEGAC2siAiQAIAJBCGoQSyACQcgBakE4EHIaIAJBAT
        YCgAIgAkGIAmpBOBByGiACQQE2AsACIAJByAJqQTgQchogAkEBNgKAAyACQYgDakE4EHIaIAJBATYCwAMgAkHIA2pBOBB
        yGiACQQE2AoAEIAJBiARqQQEQigEgAkHIBGpBOBByGiACQQE2AoAFIAJBiAVqQTgQchogAkEBNgLABSACQcgFaiABEIUB
        IAJBiAZqQTgQchogAkEBNgLABiACQcgGakE4EHIaIAJBATYCgAcgAkGIB2pBOBByGiACQQE2AsAHIAJByAdqQTgQchogA
        kEBNgKACCACQcgFahBYIQMgAkHICWpB4ITAABBfIAJBiApqIAJByAlqEIsBIAJByAFqIAJBiApqEKUBIAJByAlqQZiFwA
        AQXyACQYgKaiACQcgJahCLASACQYgCaiACQYgKahClASACQcgFahADIAJByAVqQQsQUiACQYgGaiACQcgFahClASACQYg
        GaiACQYgEahB4IAJBiAZqEEQgAkGIBmogAkHIBWoQSCACQYgFaiACQcgBahClASACQYgFaiACQYgGahBIIAJBiAZqIAJB
        iARqEHggAkGIBmoQRCACQYgGaiACQYgCahBIIAJBiAZqEEEgAkGIBmoQRCACQYgDaiACQYgGahClASACQcgDaiACQcgFa
        hClASACQcgDaiACQYgDahBIIAJByAdqIAJBiANqEKUBIAJByAdqEAMgAkHIBmogAkGIBWoQpQEgAkHIBmoQAyACQYgGai
        ACQcgBahClASACQYgGaiACQcgGahBIIAJByAdqIAJBiAZqEHggAkHIB2oQRCACQcgHaiACQYgDahBIIAJByAZqIAJBiAV
        qEEggAkGIBmogAkGIAmoQpQEgAkGIBmogAkHIBmoQSCACQcgHaiACQYgGahB4IAJByAdqEEQgAkGIBmogAkHIB2oQpQEg
        AkGIBmogAkGIBWoQSCACQYgGaiACQYgHahBcIQQgAkGIBWogAkGIBmoQpQEgAkGIBWogAkGIB2oQNCACQYgFaiACQcgHa
        hBIIAJBiANqIAJBiAVqEEggAkHIA2ogAkGIBWoQSCACQcgFaiABEEggAkHIBmogAkGIBWoQpQEgAkHIBmoQAyACQYgFai
        ACQcgGahClASACQYgFaiACQcgFahBIIAJByAVqIAJBiAZqEKUBIAJByAVqQQsQUiACQcgJakHQhcAAEF8gAkGICmogAkH
        ICWoQiwEgAkHIAmogAkGICmoQpQEgAkHIAmogAkGIB2oQSCACQYgDaiACQcgDakEBIARrIgEQeSACQcgGaiACQYgFaiAB
        EHkgAkGIBmogAkHIBWogARB5IAJBiAdqIAJByAJqIAEQeSACQYgKaiACQYgGaiACQYgHahAjIAJByARqIAJBiApqEKUBI
        AJByARqIAJByAZqEEggAkHIBGoQWCEBIAJBiAZqIAJByARqEKUBIAJBiAZqEEEgAkGIBmoQRCACQcgEaiACQYgGaiABIA
        NzEHkgAkGICmpBiIbAABBfIAJBiAhqIAJBiApqEIsBQTghAQNAIAFBoAVGRQRAIAJBiAhqIAJBiANqEEggAkHICWogAUG
        IhsAAahBfIAFBOGohASACQYgKaiACQcgJahCLASACQYgGaiACQYgKahClASACQYgIaiACQYgGahB4IAJBiAhqEEQMAQsL
        IAJByAhqIAJBiANqEIUBIAJByAlqQaiLwAAQXyACQYgKaiACQcgJahCLASACQYgGaiACQYgKahClASACQcgIaiACQYgGa
        hB4IAJByAhqEERBACEBA0AgAUH4A0ZFBEAgAkHICGogAkGIA2oQSCACQcgJaiABQeCLwABqEF8gAUE4aiEBIAJBiApqIA
        JByAlqEIsBIAJBiAZqIAJBiApqEKUBIAJByAhqIAJBiAZqEHggAkHICGoQRAwBCwsgAkGICmpB2I/AABBfIAJBiAlqIAJ
        BiApqEIsBQQAhAQNAIAFByAZGBEACQCACQcgJaiACQYgDahCFASACQcgKakHYlsAAEF8gAkGICmogAkHICmoQiwEgAkGI
        BmogAkGICmoQpQEgAkHICWogAkGIBmoQeCACQcgJahBEQQAhAQNAIAFBkAZGDQEgAkHICWogAkGIA2oQSCACQcgKaiABQ
        ZCXwABqEF8gAUE4aiEBIAJBiApqIAJByApqEIsBIAJBiAZqIAJBiApqEKUBIAJByAlqIAJBiAZqEHggAkHICWoQRAwACw
        ALBSACQYgJaiACQYgDahBIIAJByAlqIAFBkJDAAGoQXyABQThqIQEgAkGICmogAkHICWoQiwEgAkGIBmogAkGICmoQpQE
        gAkGICWogAkGIBmoQeCACQYgJahBEDAELCyACQYgJaiACQcgEahBIIAJBiAZqIAJBiAhqEKUBIAJBiAZqIAJByAlqEEgg
        AkEIaiACQYgGahClASACQYgGaiACQYgJahClASACQYgGaiACQcgIahBIIAJByABqIAJBiAZqEKUBIAJBiAZqIAJByAhqE
        KUBIAJBiAZqIAJByAlqEEggAkGIAWogAkGIBmoQpQEgACACQQhqQcABEGcaIAJBgAtqJAALzQ0CE38IfiMAQYADayIBJA
        AgADQCOCIUIBR+QoCAgBBaBEAgABASCyABQeABakHoABByGiABQcgBaiAAKQMAIhggGEI/hyIZIBggGRAxIAEgASkDyAE
        iFEL//////////wODNwPYASABQdABaikDACIXQgaGIBRCOoiEIRUgF0I6iCEaIABBCGoiCyEFIAAhBkEBIQcDQCAHQQZP
        BEAgAEEYaiEMIABBKGohCyAAQRBqIQcgACkDMCEYQQQhBkEAIQkgAUGgAWohDUEDIQpBAiEIQQchBQJAAkADQCAFQQpLD
        QIgBiAIIAYgCEsbIQ4gBiAKIAYgCksbQQN0QWhqIQ8gAUGYAWogBUEDdCIQIABqQVBqKQMAIhQgFEI/hyAYIBhCP4ciGR
        AxIAVBAWoiEUEBdiESIA0pAwAhFyABKQOYASEUIAshAyAHIQQgBUF7aiITIQICQANAIAIgDkcEQCACQQdGDQIgAUGIAWo
        gBCkDACIWIBZCP4cgAykDACIWIBZCP4cQMSABKQOIASIWIBR8IhQgFlStIAFBkAFqKQMAIBd8fCEXIANBeGohAyAEQQhq
        IQQgAkEBaiECDAELCyABQdgBaiAQaiAUQgGGIhYgFXwiFUL//////////wODNwMAIAFB+ABqIAAgE0EDdGopAwAiGyAbQ
        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
        kEBNgIAIAJBgApqIABBgANqIgMQXiACQYAIaiACQYAKahCQASACQYAKaiABQYADaiIFEF4gAkGACGogAkGACmoQDyACQc
        AMahCpASAERQRAIAJBgApqIAMQXiACQcAMaiACQYAKahCQASACQYAKaiABQYACahBeIAJBwAxqIAJBgApqEA8LIAAoAoA
        GQQRHBEAgAkGACmogAEGAAmoQXiACQcAMaiACQYAKahCQASACQYAKaiAFEF4gAkHADGogAkGACmoQDwsgAkGABGogAkHA
        DGogAkGACGoQoQEgAkGABGoQZgsgAkGACGogABCOASACQYAKaiABEI4BIAJBgAhqIABBgAJqIgQQlgEgAkGACGoQrAEgA
        kGACmogAUGAAmoiBRCWASACQYAKahCsASACQYACaiACQYAIahCSASACQYACaiACQYAKahAZIAJBgAhqIAQQkgEgAkGACG
        ogAEGABGoiAxCWASACQYAIahCsASACQYAKaiAFEJIBIAJBgApqIAFBgARqIgUQlgEgAkGACmoQrAEgAkGABmogAkGACGo
        QkgEgAkGABmogAkGACmoQGSACQYAIaiACEJIBIAJBgAhqECsgAkGACmogAkGABGoQkgEgAkGACmoQKyACQYACaiACQYAI
        ahCWASAEIAJBgAJqEJIBIAQgAkGACmoQlgEgAkGABmogAkGACmoQlgEgAkGABGogAkGACGoQlgEgAkGACGogABCSASACQ
        YAIaiADEJYBIAJBgAhqEKwBIAJBgApqIAEQkgEgAkGACmogBRCWASACQYAKahCsASACQYAIaiACQYAKahAZIAJBgARqIA
        JBgAhqEJYBIAJBgAhqIAMQkgEgAkGACGogBRAZIAJBgApqIAJBgAhqEJIBIAJBgApqECsgAyACQYAEahCSASADIAJBgAp
        qEJYBIAJBgAZqIAJBgApqEJYBIAJBgAhqEGYgBCACQYAIahCWAQwDCyAAIAEQBgwECyACQcAMaiABQYAFahBeIAJBgAxq
        IAJBwAxqQcAAEGcaIAJBgAZqIAJBgAxqEKMBCyACQYAGahBmIAJBgAhqIAIQkgEgAkGACGoQKyACQYACaiACQYAIahCWA
        SAFIAJBgAJqEJIBIAJBgARqIAJBgAhqEJIBIAJBgAhqIAAQkgEgAkGACGogAxCWASACQYAIahCsASACQYAKaiABEJIBIA
        JBgApqIAFBgARqEJYBIAJBgApqEKwBIAJBgAhqIAJBgApqEBkgAkGABGogAkGACGoQlgEgAkGACGogAxCSAQJAIARBAkc
        EQCACQcAMaiABQYAFahBeIAJBgAhqIAJBwAxqEKIBDAELIAJBwAxqIAFBgAVqEF4gAkGADGogAkHADGpBwAAQZxogAkGA
        CGogAkGADGoQowELIAJBgAhqEGYgAkGACmogAkGACGoQkgEgAkGACmoQKyADIAJBgARqEJIBIAMgAkGACmoQlgEgAkGAB
        mogAkGACmoQlgEgAkGACGoQZiAFIAJBgAhqEJYBCyACQYAGahCsASACQYAGahBmIAAgAhCSASAAIAJBgAZqEJYBIABBBT
        YCgAYgABCZAQwBCyAAIAEQbAsgAkHADWokAAuaCQIPfwt+IwBBwAJrIgIkACACQeAAakGgp8AAEF8gAEE4EHIhDCACQZg
        BakHwABByGiACQZACakEwEHIaIAwQdCACIAEpAwAiFEL9//P/z///+QF+Qv//////////A4MiETcDiAIgAkHQAGogEUIA
        IAIpA2AiGCAYQj+HIhoQMSAUIAIpA1AiEXwiFiARVK0gAkHYAGopAwAgFEI/h3x8IhRCOocgASkDCCIRQj+HfCARIBRCB
        oYgFkI6iIQiEXwiEiARVK18IRNBASEDAkADQAJAIANBB0YEQCACQZACaiEJIAJB6ABqIQpBByEEIAJB4ABqIQ0gAkGIAm
        ohDkEGIQ8MAQsgA0EBdiIAQQFqIQUgCiAAayEGIAkgAEEDdCIHayEAIAdBCGohCCACQUBrIANBA3QiBCACQeAAamopAwA
        iFiAWQj+HIhQgAikDiAIiESARQj+HEDEgAkHIAGopAwAgEiAVfCIRIBJUrSATIBd8fHwgESACKQNAfCITIBFUrXwhEiAD
        QQFqIQcDQCADIAVNBEAgAkGIAmogBGogE0L9//P/z///+QF+Qv//////////A4MiETcDACACQTBqIBFCACAYIBoQMSACQ
        SBqIBFCACAWIBQQMSACQZgBaiADQQR0aiIAIAJBKGopAwAiGzcDCCAAIAIpAyAiGTcDACACKQMwIhEgE3wiFiARVK0gAk
        E4aikDACASfHwiFEI6hyABIAdBA3RqKQMAIhFCP4d8IBEgFEIGhiAWQjqIhCIRfCISIBFUrXwhEyAVIBl8IhUgGVStIBc
        gG3x8IRcgCUEIaiEJIApBAWohCiAHIQMMAwsgBkEGSw0DIAJBEGogAkHgAGogCGopAwAgAkHgAGogAGopAwB9IhEgEUI/
        hyACQYgCaiAAaikDACACQYgCaiAIaikDAH0iESARQj+HEDEgAikDECIRIBN8IhMgEVStIAJBGGopAwAgEnx8IRIgBUEBa
        iEFIABBeGohACAGQX9qIQYgCEEIaiEIDAALAAsLA0ACQCAEQQ1HBEAgDyAEQQF2IgBrIQUgDiAAQQN0IgtrIRAgDSALay
        EIIBMgF3wgEiAVfCITIBJUrXwhEiAEQQFqIQdBMCEAIAkhBiAKIQMDQCAAIAtGDQIgBUEGTQRAIAIgAyALaikDACAAIAh
        qKQMAfSIRIBFCP4cgACAQaikDACAGIAtqKQMAfSIRIBFCP4cQMSACKQMAIhEgE3wiEyARVK0gAkEIaikDACASfHwhEiAF
        QX9qIQUgBkEIaiEGIANBCGohAyAAQXhqIQAMAQsLIAVBB0HknsAAEDwACyAMIBJC//////////8DgzcDMCACQcACaiQAD
        wsgBEEDdCAMakFIaiATQv//////////A4M3AwAgEkI6hyABIAdBA3RqKQMAIhFCP4d8IBEgEkIGhiATQjqIhCIRfCISIB
        FUrXwhEyAXIARBBHQgAmpBOGoiAEEIaikDAH0gFSAAKQMAIhFUrX0hFyAOQQhqIQ4gDUEIaiENIA9BAWohDyAVIBF9IRU
        gByEEDAALAAsgBkEHQdSewAAQPAAL+QkBBH8jAEGACWsiAiQAIAJBgAhqIAAQXiACIAJBgAhqEF4gAkGACGogAEGAAWoi
        BBBeIAJBgAFqIAJBgAhqEF4gAkGACGogARBeIAIgAkGACGoQDyACQYAIaiABQYABaiIFEF4gAkGAAWogAkGACGoQDyAAK
        AKABiEDAkACQCABKAKABkECRwRAIANBAkYNASACQYAIaiAAQYAFahBeIAJBgAJqIAJBgAhqEF4gAkGACGogAUGABWoQXi
        ACQYACaiACQYAIahAPDAILIANBAkYEQCACQYAIaiAAQYAFahBeIAJBgAdqIAJBgAhqQcAAEGcaIAJBgAZqIAJBgAdqEIU
        BIAJBgAhqIAFBgAVqEF4gAkGAB2ogAkGACGpBwAAQZxogAkGABmogAkGAB2oQSCACQYAIakE4EHIaIAJBATYCuAggAkHA
        CGpBOBByIAJB+AhqQQE2AgAgAkGACGogAkGABmoQpQEQsgEgAkGAAmogAkGACGpBgAEQZxoMAgsgAkGACGogAEGABWoQX
        iACQYACaiACQYAIahBeIAJBgAhqIAFBgAVqEF4gAkGAB2ogAkGACGpBwAAQZxogAkGAAmogAkGAB2oQoAEMAQsgAkGACG
        ogAUGABWoQXiACQYACaiACQYAIahBeIAJBgAhqIABBgAVqEF4gAkGAB2ogAkGACGpBwAAQZxogAkGAAmogAkGAB2oQoAE
        LIAJBgAhqIAAQXiACQYADaiACQYAIahBeIAJBgAhqIAEQXiACQYAEaiACQYAIahBeIAJBgAhqIAQQXiACQYADaiACQYAI
        ahCVASACQYADahCoASACQYAIaiAFEF4gAkGABGogAkGACGoQlQEgAkGABGoQqAEgAkGABWogAkGAA2oQXiACQYAFaiACQ
        YAEahAPIAJBgAZqIAIQXiACQYAGaiACQYABahCVASACQYAGahA6IAJBgAVqIAJBgAZqEJUBIAJBgAhqIAAQXiACQYADai
        ACQYAIahCQASACQYAIaiAAQYAFaiIDEF4gAkGAA2ogAkGACGoQlQEgAkGAA2oQqAEgAkGACGogARBeIAJBgARqIAJBgAh
        qEJABIAJBgAhqIAFBgAVqIgEQXiACQYAEaiACQYAIahCVASACQYAEahCoASACQYAHaiACQYADahBeIAJBgAdqIAJBgARq
        EA8gAkGABmogAhCQASACQYAGaiACQYACahCVASACQYAGahA6IAJBgAdqIAJBgAZqEJUBIAJBgAhqIAQQXiACQYADaiACQ
        YAIahCQASACQYAIaiADEF4gAkGAA2ogAkGACGoQlQEgAkGAA2oQqAEgAkGACGogBRBeIAJBgARqIAJBgAhqEJABIAJBgA
        hqIAEQXiACQYAEaiACQYAIahCVASACQYAEahCoASACQYAIaiACQYADahBeIAJBgAhqIAJBgARqEA8gAkGABmogAkGAAWo
        QkAEgAkGABmogAkGAAmoQlQEgAkGABmoQOiACQYAIaiACQYAGahCVASACQYABahBVIAIgAkGAAWoQlQEgACACIAJBgAVq
        EKEBIAJBgAJqEFUgAkGAAmoQqAEgAEGAA2ogAkGAAmoQkAEgAEGAAmoQqQEgAkGACGoQqAEgAkGACGoQVSAAQYAEaiIBI
        AJBgAhqIAJBgAdqEKEBIAAQrAEgARCsASAAQQQ2AoAGIAJBgAlqJAALnwgBB38jAEGgC2siASQAIAFBCGpBoKfAABBfIA
        FBCGpBARCeAQNAIAJBMEYEQCABIAEpAzhCAYc3AzggAUEIakEBEJ4BIAFBCGpBARA7QQAhAiABQYABakE4EHIaIAFB4Ap
        qQTgQchogAUGACWpBOBByGiABQQE2ArgBIAFBwAFqQTgQciEEIAFB+AFqQQE2AgAgAUGAAmpBOBByGiABQbgCakEBNgIA
        IAFBwAJqQTgQchogAUH4AmpBATYCACABQYADakE4EHIaIAFBuANqQQE2AgAgAUHAA2pBOBByGiABQfgDakEBNgIAIAFBg
        ARqQTgQchogAUG4BGpBATYCACABQcAEakE4EHIaIAFB+ARqQQE2AgAgAUGABWpBOBByGiABQbgFakEBNgIAIAFBwAVqQT
        gQchogAUH4BWpBATYCACABQYAGakE4EHIaIAFBuAZqQQE2AgAgAUHABmpBOBByGiABQfgGakEBNgIAIAFBgAdqQTgQcho
        gAUG4B2pBATYCACABQcAHakE4EHIaIAFB+AdqQQE2AgAgAUGACGogAUHgCmpBOBBnGiABQbgIakEBNgIAIAFBwAhqIAFB
        gAlqQTgQZxogAUH4CGpBATYCACABQYAJakHnABByGiABQegJaiAAEIUBIAFB6AlqEEQgAUGoCmogAUEIahBfIAFBqApqE
        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
        J8BIAJBgAZqEFUgAkGABmoQqAEgAkGABWogAkGABmoQkAEgAkGABWogAkGABGoQDyACQYACaiACQYADahCQASACQYACai
        ACQYABahAPIAJBgAVqIAJBgAJqELUBIAJBgAZqIAIQDyACQYABaiACQYAHahAPIAJBgAZqIAJBgAFqEJUBIAIgAkGAA2o
        QDyACQYAHaiACQYAEahAPIAJBgAdqIAIQlQEgACACQYAFahCQASAAEKgBIAMgAkGABmoQkAEgAxCoASAEIAJBgAdqEJAB
        IAQQqAEgAkGACGokAAv2BQEFfyMAQYAEayICJAAgAiAAEIUBIAIgARBIIAJBQGsgAEFAayIDEIUBIAJBQGsgAUFAayIFE
        EggAkGAAWogAEGAAWoiBBCFASACQYABaiABQYABaiIGEEggAkHAAWogABCFASACQcABaiADEHggAkHAAWoQRCACQYACai
        ABEIUBIAJBgAJqIAUQeCACQYACahBEIAJBwAFqIAJBgAJqEEggAkGAAmogAhClASACQYACaiACQUBrEHggAkHAAWogAkG
        AAmoQgAEgAkHAAWoQRCACQYACaiADEKUBIAJBgAJqIAQQeCACQYACahBEIAJBwAJqIAUQhQEgAkHAAmogBhB4IAJBwAJq
        EEQgAkGAAmogAkHAAmoQSCACQcACaiACQUBrEKUBIAJBwAJqIAJBgAFqEHggAkGAAmogAkHAAmoQgAEgAkGAAmoQRCACQ
        cACaiAAEKUBIAJBwAJqIAQQeCACQcACahBEIAJBgANqIAEQhQEgAkGAA2ogBhB4IAJBgANqEEQgAkHAAmogAkGAA2oQSC
        ACQYADaiACEKUBIAJBgANqIAJBgAFqEHggAkGAA2ogAkHAAmoQswEgAkGAA2oQRCACQcACaiACEKUBIAJBwAJqIAIQeCA
        CIAJBwAJqEHggAhBEIAJBgAFqQQwQUiACQcADaiACQUBrEIUBIAJBwANqIAJBgAFqEHggAkHAA2oQRCACQUBrIAJBgAFq
        EIABIAJBQGsQRCACQYADakEMEFIgAkHAAmogAkGAA2oQpQEgAkHAAmogAkGAAmoQSCACQYABaiACQcABahClASACQYABa
        iACQUBrEEggAkHAAmogAkGAAWoQswEgAkGAA2ogAhBIIAJBQGsgAkHAA2oQSCACQYADaiACQUBrEHggAiACQcABahBIIA
        JBwANqIAJBgAJqEEggAkHAA2ogAhB4IAAgAkHAAmoQpQEgABBEIAMgAkGAA2oQpQEgAxBEIAQgAkHAA2oQpQEgBBBEIAJ
        BgARqJAALxQUBBH8jAEHwEmsiACQAIAAQOEF/IQEgABCIAUUEQCAAQYADakE4EHIaIABBuANqQTgQchogAEG4A2ogAEGA
        A2oQVCAAQfAKakG4gMAAEF8gAEHwDWpB8IDAABBfIABB8ANqIABB8ApqIABB8A1qEEkgAEHwBGpBOBByGiAAQQE2AqgFI
        ABBsAVqQTgQchogAEHoBWpBATYCACAAQfAFakE4EHIaIABBATYCqAYgAEGwBmpBOBByGiAAQegGakEBNgIAIABB8AZqQT
        gQchogAEEBNgKoByAAQbAHakE4EHIaIABB6AdqQQE2AgBBf2ohAyAAQfAHahAqIABB8AdqIAAQfiAAQfAKahAqIABB8Ap
        qIABB8AdqEH4gAEHwDWoQKiAAQfANaiAAQfAHahB+IABB8A1qEJwBAkACQAJAA0AgAiEBIANBAkkNAyAAQfAKaiAAQfAE
        aiAAQfAFaiAAQfAGahAlIAFBxABNBEAgAEHwEGogAEHwBGogAEHwBWogAEHwBmoQRiABQQh0QdCrwABqIABB8BBqEJIBI
        AFBAWohAgJAAkAgAEG4A2ogA0F/aiIDEFcgAEGAA2ogAxBXa0EBag4DAQMAAwsgAEHwCmogAEHwB2ogAEHwBGogAEHwBW
        ogAEHwBmoQHiABQcMASw0DIABB8BBqIABB8ARqIABB8AVqIABB8AZqEEYgAkEIdEHQq8AAaiAAQfAQahCSASABQQJqIQI
        MAgsgAEHwCmogAEHwDWogAEHwBGogAEHwBWogAEHwBmoQHiABQcMASw0DIABB8BBqIABB8ARqIABB8AVqIABB8AZqEEYg
        AkEIdEHQq8AAaiAAQfAQahCSASABQQJqIQIMAQsLIAFBxQBBvIHAABA8AAtBxQBBxQBBzIHAABA8AAtBxQBBxQBB3IHAA
        BA8AAtBACEBCyAAQfASaiQAIAEL8gQBBH8jAEGADGsiAiQAIAIgABCOASACQYACahAvIAJBgARqIABBgAJqIgMQjgEgAk
        GABmoQLyACQYAIaiAAEI4BIAJBgApqIAEQjgEgAiABEBkgAkGABGogAUGAAmoiBBAZIAJBgAhqIAMQlgEgAkGACmogBBC
        WASACQYAIahCsASACQYAKahCsASACQYACaiACQYAIahCSASACQYACaiACQYAKahAZIAJBgAhqIAMQkgEgAkGACGogAEGA
        BGoiBRCWASACQYAKaiAEEJIBIAJBgApqIAFBgARqIgQQlgEgAkGACGoQrAEgAkGACmoQrAEgAkGABmogAkGACGoQkgEgA
        kGABmogAkGACmoQGSACQYAIaiACEJIBIAJBgAhqECsgAkGACmogAkGABGoQkgEgAkGACmoQKyACQYACaiACQYAIahCWAS
        ADIAJBgAJqEJIBIAMgAkGACmoQlgEgAkGABmogAkGACmoQlgEgAkGABGogAkGACGoQlgEgAkGACGogABCSASACQYAIaiA
        FEJYBIAJBgAhqEKwBIAJBgApqIAEQkgEgAkGACmogBBCWASACQYAKahCsASACQYAIaiACQYAKahAZIAJBgARqIAJBgAhq
        EJYBIAJBgAhqIAUQkgEgAkGACGogBBAZIAJBgApqIAJBgAhqEJIBIAJBgApqECsgBSACQYAEahCSASAFIAJBgApqEJYBI
        AJBgAZqIAJBgApqEJYBIAJBgAhqEGYgAyACQYAIahCWASACQYAGahCsASACQYAGahBmIAAgAhCSASAAIAJBgAZqEJYBIA
        BBBTYCgAYgABCZASACQYAMaiQAC68EAQV/IwBBkAZrIgIkACAAQUBrIQQCQCABQfgAaigCACABKAI4aqwgAEH4AGooAgA
        iAyAAKAI4IgVqrH5CgICAEFMNACAFQQJOBH8gABASIAAoAngFIAMLQQJIDQAgBBASCyACQaCnwAAQX0EAIQMgAkE4akHw
        ABByGiABQUBrIQUDQCADQThGBEAgAkHwAGohBkEAIQMDQCADQThGRQRAIAMgBmogAiADaikDADcDACADQQhqIQMMAQsLI
        AJBqAFqIAAQXyACQeABaiABEF8gAkGYAmogACABEAggAkGIA2ogBCAFEAggAkGoAWogBBBhIAJBqAFqEEQgAkHgAWogBR
        BhIAJB4AFqEEQgAkH4A2ogAkGoAWogAkHgAWoQCEEAIQMgAkHoBGpB8AAQchoDQCADQfAARkUEQCACQegEaiADaiACQZg
        CaiADaikDADcDACADQQhqIQMMAQsLIAJB6ARqIAJBiANqEGVBACEDA0AgA0HwAEZFBEAgAkGIA2ogA2oiASACQThqIANq
        KQMAIAEpAwB9NwMAIANBCGohAwwBCwsgAkGYAmogAkGIA2oQZSACQZgCahBFIAJB+ANqIAJB6ARqEGQgAkH4A2oQRSACQ
        dgFaiACQZgCahAFIAAgAkHYBWoQayAAQQM2AjggAkHYBWogAkH4A2oQBSAEIAJB2AVqEGsgAEECNgJ4IAJBkAZqJAAFIA
        JBOGogA2pCADcDACADQQhqIQMMAQsLC5QEAQF/IwBB0CJrIgMkACADQcAWakG4gMAAEF8gA0HIHGpB8IDAABBfIANBCGo
        gA0HAFmogA0HIHGoQSSADQYgBakE4EHIaIANBwAFqQTgQchogA0H4AWoQKgJAIAIQhAFFBEAgA0H4BGoQKiADQfgEaiAB
        EH4gA0H4BGoQSiADQfgHahBLIANB+AdqIAIQfyADQfgHahBHIANByBxqIANB+AdqEIUBIANBuAlqIANByBxqEIUBIANBy
        BxqIANBuAhqEIUBIANB+AlqIANByBxqEIUBIANBuApqECogA0G4DWoQYCADQbgKaiADQfgEahB+IANBwBNqECogA0HAE2
        ogA0H4BGoQfiADQcATahCcASADQcABaiADQYgBahBUQX9qIQIDQCACQQFNBEAgA0G4DWoQkwEgACADQbgNakGIBhBnGgw
        DBSADQbgNahAbIANBwBZqIANBuApqIANBuAlqIANB+AlqEBcCQAJAAkAgA0HAAWogAkF/aiICEFcgA0GIAWogAhBXa0EB
        ag4DAQIAAgsgA0HIHGogA0G4CmogA0H4BGogA0G4CWogA0H4CWoQFiADQcAWaiADQcgcahAGDAELIANByBxqIANBuApqI
        ANBwBNqIANBuAlqIANB+AlqEBYgA0HAFmogA0HIHGoQBgsgA0G4DWogA0HAFmoQBAwBCwALAAsgABBgCyADQdAiaiQAC8
        MDARV/A0AgAUHAAUYEQAJAIABBKGohCyAAQRRqKAIAIgwhCCAAQRBqKAIAIg0hAyAAQQxqKAIAIg4hAiAAKAIIIg8hASA
        AQRhqKAIAIhAhCiAAQRxqKAIAIhEhBCAAQSBqKAIAIhIhByAAQSRqKAIAIhMhBgNAIAchCSAEIQcgCiEEIAVBgAJGDQEg
        AiADcSEUIAIgA3MhFSAFIAtqKAIAIAVB9J7AAGooAgAgBEEadyAEQRV3cyAEQQd3cyAGaiAJIARBf3NxIAQgB3FyampqI
        gYgCGohCiAFQQRqIQUgAyEIIAIhAyABIQIgAUEedyABQRN3cyABQQp3cyAUIAEgFXFzaiAGaiEBIAkhBgwACwALBSAAIA
        FqIgNB6ABqIANBzABqKAIAIANBKGooAgAgA0EsaigCACICQRl3IAJBDndzIAJBA3ZzIANB4ABqKAIAIgJBD3cgAkENd3M
        gAkEKdnNqamo2AgAgAUEEaiEBDAELCyAAIAYgE2o2AiQgACAJIBJqNgIgIAAgByARajYCHCAAIAQgEGo2AhggACAIIAxq
        NgIUIAAgAyANajYCECAAIAIgDmo2AgwgACABIA9qNgIIC9YDAgZ/An4jAEHwAGsiASQAIAFBoKfAABBfIAFBOGogARBfI
        AAQRAJAAkACQCABAn8gACgCOCICQRBMBEAgAkF/ahA5DAELIAEpAzAiCEIBfCIHIAhUDQEgACkDMCIIQoCAgICAgICAgH
        9RQQAgB0J/URsNAiABQThqIAggB3+nECghByABIAEpA2ggB0I6hnw3A2ggACABQThqEGIgABBEQQILIgMQLSAAQQhqIQQ
        DQCADRQ0DIAEgASkDCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgASAAKQMAIAd9IgdC//////////8DgzcDOEEA
        IQIDQCAHQjqHIQcgAkEoRkUEQCABIAJqIgVBCGoiBiAFQRBqKQMAQjmGQoCAgICAgICAAoMgBikDAEIBh4QiCDcDACABI
        AJqQUBrIAIgBGopAwAgCH0gB3wiB0L//////////wODNwMAIAJBCGohAgwBCwsgASABKQMwQgGHIgg3AzAgASAAKQMwIA
        h9IAd8Igc3A2ggACABQThqIAdCP4enQQFqEE8gA0F/aiEDDAALAAtBoKLAAEEZQbyiwAAQWwALQdCiwABBH0G8osAAEFs
        ACyAAQQE2AjggAUHwAGokAAuhAwEBfyMAQZADayIGJAAgBkEIakHAABByGiAGQcgAakGoAhByGiAGQcgAahBDA0AgAQRA
        IAZByABqQQAQPiABQX9qIQEMAQUCQCACBEAgBkHIAGogAiADEHoLIAQEQCAGQcgAaiAEIAUQegsgBkGIA2pCADcDACAGQ
        YADakIANwMAIAZB+AJqQgA3AwAgBkIANwPwAiAGKAJIIQEgBigCTCECIAZByABqQYABED4DQCAGKAJIQf8DcUHAA0ZFBE
        AgBkHIAGpBABA+DAELCyAGQawBaiABNgIAIAZBqAFqIAI2AgAgBkHIAGoQEUEAIQJBACEBA0AgAUEgRkUEQCAGQfACaiA
        BaiABQXxxIAZqQdAAaigCACACQX9zQRhxdjoAACACQQhqIQIgAUEBaiEBDAELCyAGQcgAahBDQQAhAQNAIAFBIEZFBEAg
        BkEIaiABaiAGQfACaiABai0AADoAACABQQFqIQEMAQsLQQAhAQNAIAFBIEYNASAAIAFqIAZBCGogAWotAAA6AAAgAUEBa
        iEBDAALAAsLCyAGQZADaiQAC6EDAQN/IwBBgAZrIgEkACABIABBgAFqIgMQXiABQYABaiADEF4gAUGAAWoQMiABQYACai
        ABEF4gAUGAAmogAEGAAmoiAhAPIAFBgANqIAIQXiABQYADahAyIAIgAUGAAWoQkAEgAiABQYABahCVASACEKgBIAIQpwE
        gAhCnASACEKgBIAFBgANqQQwQnwEgAUGAA2oQVSABQYADahCoASABQYAEaiABQYADahBeIAFBgARqIAIQDyABQYAFaiAB
        QYABahBeIAFBgAVqIAFBgANqEJUBIAFBgAVqEKgBIAIgAUGAAmoQDyABQYACaiABQYADahCQASABQYACaiABQYADahCVA
        SABQYADaiABQYACahCVASABQYADahCoASABQYABaiABQYADahB9IAFBgAFqEKgBIAFBgAVqIAFBgAFqEA8gAUGABWogAU
        GABGoQlQEgAUGAAmogABCQASABQYACaiABEA8gACABQYABahCQASAAEKgBIAAgAUGAAmoQDyAAEKcBIAAQqAEgAyABQYA
        FahCQASADEKgBIAFBgAZqJAALhQMBBH8CQAJAIAFBgAJPBEAgAEEYaigCACEEAkACQCAAIAAoAgwiAkYEQCAAQRRBECAA
        QRRqIgIoAgAiAxtqKAIAIgENAUEAIQIMAgsgACgCCCIBIAI2AgwgAiABNgIIDAELIAIgAEEQaiADGyEDA0AgAyEFIAEiA
        kEUaiIDKAIAIgFFBEAgAkEQaiEDIAIoAhAhAQsgAQ0ACyAFQQA2AgALIARFDQIgACAAQRxqKAIAQQJ0QeS3wQBqIgEoAg
        BHBEAgBEEQQRQgBCgCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQdi1wQBB2LXBACgCAEF+IAAoAhx3cTYCAA8
        LIABBDGooAgAiAiAAQQhqKAIAIgBHBEAgACACNgIMIAIgADYCCA8LQdS1wQBB1LXBACgCAEF+IAFBA3Z3cTYCAAwBCyAC
        IAQ2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgAEEUaigCACIARQ0AIAJBFGogADYCACAAIAI2AhgLC7MCAQF/IwBBg
        AtrIgUkACAFEC8gBUGAAmoQLyAFQYAEahAvIAVBgAZqQTgQchogBUEBNgK4BiAFQcAGakE4EHIaIAVB+AZqQQE2AgAgBU
        GAB2pBOBByGiAFQQE2ArgHIAVBwAdqQTgQchogBUH4B2pBATYCACAFQYAIakE4EHIaIAVBATYCuAggBUHACGpBOBByGiA
        FQfgIakEBNgIAIAEgAiAFQYAGaiAFQYAHaiAFQYAIahAeIAVBgAhqIAMQoAEgBUGABmogBBCgASAFQYAJaiAFQYAGaiAF
        QYAHahCRASAFIAVBgAlqEJIBIAVBgAlqIAVBgAhqEJsBIAVBgARqIAVBgAlqEJIBIAVBgARqEGYgACAFIAVBgAJqIAVBg
        ARqEHYgAEEDNgKABiAFQYALaiQAC7ECAQF/IwBBgAtrIgQkACAEEC8gBEGAAmoQLyAEQYAEahAvIARBgAZqQTgQchogBE
        EBNgK4BiAEQcAGakE4EHIaIARB+AZqQQE2AgAgBEGAB2pBOBByGiAEQQE2ArgHIARBwAdqQTgQchogBEH4B2pBATYCACA
        EQYAIakE4EHIaIARBATYCuAggBEHACGpBOBByGiAEQfgIakEBNgIAIAEgBEGABmogBEGAB2ogBEGACGoQJSAEQYAIaiAC
        EKABIARBgAZqIAMQoAEgBEGACWogBEGABmogBEGAB2oQkQEgBCAEQYAJahCSASAEQYAJaiAEQYAIahCbASAEQYAEaiAEQ
        YAJahCSASAEQYAEahBmIAAgBCAEQYACaiAEQYAEahB2IABBAzYCgAYgBEGAC2okAAvJAgEDfyMAQcACayIBJAAgASAAQU
        BrIgMQhQEgARADIAFBQGsgAxCFASABQUBrIABBgAFqIgIQSCABQYABaiACEIUBIAFBgAFqEAMgAiABEKUBIAIgARB4IAI
        QRCACEE4gAhBOIAIQRCABQYABakEMEFIgAUHAAWogAUGAAWoQhQEgAUHAAWogAhBIIAFBgAJqIAEQhQEgAUGAAmogAUGA
        AWoQeCABQYACahBEIAIgAUFAaxBIIAFBQGsgAUGAAWoQpQEgAUFAayABQYABahB4IAFBgAFqIAFBQGsQeCABIAFBgAFqE
        IABIAEQRCABQYACaiABEEggAUGAAmogAUHAAWoQeCABQUBrIAAQpQEgAUFAayADEEggACABEKUBIAAQRCAAIAFBQGsQSC
        AAEE4gABBEIAMgAUGAAmoQpQEgAxBEIAFBwAJqJAALrQIBA38jAEGABGsiAiQAIAIgABBeIAJBgAFqIABBgAFqIgMQXiA
        CQYACakE4EHIaIAJBATYCuAIgAkHAAmpBOBByGiACQfgCakEBNgIAIAJBgANqIAMQXiACIAEQDyACQYABaiABQYABaiIE
        EA8gAkGAAmogBBCQASACQYACaiABEJUBIAJBgANqIAAQlQEgAkGAAmoQqAEgAkGAA2oQqAEgAkGAA2ogAkGAAmoQDyACQ
        YACaiACEJABIAJBgAJqEDogAkGAA2ogAkGAAmoQlQEgAkGAA2oQqAEgAkGAAmogAkGAAWoQkAEgAkGAAmoQOiADIAJBgA
        NqEJABIAMgAkGAAmoQlQEgAkGAAWoQVSAAIAJBgAFqEJABIAAgAhCVASAAEKwBIAJBgARqJAALvQIBA38jAEGACGsiASQ
        AIAEgABCOASABQYACaiAAQYAEaiICEI4BIAFBgARqIABBgAJqIgMQjgEgAUGABmoQLyAAECIgAUGABmogABCSASABQYAG
        aiAAEJYBIAAgAUGABmoQlgEgABCsASABELYBIAEQrwEgACABEJYBIAFBgAJqECIgAUGAAmoQZiABQYAGaiABQYACahCSA
        SABQYAGaiABQYACahCWASABQYACaiABQYAGahCWASABQYACahCsASABQYAEahAiIAFBgAZqIAFBgARqEJIBIAFBgAZqIA
        FBgARqEJYBIAFBgARqIAFBgAZqEJYBIAFBgARqEKwBIAMQrgEgAxCvASACELYBIAIQrwEgAyABQYACahCWASACIAFBgAR
        qEJYBIABBBTYCgAYgABCaASABQYAIaiQAC7ICAQN/IwBBgAhrIgEkACAAKAKABkEBRwRAIAEgABCOASABQYACaiAAQYAC
        aiIDEI4BIAFBgARqIABBgARqIgIQjgEgAUGABmogABCOASABECIgAUGAAmogAhAZIAFBgAJqEK8BIAFBgAJqEKwBIAFBg
        ARqECIgAUGABmogAxAZIAFBgAZqEK8BIAIgABCWASACIAMQlgEgAhCsASACECIgACABEJIBIAEgAUGAAmoQlgEgARCsAS
        ABIAFBgARqEJYBIAEgAUGABmoQlgEgARCsASABECsgAUGAAmoQZiABQYAEahBmIAAgAUGAAmoQlgEgAyABQYAEahCSASA
        DIAFBgAZqEJYBIAIgARCWASAAQQRBBSAAKAKABkF+cUECRhs2AoAGIAAQmQELIAFBgAhqJAALigIBAn8jAEHgAWsiAiQA
        IAAQRCACQQhqQTAQchogAkIBNwMAIAJBOGogABBfIAJB8ABqIAEQXyACQagBakE4EHIaIAAQdANAIAJBOGogAkHwAGoQN
        UF/TARAA0ACQCADQQBMDQAgAkHwAGpBARA7IAJBARA7IAJBqAFqIAJBOGoQayACQagBaiACQfAAahBiIAJBqAFqEEQgAk
        E4aiACQagBaiACKQPYAUI/h6dBAWoiARBPIAJBqAFqIAAQayACQagBaiACEGEgAkGoAWoQRCAAIAJBqAFqIAEQTyADQX9
        qIQMMAQsLBSACQQEQLSACQfAAakEBEC0gA0EBaiEDDAELCyACQeABaiQAC54CAQF/IwBBgA1rIgMkACADIAEQaiADEJkB
        IANBiAZqIAIQXyADQYgGahBEIANBwAZqIANBiAZqEF8gA0HABmpBAxAoGiADQcAGahBEIANB+AZqIAMQagJAIANBwAZqE
        FpFBEAgA0HABmoQKUF/aiECA0AgAkEBTQRAIANB+AZqEJoBDAMLIANB+AZqEBoCQAJAIANBwAZqIAJBf2oiAhBXIANBiA
        ZqIAIQV2tBAWoOAwECAAILIANB+AZqIAMQDgwBCyADEJMBIANB+AZqIAMQDiADEJMBDAALAAsgA0H4BmoQsAEgA0H4B2o
        QqQEgA0H4CGoQrQEgA0H4CmoQrQEgA0EBNgL4DAsgACADQfgGakGIBhBnGiADQYANaiQAC5ACAQJ/IwBBgAJrIgUkACAF
        QYABaiAAEF4gAiAFQYABahCQASAFQYABaiAAQYABahBeIAQgBUGAAWoQkAEgBUGAAWogAEGAAmoiBhBeIAUgBUGAAWoQX
        iAFQYABaiAGEF4gAyAFQYABahCQASAFQYABaiABQYABaiIGEF4gBSAFQYABahAPIAVBgAFqIAEQXiADIAVBgAFqEA8gAi
        ADEH0gAhCoASAEIAUQfSAEEKgBIAUgAhCQASACEFUgAhCoASAFQYABaiAGEF4gBSAFQYABahAPIAMgBBCQASAFQYABaiA
        BEF4gAyAFQYABahAPIAMgBRB9IAMQqAEgBBA6IAQQqAEgACABEAsgBUGAAmokAAvkAQECfyMAQcABayIDJAAgAxBLIAAg
        ASACQR91IgQgAnMgBEF/c2pBAm0iAkF/akEfdhBtIAAgAUHAAWogAkEBc0F/akEfdhBtIAAgAUGAA2ogAkECc0F/akEfd
        hBtIAAgAUHABGogAkEDc0F/akEfdhBtIAAgAUGABmogAkEEc0F/akEfdhBtIAAgAUHAB2ogAkEFc0F/akEfdhBtIAAgAU
        GACWogAkEGc0F/akEfdhBtIAAgAUHACmogAkEHc0F/akEfdhBtIAMgABB/IAMQpgEgACADIARBAXEQbSADQcABaiQAC+Q
        BAQJ/IwBBgANrIgMkACADECogACABIAJBH3UiBCACcyAEQX9zakECbSICQX9qQR92EG8gACABQYADaiACQQFzQX9qQR92
        EG8gACABQYAGaiACQQJzQX9qQR92EG8gACABQYAJaiACQQNzQX9qQR92EG8gACABQYAMaiACQQRzQX9qQR92EG8gACABQ
        YAPaiACQQVzQX9qQR92EG8gACABQYASaiACQQZzQX9qQR92EG8gACABQYAVaiACQQdzQX9qQR92EG8gAyAAEH4gAxCcAS
        AAIAMgBEEBcRBvIANBgANqJAALvAEBAn8jAEGwAWsiAiQAIAJBMBByIQIDQCADQTBGBEACQCABQTBqIQEgAkEwaiACEHV
        BACEDA0AgA0EwRg0BIAIgA2ogASADai0AADoAACADQQFqIQMMAAsACwUgAiADaiABIANqLQAAOgAAIANBAWohAwwBCwsg
        AkHwAGogAhB1IABBOBByIgBBATYCOCAAQUBrQTgQciAAQfgAakEBNgIAIAAgAkHwAGoQpQEgAkEwahClASACQbABaiQAC
        9QBAQJ/IwBBgANrIgEkACABIAAQXiABQYABaiAAQYABaiICEF4gAUGAAmogABBeIAFBgAJqIAIQDyABIAIQlQEgAUGAAW
        oQVSABQYABaiAAEJUBIAEQqAEgAUGAAWoQqAEgACABEJABIAAgAUGAAWoQDyABQYABaiABQYACahCQASABQYABahBVIAF
        BgAFqIAFBgAJqEJUBIAFBgAFqEKgBIAFBgAFqEDogACABQYABahCVASABQYACahCnASACIAFBgAJqEJABIAAQrAEgAUGA
        A2okAAvEAQEBfyMAQYADayIDJAAgA0EIaiABEIUBAkAgAkUEQCADQQhqEAcMAQsgA0EIaiACEKUBCyADQcgAakHYo8AAE
        F8gA0GAAWogA0HIAGoQiwEgA0HAAWogA0EIahCFASADQcABahADIANBwAFqIAEQSCAAIAEQhQEgACADQQhqEEggA0GAAm
        ogA0HAAWoQhQEgABBYIQEgA0HAAmogABCFASADQcACahBBIANBwAJqEEQgACADQcACaiABEHkgA0GAA2okAAufAQEBfyM
        AQfAAayICJAAgAiABEF9BACEBIAJBOGpBOBByGiAAEEQCQCAAIAIQNUEASA0AA0AgAkEBEC0gAUEBaiEBIAAgAhA1QX9K
        DQALA0AgAUEATA0BIAJBARA7IAJBOGogABBrIAJBOGogAhBiIAJBOGoQRCAAIAJBOGogAikDaEI/h6dBAWoQTyABQX9qI
        QEMAAsACyACQfAAaiQAC7IBAQF/IwBBgAJrIgQkACAEQYABaiAAEF4gAyAEQYABahCQASAEQYABaiAAQYABahBeIAQgBE
        GAAWoQXiAEQYABaiAAQYACahBeIAIgBEGAAWoQkAEgASAEEJABIAEgAhAPIAMQMiAEEDIgAhAyIAEQpwEgARA6IAEQqAE
        gARBVIAEQqAEgAkEMEJ8BIANBAxCfASACEFUgAhCoASACIAQQfSACEKgBIAAQFCAEQYACaiQAC58BAQJ/IwBBgAJrIgIk
        ACAAIAEQXiAAEDIgAkGIAWpB2KTAABBfIAJBCGpBOBByGiACQQE2AkAgAkHIAGpBOBByIAJBgAFqQQE2AgAgAkHAAWogA
        kGIAWoQiwEgAkEIaiACQcABahClARCyASACQQhqEKgBIAJBCGoQVSACQQhqEKgBIAAgARAPIAAgAkEIahCVASAAEKsBIA
        JBgAJqJAALowEBAX8jAEEwayIGJAAgBkEQaiAAIAEQsQEgBiAGKAIUIgA2AhwgBiAGKAIQIgE2AhggBkEIaiACIAMQsQE
        gBiAGKAIMIgI2AiQgBiAGKAIIIgM2AiAgBiAEIAUQsQEgBiAGKAIEIgQ2AiwgBiAGKAIAIgU2AiggASAAIAMgAiAFIAQQ
        ACAGQShqEKQBIAZBIGoQpAEgBkEYahCkASAGQTBqJAALiAECA38DfiMAQRBrIgIkAAN+IANBOEYEfiACQRBqJAAgBgUgA
        iAAIANqIgQpAwAiBSAFQj+HIAGsIgUgBUI/hxAxIAQgAikDACIHIAZ8IgVC//////////8DgzcDACAFIAdUrSACQQhqKQ
        MAIAZCP4d8fEIGhiAFQjqIhCEGIANBCGohAwwBCwsLhAECA38BfiMAQUBqIgEkACABQQhqIAAQXyABQQhqEEQgAUE4aiE
        CQQYhA0HcAiEAAn8DQEEAIANBAEgNARogAikDACIEUARAIAJBeGohAiAAQUZqIQAgA0F/aiEDDAELCwN/IARQBH8gAAUg
        AEEBaiEAIARCAn8hBAwBCwsLIAFBQGskAAuHAQEBfyMAQcABayIBJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByGiAAQfgAa
        kEBNgIAIAEQUCABQYgBakE4EHIaIABBgAFqIAFBgAEQZxogAEGAAmpBOBByGiAAQbgCakEBNgIAIABBvAJqIAFBhAFqQT
        wQZxogAEH4AmpBATYCACABQcABaiQAC48BAQJ/IwBBgAJrIgEkACAAEKwBIAEgABBeIAFBgAFqQTgQchogAUEBNgK4ASA
        BQcABakE4EHIaIAFB+AFqQQE2AgAgASAAQYABaiICEJUBIAEQOiABQYABaiABEJABIAFBgAFqIAIQlQEgAiABEJABIAIg
        ABCVASAAIAFBgAFqEJABIAAQrAEgAUGAAmokAAt9AgF/An4jAEGAAWsiASQAIAFBCGogABCFASABQQhqEBIgAUHIAGogA
        UEIahCDAUEIIQADQCAAQThGRQRAIAFByABqIABqKQMAIAKEIQIgAEEIaiEADAELCyABKQNIIQMgAUGAAWokACACQn98IA
        NCAYVCf3yDQjqIp0EBcQuJAQIBfwJ+IAAgACkDMCABQT9xrSIDhiAAKQMoQTogAWtBP3GtIgSHhDcDMCAAQShqIQFBBiE
        CA0AgAkEBTQRAIAAgACkDACADhkL//////////wODNwMABSABIAEpAwAgA4ZC//////////8DgyABQXhqIgEpAwAgBIeE
        NwMAIAJBf2ohAgwBCwsLiQECAX8CfiAAIAApA2BBOiABQTpwIgFrrSIEhyAAKQNoIAGtIgOGhDcDaCAAQeAAaiEBQQ0hA
        gNAIAJBAU0EQCAAIAApAwAgA4ZC//////////8DgzcDAAUgASABKQMAIAOGQv//////////A4MgAUF4aiIBKQMAIASHhD
        cDACACQX9qIQIMAQsLC3EBAX8jAEFAaiIBJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByGiAAQfgAakEBNgIAIAFBCGpBOBB
        yGiAAQYABakE4EHIaIABBuAFqQQE2AgAgAEG8AWogAUEEakE8EGcaIABB+AFqQQE2AgAgAUFAayQAC4EBAgF/AX4gAEHw
        ABByIQADQCACQThGBEACQCAAIAEpAzAiA0I6hzcDOCAAIANC//////////8DgzcDMCAAQUBrIQBBACECA0AgAkEwRg0BI
        AAgAmpCADcDACACQQhqIQIMAAsACwUgACACaiABIAJqKQMANwMAIAJBCGohAgwBCwsLdQECfiAAIANCIIgiBSABQiCIIg
        Z+IAIgA358IAEgBH58IANC/////w+DIgIgAUL/////D4MiAX4iA0IgiCACIAZ+fCICQiCIfCABIAV+IAJC/////w+DfCI
        BQiCIfDcDCCAAIANC/////w+DIAFCIIaENwMAC3YBAn8jAEHAAWsiASQAIAEgABCFASABQUBrIAAQhQEgAUGAAWogAEFA
        ayICEIUBIAEgAhB4IAFBQGsgABB4IAFBQGsQRCACIAFBQGsQSCABQYABahBBIAAgAUGAAWoQeCABEEQgABBEIAAgARBII
        AFBwAFqJAALkwEBAn9B0LXBAEHQtcEAKAIAQQFqNgIAAkACQEGYucEAKAIAQQFGBEBBnLnBAEGcucEAKAIAQQFqIgA2Ag
        AgAEECSw0CQaC5wQAoAgAiAUF/Sg0BDAILQZi5wQBCgYCAgBA3AwBBoLnBACgCACIAQQBIDQFBoLnBACAANgIAAAtBoLn
        BACABNgIAIABBAUsNAAALAAtnAQJ/IwBBQGoiAiQAIAAQRCACIAAQhQECQCABRQRAIAAQBwwBCyAAIAEQpQELQQAhAQNA
        IAFBAUsgA3JFBEAgABADIAFBAEchAyABIAFFaiEBDAELCyAAIAIQSCAAEBIgAkFAayQAC18CAX8EfkIBIQNBMCECA38gA
        kF4RgR/IARCAYYgA3ynQX9qBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBeGohAiAFIAaFQn98QjqHIA
        ODIQMMAQsLC2ACAX8EfkIBIQNB6AAhAgN/IAJBeEYEfyAEQgGGIAN8p0F/agUgASACaikDACIFIAAgAmopAwAiBn1COoc
        gA4MgBIQhBCACQXhqIQIgBSAGhUJ/fEI6hyADgyEDDAELCwt3AQN/IwBBgAJrIgIkACACIAEQXiACQYABaiABEF4gAhAy
        IAJBgAFqIAIQDyAAIAJBgAFqEJcBIABBgAJqIgMgAkGAAWoQlwEgAEGABGoiBCACQYABahCXASADIAEQogEgBCACEKIBI
        ABBBTYCgAYgAkGAAmokAAt6AQF/IwBB4ANrIgEkACABQYABakHApcAAEF8gAUG4AWpB+KXAABBfIAEgAUGAAWogAUG4AW
        oQSSABQfACakGwpsAAEF8gAUGoA2pB6KbAABBfIAFB8AFqIAFB8AJqIAFBqANqEEkgACABIAFB8AFqED8gAUHgA2okAAt
        nACAAQQF2IAByIgBBAnYgAHIiAEEEdiAAciIAQQh2IAByIgBBEHYgAHIiACAAQQF2QdWq1aoFcWsiAEECdkGz5syZA3Eg
        AEGz5syZA3FqIgBBBHYgAGpBj568+ABxQYGChAhsQRh2C2cBAn8jAEGAAWsiASQAIAEgABCFASABQUBrQTgQchogAUEBN
        gJ4IAEgAEFAayICEHggARBBIAFBQGsgARClASABQUBrIAIQeCACIAEQpQEgAiAAEHggACABQUBrEKUBIAFBgAFqJAALaA
        IBfwJ+IAFBP3GtIQNBOiABa0E/ca0hBEEAIQEDQCABQTBGBEAgACAAKQMwIAOHNwMwBSAAIAFqIgIgAkEIaikDACAEhkL
        //////////wODIAIpAwAgA4eENwMAIAFBCGohAQwBCwsLbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYC
        ACADQSxqQQI2AgAgA0ICNwIMIANBlKjAADYCCCADQQI2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACE
        HAAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQbCqwAA2AgggA0
        ECNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBwAAtlAQJ/IAAgACgCACICQQhqIgM2AgAgACACQQN
        2QTxxakEoaiICIAFB/wFxIAIoAgBBCHRyNgIAAkACQCADRQRAIABBADYCACAAIAAoAgRBAWo2AgQMAQsgA0H/A3ENAQsg
        ABARCwtnAQF/IwBBgAJrIgMkACAAECogACABEJABIABBgAFqIgEgAhCQASAAQYACahCwASAAEKgBIAMgABAmIANBgAFqI
        AEQXiADQYABahAyIANBgAFqIAMQe0UEQCAAEJgBCyADQYACaiQAC18BAn8jAEGAAWsiASQAIAAQqAEgASAAEIUBIAFBQG
        sgAEFAayICEIUBIAEQAyABQUBrEAMgASABQUBrEHggAUEAEDQgACABEEggARBBIAEQRCACIAEQSCABQYABaiQAC10BAn8
        jAEFAaiIBJAAgAUEIakGgp8AAEF8gAUEIaiAAKAI4QX9qEDkiAhAtIAAgAUEIahBjIABBASACQQFqQR9xdCICNgI4IAJB
        gICAEE4EQCAAEBILIAFBQGskAAtfAgF/AX4jAEHwAGsiASQAIAFBoKfAABBfIAApAwAhAiABQThqIAAQXyAAQQEQOyABQ
        ThqIAEQYSABQThqEEQgAUE4akEBEDsgACABQThqIAJCAoGnEE8gAUHwAGokAAt7AQJ/IABBKGohAgNAIAFBgAJGBEAgAE
        LnzKfQ1tDrs7t/NwIIIABCADcCACAAQSBqQquzj/yRo7Pw2wA3AgAgAEEYakL/pLmIxZHagpt/NwIAIABBEGpC8ua746O
        n/aelfzcCAAUgASACakEANgIAIAFBBGohAQwBCwsLaQICfwF+IAAgACkDACIDQv//////////A4M3AwBBCCEBA0AgA0I6
        hyEDIAFBMEYEQCAAIAApAzAgA3w3AzAFIAAgAWoiAiACKQMAIAN8IgNC//////////8DgzcDACABQQhqIQEMAQsLC2oCA
        n8BfiAAIAApAwAiA0L//////////wODNwMAQQghAQNAIANCOochAyABQegARgRAIAAgACkDaCADfDcDaAUgACABaiICIA
        IpAwAgA3wiA0L//////////wODNwMAIAFBCGohAQwBCwsLWQEBfyMAQYADayIEJAAgBCADEF4gBBBAIARBgAFqIAEQXiA
        EQYACaiACEF4gBEGAAWogBBAPIARBgAJqIAQQDyAAIARBgAFqIARBgAJqEJEBIARBgANqJAALWQECfyMAQUBqIgEkAAJA
        IAAQhAENACABQQEQigEgAEGAAWoiAiABEFkNACACQQAQNCAAIAIQSCAAEBIgAEFAayIAIAIQSCAAEBIgAiABEKUBCyABQ
        UBrJAALVwEBfyMAQbABayICJAAgATQCOCAANAI4fkKAgIAQWQRAIAAQEgsgAkEIaiAAIAEQCCACQfgAaiACQQhqEAUgAC
        ACQfgAahBrIABBAjYCOCACQbABaiQAC08BAn8jAEFAaiIDJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByIABB+ABqQQE2AgA
        gAyABEIsBIAAgAxClASADIAIQiwEgAxClASADQUBrJAALWQECfyMAQYABayIBJAACQCAAEIgBDQAgARBQIABBgAJqIgIg
        ARB7DQAgAhBAIAAgAhAPIAAQqwEgAEGAAWoiACACEA8gABCrASACIAEQkAELIAFBgAFqJAALSwEBfyMAQUBqIgEkACAAQ
        TgQciIAQQE2AjggAUEBEIoBIABBQGsgAUHAABBnGiAAQYABakE4EHIaIABBuAFqQQE2AgAgAUFAayQAC0sBAn8jAEHwAG
        siASQAIAAQd0UEQCABQaCnwAAQXyABQThqIAAQgwEgASABQThqEGIgARBEIAFBOGogARA1IQILIAFB8ABqJAAgAgtPAQF
        /IwBBgAFrIgIkACAAIAEQhQEgABADIAJByABqQdikwAAQXyACQQhqIAJByABqEIsBIAAgARBIIAAgAkEIahB4IAAQEiAC
        QYABaiQAC0kBAn8DQCABQThGRQRAIAAgAWoiAiACKQMAQgGGNwMAIAFBCGohAQwBCwsgACAAKAI4QQF0IgE2AjggAUGAg
        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
        yAAEFYLNwAgABBRIAAgARCSASAAQYACaiABQYACahCSASAAQYAEaiABQYAEahCSASAAIAEoAoAGNgKABgsoAQF/A0AgAk
        E4RwRAIAAgAmogASACaikDADcDACACQQhqIQIMAQsLCzMAIAAgARCSASAAQYACaiABQYACahCSASAAQYAEaiABQYAEahC
        SASAAIAEoAoAGNgKABgsoACAAIAEgAhB5IABBQGsgAUFAayACEHkgAEGAAWogAUGAAWogAhB5Cy4BAX8jAEGAAWsiASQA
        IAAQLyABEFAgACABEJABIABBgAFqEKkBIAFBgAFqJAALLQAgACABIAIQjwEgAEGAAWogAUGAAWogAhCPASAAQYACaiABQ
        YACaiACEI8BCzQBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQaSowAA2AgQgAkH0qsAANgIAIAIQaAALPgEBfyMAQR
        BrIgEkACABQQhqIABBCGooAgA2AgAgASAAKQIANwMAIAEoAgAiAEEUaigCABogACgCBBoQMwALKQEBfyABBEAgACECA0A
        gAkEAOgAAIAJBAWohAiABQX9qIgENAAsLIAALKwEBfyMAQcABayICJAAgAhBLIAIgARB/IAIQpgEgACACEAwgAkHAAWok
        AAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCycBAX8jAEFAaiICJAAgAkEIaiABEF0gACACQQhqEIsBI
        AJBQGskAAsrACAAEFEgACABEJIBIABBgAJqIAIQkgEgAEGABGogAxCSASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEI
        UBIAEQEiABEFogAUFAayQACykAIAAgARBhIAAgACgCOCABKAI4aiIBNgI4IAFBgICAEE4EQCAAEBILCyUAIAAgASACEE8
        gAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLIwADQCACBEAgACABLQAAED4gAkF/aiECIAFBAWohAQwBCwsLIgACQCAA
        IAEQWUUNACAAQUBrIAFBQGsQWUUNAEEBDwtBAAskAAJAIABBfE0EQCAARQRAQQQhAAwCCyAAEAEiAA0BCwALIAALJwEBf
        yMAQYABayICJAAgAiABEF4gAhA6IAAgAhCVASACQYABaiQACycAIAAgARCQASAAQYABaiABQYABahCQASAAQYACaiABQY
        ACahCQAQslACAAIAEQpQEgAEFAayABQUBrEKUBIABBgAFqIAFBgAFqEKUBCyUBAX8jAEFAaiICJAAgAiABEIUBIAIQQSA
        AIAIQeCACQUBrJAALKAEBfyMAQYACayICJAAgAiABEI4BIAIQKyAAIAIQlgEgAkGAAmokAAsjAEGEAiACSQRAIAJBhAIg
        AxA9AAsgACACNgIEIAAgATYCAAsiAQF/IwBB8ABrIgIkACACIAEQMCAAIAIQBSACQfAAaiQACxwAAkAgABB3RQ0AIABBg
        AFqEHdFDQBBAQ8LQQALHwAgAEE4EHIiAEEBNgI4IAAgARBrIAAgASgCODYCOAseAAJAIAAQhwFFDQAgAEGAAWoQhwFFDQ
        BBAQ8LQQALGwACQCAAEHdFDQAgAEFAaxB3RQ0AQQEPC0EACx4AAkAgABCHAUUNACAAQYACahCHAUUNAEEBDwtBAAsaAQF
        /IAAQWCIBIABBQGsQWCABcyAAEHdxcwsaACAAQTgQciIAQQE2AjggACABEJ0BIAAQVgsZACAAQTgQciIAQQE2AjggACAB
        EGsgABBWCxcAIAAQRCAAKAIAQX8gAUEfcXRBf3NxCxoAIAAgARBfIAAgAhAkIAAgAhBjIAAgAhAkCxwAIAAQLyAAIAEQk
        AEgAEGAAWogAUGAAWoQkAELGAAgACABIAIQeSAAQUBrIAFBQGsgAhB5CxYAIAAgARClASAAQUBrIAFBQGsQpQELGAAgAB
        AvIAAgARCQASAAQYABaiACEJABCxgAIAAgARCQASAAQYABaiABQYABahCQAQsZACAAEK4BIABBgAJqELYBIABBgARqEK4
        BCxcAIAAQsgEgAEFAaxBpIABBgAFqELIBCxQAIAAgARB4IABBQGsgAUFAaxB4CxgAIAAgARCVASAAQYABaiABQYABahCV
        AQsYACAAEKYBIABBgAFqIgAQpgEgACABEA8LGQAgABCpASAAQYABahCwASAAQYACahCpAQsZACAAEKwBIABBgAJqEKwBI
        ABBgARqEKwBCxkAIAAQqgEgAEGAAmoQqgEgAEGABGoQqgELFgAgABAvIAAgARCQASAAQYABahCpAQsWACAAQYABaiIAEK
        gBIAAQOiAAEKgBCxQAIAAQRCAAIAApAwAgAax8NwMACxQAIAAQRCAAIAApAwAgAax9NwMACxEAIAAgARBSIABBQGsgARB
        SCxEAIAAgARBIIABBQGsgARBICxQAIAAgARCQASAAQYABaiACEJABCxIAIAAgARAPIABBgAFqIAEQDwsUACAAIAEQoAEg
        AEGAAWogARCgAQsRACAAKAIEBEAgACgCABAJCwsSACAAIAEQayAAIAEoAjg2AjgLDwAgAEFAayIAEEEgABBECw0AIAAQT
        iAAQUBrEE4LDQAgABBEIABBQGsQRAsPACAAELIBIABBQGsQsgELEAAgABCrASAAQYABahCrAQsNACAAEBIgAEFAaxASCx
        AAIAAQqAEgAEGAAWoQqAELEAAgABCpASAAQYABahCpAQsPACAAQYABahA6IAAQrAELEAAgABCnASAAQYABahCnAQsOACA
        AEGkgAEFAaxCyAQsQACAAIAI2AgQgACABNgIACw0AIAAQdCAAQQE2AjgLDAAgABBBIAAgARB4CwwAIAAgARBrIAAQVgsN
        ACAAEDogACABEJUBCwsAIAAQOiAAEKwBCwwAQunQotvMouq7RgsDAAELAwABCwv+PZoCAEGCgMAACwcBAAAAAQI0AEG4g
        MAAC9sBuF8jku11BwFjT+D5WE+pA2dPnKtLeD0Akew9ffXy9AMD1g8fDSwgAK1vjPCZwa4A8DtNkAEAAADzStxtEor3AI
        uwH1tTsFYDgvLFYx+X7AAysL/NHtseAkehVLifHyMCQHo6ogw4sQGz4sMPAAAAAHNyYy9ibHMxMjM4MS9wYWlyLnJzqAA
        QABQAAAAHAQAACQAAAKgAEAAUAAAADAEAAA0AAACoABAAFAAAABEBAAANAAAAAAAAAAEAAAD///8Dv/+W/78AaQM7VYAd
        moCAAefMIPV1pkwBp+1zAEGogsAACyz+//7///8BAosAgILYBPYB4Y1oiW++kwLOdqvfPagdAMZpulHOdt8Dy1nGFwBB4
        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
        qr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAABAEhAAFAAAABUBAAATAA
        AAQBIQABQAAAAeAQAAGAAAAEASEAAUAAAAJAEAABwAAABzcmMvYmxzMTIzODEvZWNwMi5ycwAAAAAEAEGQpcAAC7wGQBI
        QABQAAADmAgAACQAAAEASEAAUAAAA7gIAAA0AAABAEhAAFAAAAP4CAAAhAAAAuL0hwchWgAD1+24BqskAA7pwFz2uR7YA
        RNEK7ADpUwN65MZREMUtA0kBgkmkwiMALyuqJAAAAAB+KwRdBX2sAflVF+WERDwDNJME9ce9GwJp12rYgmRCA9BrWWVPJ
        4gA6DRrH9hnnAAFtgI+AQAAAAEouAiGVJMBeKIo6w5zsgIjyRINFpWmAQq1nU73MqoCm/2tGjUu2gJxczJjhFufAHdSXc
        4AAAAAvnlf8F8HqQJqaAc710nDAfOzmulytSoB0pm8jp0W+gEoPsuZi8IrAKw0qwwzzakDAkpsYAAAAACrqv/////+Ae7
        //1Ss//8C6kFiD2sPKgHDnP1KFM4TAkt3ZNesS0MC7enGkqb5XwKjHhGgAQAAAAgUEAALAAAAjwEAAA8AAAAIFBAACwAA
        AKcBAAATAAAACBQQAAsAAACqAQAADQAAAHNyYy9obWFjLnJzADQUEAAgAAAAVBQQABIAAAADAAAAAAAAAAEAAAAEAAAAa
        W5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAwMDAxMDIwMzA0MDUwNjA3MDgwOT
        EwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ
        0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5
        ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAAQBUQABAAAABQFRAAIgAAAHJhbmdlIGVuZCBpb
        mRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIG
        EgYE5vbmVgIHZhbHVlALAVEAAcAAAA7gEAAB4AAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzAEGIrMAACwEBAEH
        IrMAACwEBAEGIrcAACwEBAEHIrcAACwEBAEGIrsAACwEBAEHIrsAACwEBAEGIr8AACwEBAEHIr8AACwEBAEGIsMAACwEB
        AEHIsMAACwEBAEGIscAACwEBAEHIscAACwEBAEGIssAACwEBAEHIssAACwEBAEGIs8AACwEBAEHIs8AACwEBAEGItMAAC
        wEBAEHItMAACwEBAEGItcAACwEBAEHItcAACwEBAEGItsAACwEBAEHItsAACwEBAEGIt8AACwEBAEHIt8AACwEBAEGIuM
        AACwEBAEHIuMAACwEBAEGIucAACwEBAEHIucAACwEBAEGIusAACwEBAEHIusAACwEBAEGIu8AACwEBAEHIu8AACwEBAEG
        IvMAACwEBAEHIvMAACwEBAEGIvcAACwEBAEHIvcAACwEBAEGIvsAACwEBAEHIvsAACwEBAEGIv8AACwEBAEHIv8AACwEB
        AEGIwMAACwEBAEHIwMAACwEBAEGIwcAACwEBAEHIwcAACwEBAEGIwsAACwEBAEHIwsAACwEBAEGIw8AACwEBAEHIw8AAC
        wEBAEGIxMAACwEBAEHIxMAACwEBAEGIxcAACwEBAEHIxcAACwEBAEGIxsAACwEBAEHIxsAACwEBAEGIx8AACwEBAEHIx8
        AACwEBAEGIyMAACwEBAEHIyMAACwEBAEGIycAACwEBAEHIycAACwEBAEGIysAACwEBAEHIysAACwEBAEGIy8AACwEBAEH
        Iy8AACwEBAEGIzMAACwEBAEHIzMAACwEBAEGIzcAACwEBAEHIzcAACwEBAEGIzsAACwEBAEHIzsAACwEBAEGIz8AACwEB
        AEHIz8AACwEBAEGI0MAACwEBAEHI0MAACwEBAEGI0cAACwEBAEHI0cAACwEBAEGI0sAACwEBAEHI0sAACwEBAEGI08AAC
        wEBAEHI08AACwEBAEGI1MAACwEBAEHI1MAACwEBAEGI1cAACwEBAEHI1cAACwEBAEGI1sAACwEBAEHI1sAACwEBAEGI18
        AACwEBAEHI18AACwEBAEGI2MAACwEBAEHI2MAACwEBAEGI2cAACwEBAEHI2cAACwEBAEGI2sAACwEBAEHI2sAACwEBAEG
        I28AACwEBAEHI28AACwEBAEGI3MAACwEBAEHI3MAACwEBAEGI3cAACwEBAEHI3cAACwEBAEGI3sAACwEBAEHI3sAACwEB
        AEGI38AACwEBAEHI38AACwEBAEGI4MAACwEBAEHI4MAACwEBAEGI4cAACwEBAEHI4cAACwEBAEGI4sAACwEBAEHI4sAAC
        wEBAEGI48AACwEBAEHI48AACwEBAEGI5MAACwEBAEHI5MAACwEBAEGI5cAACwEBAEHI5cAACwEBAEGI5sAACwEBAEHI5s
        AACwEBAEGI58AACwEBAEHI58AACwEBAEGI6MAACwEBAEHI6MAACwEBAEGI6cAACwEBAEHI6cAACwEBAEGI6sAACwEBAEH
        I6sAACwEBAEGI68AACwEBAEHI68AACwEBAEGI7MAACwEBAEHI7MAACwEBAEGI7cAACwEBAEHI7cAACwEBAEGI7sAACwEB
        AEHI7sAACwEBAEGI78AACwEBAEHI78AACwEBAEGI8MAACwEBAEHI8MAACwEBAEGI8cAACwEBAEHI8cAACwEBAEGI8sAAC
        wEBAEHI8sAACwEBAEGI88AACwEBAEHI88AACwEBAEGI9MAACwEBAEHI9MAACwEBAEGI9cAACwEBAEHI9cAACwEBAEGI9s
        AACwEBAEHI9sAACwEBAEGI98AACwEBAEHI98AACwEBAEGI+MAACwEBAEHI+MAACwEBAEGI+cAACwEBAEHI+cAACwEBAEG
        I+sAACwEBAEHI+sAACwEBAEGI+8AACwEBAEHI+8AACwEBAEGI/MAACwEBAEHI/MAACwEBAEGI/cAACwEBAEHI/cAACwEB
        AEGI/sAACwEBAEHI/sAACwEBAEGI/8AACwEBAEHI/8AACwEBAEGIgMEACwEBAEHIgMEACwEBAEGIgcEACwEBAEHIgcEAC
        wEBAEGIgsEACwEBAEHIgsEACwEBAEGIg8EACwEBAEHIg8EACwEBAEGIhMEACwEBAEHIhMEACwEBAEGIhcEACwEBAEHIhc
        EACwEBAEGIhsEACwEBAEHIhsEACwEBAEGIh8EACwEBAEHIh8EACwEBAEGIiMEACwEBAEHIiMEACwEBAEGIicEACwEBAEH
        IicEACwEBAEGIisEACwEBAEHIisEACwEBAEGIi8EACwEBAEHIi8EACwEBAEGIjMEACwEBAEHIjMEACwEBAEGIjcEACwEB
        AEHIjcEACwEBAEGIjsEACwEBAEHIjsEACwEBAEGIj8EACwEBAEHIj8EACwEBAEGIkMEACwEBAEHIkMEACwEBAEGIkcEAC
        wEBAEHIkcEACwEBAEGIksEACwEBAEHIksEACwEBAEGIk8EACwEBAEHIk8EACwEBAEGIlMEACwEBAEHIlMEACwEBAEGIlc
        EACwEBAEHIlcEACwEBAEGIlsEACwEBAEHIlsEACwEBAEGIl8EACwEBAEHIl8EACwEBAEGImMEACwEBAEHImMEACwEBAEG
        ImcEACwEBAEHImcEACwEBAEGImsEACwEBAEHImsEACwEBAEGIm8EACwEBAEHIm8EACwEBAEGInMEACwEBAEHInMEACwEB
        AEGIncEACwEBAEHIncEACwEBAEGInsEACwEBAEHInsEACwEBAEGIn8EACwEBAEHIn8EACwEBAEGIoMEACwEBAEHIoMEAC
        wEBAEGIocEACwEBAEHIocEACwEBAEGIosEACwEBAEHIosEACwEBAEGIo8EACwEBAEHIo8EACwEBAEGIpMEACwEBAEHIpM
        EACwEBAEGIpcEACwEBAEHIpcEACwEBAEGIpsEACwEBAEHIpsEACwEBAEGIp8EACwEBAEHIp8EACwEBAEGIqMEACwEBAEH
        IqMEACwEBAEGIqcEACwEBAEHIqcEACwEBAEGIqsEACwEBAEHIqsEACwEBAEGIq8EACwEBAEHIq8EACwEBAEGIrMEACwEB
        AEHIrMEACwEBAEGIrcEACwEBAEHIrcEACwEBAEGIrsEACwEBAEHIrsEACwEBAEGIr8EACwEBAEHIr8EACwEBAEGIsMEAC
        wEBAEHIsMEACwEBAEGIscEACwEBAEHIscEACwEBAEGIssEACwEBAEHIssEACwEBAEGIs8EACwEBAEHIs8EACwEBAEGItM
        EACwEBAEHItMEACwEBAEGItcEACwEBAEHItcEACwEBAHsJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2V
        kLWJ5AwVydXN0Yx0xLjQ5LjAgKGUxODg0YThlMyAyMDIwLTEyLTI5KQZ3YWxydXMGMC4xOC4wDHdhc20tYmluZGdlbhIw
        LjIuNzAgKGI2MzU1YzI3MCk=
    `.replace(/[^0-9a-zA-Z/+]/g, '');
    const wasmBytes = base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__.decode(wasmBytesBase64);
    /**
     * @returns {number}
     */
    function bls_init() {
        let ret = wasm.bls_init();
        return ret;
    }
    let cachegetUint8Memory0 = null;
    function getUint8Memory0() {
        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachegetUint8Memory0;
    }
    function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1);
        getUint8Memory0().set(arg, ptr / 1);
        return [ptr, arg.length];
    }
    /**
     * @param {Uint8Array} sig
     * @param {Uint8Array} m
     * @param {Uint8Array} w
     * @returns {number}
     */
    function bls_verify(sig, m, w) {
        const [ptr0, len0] = passArray8ToWasm0(sig, wasm.__wbindgen_malloc);
        const [ptr1, len1] = passArray8ToWasm0(m, wasm.__wbindgen_malloc);
        const [ptr2, len2] = passArray8ToWasm0(w, wasm.__wbindgen_malloc);
        const ret = wasm.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
        return ret;
    }
    async function load(module, imports) {
        if (typeof Response === 'function' && module instanceof Response) {
            const bytes = await module.arrayBuffer();
            return await WebAssembly.instantiate(bytes, imports);
        }
        else {
            const instance = await WebAssembly.instantiate(module, imports);
            if (instance instanceof WebAssembly.Instance) {
                return { instance, module };
            }
            else {
                return instance;
            }
        }
    }
    async function init() {
        const imports = {};
        const { instance, module } = await load(wasmBytes, imports);
        wasm = instance.exports;
        init.__wbindgen_wasm_module = module;
        return wasm;
    }
    /**
     * If `module_or_path` is {RequestInfo} or {URL}, makes a request and
     * for everything else, calls `WebAssembly.instantiate` directly.
     *
     * @param {InitInput | Promise<InitInput>} module_or_path
     *
     * @returns {Promise<InitOutput>}
     */
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (init);
    //# sourceMappingURL=bls.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-core.js":
    /*!**********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-core.js ***!
      \**********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   InputBox: () => (/* binding */ InputBox),
    /* harmony export */   InputForm: () => (/* binding */ InputForm),
    /* harmony export */   OptionForm: () => (/* binding */ OptionForm),
    /* harmony export */   RecordForm: () => (/* binding */ RecordForm),
    /* harmony export */   TupleForm: () => (/* binding */ TupleForm),
    /* harmony export */   VariantForm: () => (/* binding */ VariantForm),
    /* harmony export */   VecForm: () => (/* binding */ VecForm)
    /* harmony export */ });
    class InputBox {
        constructor(idl, ui) {
            this.idl = idl;
            this.ui = ui;
            this.label = null;
            this.value = undefined;
            const status = document.createElement('span');
            status.className = 'status';
            this.status = status;
            if (ui.input) {
                ui.input.addEventListener('blur', () => {
                    if (ui.input.value === '') {
                        return;
                    }
                    this.parse();
                });
                ui.input.addEventListener('input', () => {
                    status.style.display = 'none';
                    ui.input.classList.remove('reject');
                });
            }
        }
        isRejected() {
            return this.value === undefined;
        }
        parse(config = {}) {
            if (this.ui.form) {
                const value = this.ui.form.parse(config);
                this.value = value;
                return value;
            }
            if (this.ui.input) {
                const input = this.ui.input;
                try {
                    const value = this.ui.parse(this.idl, config, input.value);
                    if (!this.idl.covariant(value)) {
                        throw new Error(`${input.value} is not of type ${this.idl.display()}`);
                    }
                    this.status.style.display = 'none';
                    this.value = value;
                    return value;
                }
                catch (err) {
                    input.classList.add('reject');
                    this.status.style.display = 'block';
                    this.status.innerHTML = 'InputError: ' + err.message;
                    this.value = undefined;
                    return undefined;
                }
            }
            return null;
        }
        render(dom) {
            const container = document.createElement('span');
            if (this.label) {
                const label = document.createElement('label');
                label.innerText = this.label;
                container.appendChild(label);
            }
            if (this.ui.input) {
                container.appendChild(this.ui.input);
                container.appendChild(this.status);
            }
            if (this.ui.form) {
                this.ui.form.render(container);
            }
            dom.appendChild(container);
        }
    }
    class InputForm {
        constructor(ui) {
            this.ui = ui;
            this.form = [];
        }
        renderForm(dom) {
            if (this.ui.container) {
                this.form.forEach(e => e.render(this.ui.container));
                dom.appendChild(this.ui.container);
            }
            else {
                this.form.forEach(e => e.render(dom));
            }
        }
        render(dom) {
            if (this.ui.open && this.ui.event) {
                dom.appendChild(this.ui.open);
                const form = this;
                // eslint-disable-next-line
                form.ui.open.addEventListener(form.ui.event, () => {
                    // Remove old form
                    if (form.ui.container) {
                        form.ui.container.innerHTML = '';
                    }
                    else {
                        const oldContainer = form.ui.open.nextElementSibling;
                        if (oldContainer) {
                            oldContainer.parentNode.removeChild(oldContainer);
                        }
                    }
                    // Render form
                    form.generateForm();
                    form.renderForm(dom);
                });
            }
            else {
                this.generateForm();
                this.renderForm(dom);
            }
        }
    }
    class RecordForm extends InputForm {
        constructor(fields, ui) {
            super(ui);
            this.fields = fields;
            this.ui = ui;
        }
        generateForm() {
            this.form = this.fields.map(([key, type]) => {
                const input = this.ui.render(type);
                // eslint-disable-next-line
                if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {
                    input.label = this.ui.labelMap[key] + ' ';
                }
                else {
                    input.label = key + ' ';
                }
                return input;
            });
        }
        parse(config) {
            const v = {};
            this.fields.forEach(([key, _], i) => {
                const value = this.form[i].parse(config);
                v[key] = value;
            });
            if (this.form.some(input => input.isRejected())) {
                return undefined;
            }
            return v;
        }
    }
    class TupleForm extends InputForm {
        constructor(components, ui) {
            super(ui);
            this.components = components;
            this.ui = ui;
        }
        generateForm() {
            this.form = this.components.map(type => {
                const input = this.ui.render(type);
                return input;
            });
        }
        parse(config) {
            const v = [];
            this.components.forEach((_, i) => {
                const value = this.form[i].parse(config);
                v.push(value);
            });
            if (this.form.some(input => input.isRejected())) {
                return undefined;
            }
            return v;
        }
    }
    class VariantForm extends InputForm {
        constructor(fields, ui) {
            super(ui);
            this.fields = fields;
            this.ui = ui;
        }
        generateForm() {
            const index = this.ui.open.selectedIndex;
            const [_, type] = this.fields[index];
            const variant = this.ui.render(type);
            this.form = [variant];
        }
        parse(config) {
            const select = this.ui.open;
            const selected = select.options[select.selectedIndex].value;
            const value = this.form[0].parse(config);
            if (value === undefined) {
                return undefined;
            }
            const v = {};
            v[selected] = value;
            return v;
        }
    }
    class OptionForm extends InputForm {
        constructor(ty, ui) {
            super(ui);
            this.ty = ty;
            this.ui = ui;
        }
        generateForm() {
            if (this.ui.open.checked) {
                const opt = this.ui.render(this.ty);
                this.form = [opt];
            }
            else {
                this.form = [];
            }
        }
        parse(config) {
            if (this.form.length === 0) {
                return [];
            }
            else {
                const value = this.form[0].parse(config);
                if (value === undefined) {
                    return undefined;
                }
                return [value];
            }
        }
    }
    class VecForm extends InputForm {
        constructor(ty, ui) {
            super(ui);
            this.ty = ty;
            this.ui = ui;
        }
        generateForm() {
            const len = +this.ui.open.value;
            this.form = [];
            for (let i = 0; i < len; i++) {
                const t = this.ui.render(this.ty);
                this.form.push(t);
            }
        }
        parse(config) {
            const value = this.form.map(input => {
                return input.parse(config);
            });
            if (this.form.some(input => input.isRejected())) {
                return undefined;
            }
            return value;
        }
    }
    //# sourceMappingURL=candid-core.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-ui.js":
    /*!********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-ui.js ***!
      \********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Render: () => (/* binding */ Render),
    /* harmony export */   inputBox: () => (/* binding */ inputBox),
    /* harmony export */   optForm: () => (/* binding */ optForm),
    /* harmony export */   recordForm: () => (/* binding */ recordForm),
    /* harmony export */   renderInput: () => (/* binding */ renderInput),
    /* harmony export */   renderValue: () => (/* binding */ renderValue),
    /* harmony export */   tupleForm: () => (/* binding */ tupleForm),
    /* harmony export */   variantForm: () => (/* binding */ variantForm),
    /* harmony export */   vecForm: () => (/* binding */ vecForm)
    /* harmony export */ });
    /* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./idl */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/idl.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./candid-core */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-core.js");
    
    
    
    const InputConfig = { parse: parsePrimitive };
    const FormConfig = { render: renderInput };
    const inputBox = (t, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.InputBox(t, Object.assign(Object.assign({}, InputConfig), config));
    };
    const recordForm = (fields, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));
    };
    const tupleForm = (components, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));
    };
    const variantForm = (fields, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));
    };
    const optForm = (ty, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));
    };
    const vecForm = (ty, config) => {
        return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));
    };
    class Render extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitType(t, d) {
            const input = document.createElement('input');
            input.classList.add('argument');
            input.placeholder = t.display();
            return inputBox(t, { input });
        }
        visitNull(t, d) {
            return inputBox(t, {});
        }
        visitRecord(t, fields, d) {
            let config = {};
            if (fields.length > 1) {
                const container = document.createElement('div');
                container.classList.add('popup-form');
                config = { container };
            }
            const form = recordForm(fields, config);
            return inputBox(t, { form });
        }
        visitTuple(t, components, d) {
            let config = {};
            if (components.length > 1) {
                const container = document.createElement('div');
                container.classList.add('popup-form');
                config = { container };
            }
            const form = tupleForm(components, config);
            return inputBox(t, { form });
        }
        visitVariant(t, fields, d) {
            const select = document.createElement('select');
            for (const [key, type] of fields) {
                const option = new Option(key);
                select.add(option);
            }
            select.selectedIndex = -1;
            select.classList.add('open');
            const config = { open: select, event: 'change' };
            const form = variantForm(fields, config);
            return inputBox(t, { form });
        }
        visitOpt(t, ty, d) {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.classList.add('open');
            const form = optForm(ty, { open: checkbox, event: 'change' });
            return inputBox(t, { form });
        }
        visitVec(t, ty, d) {
            const len = document.createElement('input');
            len.type = 'number';
            len.min = '0';
            len.max = '100';
            len.style.width = '8rem';
            len.placeholder = 'len';
            len.classList.add('open');
            const container = document.createElement('div');
            container.classList.add('popup-form');
            const form = vecForm(ty, { open: len, event: 'change', container });
            return inputBox(t, { form });
        }
        visitRec(t, ty, d) {
            return renderInput(ty);
        }
    }
    class Parse extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitNull(t, v) {
            return null;
        }
        visitBool(t, v) {
            if (v === 'true') {
                return true;
            }
            if (v === 'false') {
                return false;
            }
            throw new Error(`Cannot parse ${v} as boolean`);
        }
        visitText(t, v) {
            return v;
        }
        visitFloat(t, v) {
            return parseFloat(v);
        }
        visitNumber(t, v) {
            return BigInt(v);
        }
        visitPrincipal(t, v) {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);
        }
        visitService(t, v) {
            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);
        }
        visitFunc(t, v) {
            const x = v.split('.', 2);
            return [_dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(x[0]), x[1]];
        }
    }
    class Random extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitNull(t, v) {
            return null;
        }
        visitBool(t, v) {
            return Math.random() < 0.5;
        }
        visitText(t, v) {
            return Math.random().toString(36).substring(6);
        }
        visitFloat(t, v) {
            return Math.random();
        }
        visitInt(t, v) {
            return BigInt(this.generateNumber(true));
        }
        visitNat(t, v) {
            return BigInt(this.generateNumber(false));
        }
        visitFixedInt(t, v) {
            return BigInt(this.generateNumber(true));
        }
        visitFixedNat(t, v) {
            return BigInt(this.generateNumber(false));
        }
        generateNumber(signed) {
            const num = Math.floor(Math.random() * 100);
            if (signed && Math.random() < 0.5) {
                return -num;
            }
            else {
                return num;
            }
        }
    }
    function parsePrimitive(t, config, d) {
        if (config.random && d === '') {
            return t.accept(new Random(), d);
        }
        else {
            return t.accept(new Parse(), d);
        }
    }
    /**
     *
     * @param t an IDL type
     * @returns an input for that type
     */
    function renderInput(t) {
        return t.accept(new Render(), null);
    }
    /**
     *
     * @param t an IDL Type
     * @param input an InputBox
     * @param value any
     * @returns rendering that value to the provided input
     */
    function renderValue(t, input, value) {
        return t.accept(new RenderValue(), { input, value });
    }
    class RenderValue extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {
        visitType(t, d) {
            d.input.ui.input.value = t.valueToString(d.value);
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        visitNull(t, d) { }
        visitText(t, d) {
            d.input.ui.input.value = d.value;
        }
        visitRec(t, ty, d) {
            renderValue(ty, d.input, d.value);
        }
        visitOpt(t, ty, d) {
            if (d.value.length === 0) {
                return;
            }
            else {
                const form = d.input.ui.form;
                const open = form.ui.open;
                open.checked = true;
                open.dispatchEvent(new Event(form.ui.event));
                renderValue(ty, form.form[0], d.value[0]);
            }
        }
        visitRecord(t, fields, d) {
            const form = d.input.ui.form;
            fields.forEach(([key, type], i) => {
                renderValue(type, form.form[i], d.value[key]);
            });
        }
        visitTuple(t, components, d) {
            const form = d.input.ui.form;
            components.forEach((type, i) => {
                renderValue(type, form.form[i], d.value[i]);
            });
        }
        visitVariant(t, fields, d) {
            const form = d.input.ui.form;
            const selected = Object.entries(d.value)[0];
            fields.forEach(([key, type], i) => {
                if (key === selected[0]) {
                    const open = form.ui.open;
                    open.selectedIndex = i;
                    open.dispatchEvent(new Event(form.ui.event));
                    renderValue(type, form.form[0], selected[1]);
                }
            });
        }
        visitVec(t, ty, d) {
            const form = d.input.ui.form;
            const len = d.value.length;
            const open = form.ui.open;
            open.value = len;
            open.dispatchEvent(new Event(form.ui.event));
            d.value.forEach((v, i) => {
                renderValue(ty, form.form[i], v);
            });
        }
    }
    //# sourceMappingURL=candid-ui.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/idl.js":
    /*!**************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/idl.js ***!
      \**************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Bool: () => (/* binding */ Bool),
    /* harmony export */   BoolClass: () => (/* binding */ BoolClass),
    /* harmony export */   ConstructType: () => (/* binding */ ConstructType),
    /* harmony export */   Empty: () => (/* binding */ Empty),
    /* harmony export */   EmptyClass: () => (/* binding */ EmptyClass),
    /* harmony export */   FixedIntClass: () => (/* binding */ FixedIntClass),
    /* harmony export */   FixedNatClass: () => (/* binding */ FixedNatClass),
    /* harmony export */   Float32: () => (/* binding */ Float32),
    /* harmony export */   Float64: () => (/* binding */ Float64),
    /* harmony export */   FloatClass: () => (/* binding */ FloatClass),
    /* harmony export */   Func: () => (/* binding */ Func),
    /* harmony export */   FuncClass: () => (/* binding */ FuncClass),
    /* harmony export */   Int: () => (/* binding */ Int),
    /* harmony export */   Int16: () => (/* binding */ Int16),
    /* harmony export */   Int32: () => (/* binding */ Int32),
    /* harmony export */   Int64: () => (/* binding */ Int64),
    /* harmony export */   Int8: () => (/* binding */ Int8),
    /* harmony export */   IntClass: () => (/* binding */ IntClass),
    /* harmony export */   Nat: () => (/* binding */ Nat),
    /* harmony export */   Nat16: () => (/* binding */ Nat16),
    /* harmony export */   Nat32: () => (/* binding */ Nat32),
    /* harmony export */   Nat64: () => (/* binding */ Nat64),
    /* harmony export */   Nat8: () => (/* binding */ Nat8),
    /* harmony export */   NatClass: () => (/* binding */ NatClass),
    /* harmony export */   Null: () => (/* binding */ Null),
    /* harmony export */   NullClass: () => (/* binding */ NullClass),
    /* harmony export */   Opt: () => (/* binding */ Opt),
    /* harmony export */   OptClass: () => (/* binding */ OptClass),
    /* harmony export */   PrimitiveType: () => (/* binding */ PrimitiveType),
    /* harmony export */   Principal: () => (/* binding */ Principal),
    /* harmony export */   PrincipalClass: () => (/* binding */ PrincipalClass),
    /* harmony export */   Rec: () => (/* binding */ Rec),
    /* harmony export */   RecClass: () => (/* binding */ RecClass),
    /* harmony export */   Record: () => (/* binding */ Record),
    /* harmony export */   RecordClass: () => (/* binding */ RecordClass),
    /* harmony export */   Reserved: () => (/* binding */ Reserved),
    /* harmony export */   ReservedClass: () => (/* binding */ ReservedClass),
    /* harmony export */   Service: () => (/* binding */ Service),
    /* harmony export */   ServiceClass: () => (/* binding */ ServiceClass),
    /* harmony export */   Text: () => (/* binding */ Text),
    /* harmony export */   TextClass: () => (/* binding */ TextClass),
    /* harmony export */   Tuple: () => (/* binding */ Tuple),
    /* harmony export */   TupleClass: () => (/* binding */ TupleClass),
    /* harmony export */   Type: () => (/* binding */ Type),
    /* harmony export */   Variant: () => (/* binding */ Variant),
    /* harmony export */   VariantClass: () => (/* binding */ VariantClass),
    /* harmony export */   Vec: () => (/* binding */ Vec),
    /* harmony export */   VecClass: () => (/* binding */ VecClass),
    /* harmony export */   Visitor: () => (/* binding */ Visitor),
    /* harmony export */   decode: () => (/* binding */ decode),
    /* harmony export */   encode: () => (/* binding */ encode)
    /* harmony export */ });
    /* harmony import */ var buffer_pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer-pipe */ "./node_modules/buffer-pipe/index.js");
    /* harmony import */ var buffer_pipe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer_pipe__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dfinity/principal */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js");
    /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/types.js");
    /* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/hash */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js");
    /* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/leb128 */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js");
    // tslint:disable:max-classes-per-file
    
    
    
    
    
    
    
    const magicNumber = 'DIDL';
    function zipWith(xs, ys, f) {
        return xs.map((x, i) => f(x, ys[i]));
    }
    /**
     * An IDL Type Table, which precedes the data in the stream.
     */
    class TypeTable {
        constructor() {
            // List of types. Needs to be an array as the index needs to be stable.
            this._typs = [];
            this._idx = new Map();
        }
        has(obj) {
            return this._idx.has(obj.name);
        }
        add(type, buf) {
            const idx = this._typs.length;
            this._idx.set(type.name, idx);
            this._typs.push(buf);
        }
        merge(obj, knot) {
            const idx = this._idx.get(obj.name);
            const knotIdx = this._idx.get(knot);
            if (idx === undefined) {
                throw new Error('Missing type index for ' + obj);
            }
            if (knotIdx === undefined) {
                throw new Error('Missing type index for ' + knot);
            }
            this._typs[idx] = this._typs[knotIdx];
            // Delete the type.
            this._typs.splice(knotIdx, 1);
            this._idx.delete(knot);
        }
        encode() {
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this._typs.length);
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(this._typs);
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([len, buf]);
        }
        indexOf(typeName) {
            if (!this._idx.has(typeName)) {
                throw new Error('Missing type index for ' + typeName);
            }
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(this._idx.get(typeName) || 0);
        }
    }
    class Visitor {
        visitType(t, data) {
            throw new Error('Not implemented');
        }
        visitPrimitive(t, data) {
            return this.visitType(t, data);
        }
        visitEmpty(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitBool(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitNull(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitReserved(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitText(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitNumber(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitInt(t, data) {
            return this.visitNumber(t, data);
        }
        visitNat(t, data) {
            return this.visitNumber(t, data);
        }
        visitFloat(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitFixedInt(t, data) {
            return this.visitNumber(t, data);
        }
        visitFixedNat(t, data) {
            return this.visitNumber(t, data);
        }
        visitPrincipal(t, data) {
            return this.visitPrimitive(t, data);
        }
        visitConstruct(t, data) {
            return this.visitType(t, data);
        }
        visitVec(t, ty, data) {
            return this.visitConstruct(t, data);
        }
        visitOpt(t, ty, data) {
            return this.visitConstruct(t, data);
        }
        visitRecord(t, fields, data) {
            return this.visitConstruct(t, data);
        }
        visitTuple(t, components, data) {
            const fields = components.map((ty, i) => [`_${i}_`, ty]);
            return this.visitRecord(t, fields, data);
        }
        visitVariant(t, fields, data) {
            return this.visitConstruct(t, data);
        }
        visitRec(t, ty, data) {
            return this.visitConstruct(ty, data);
        }
        visitFunc(t, data) {
            return this.visitConstruct(t, data);
        }
        visitService(t, data) {
            return this.visitConstruct(t, data);
        }
    }
    /**
     * Represents an IDL type.
     */
    class Type {
        /* Display type name */
        display() {
            return this.name;
        }
        valueToString(x) {
            return toReadableString(x);
        }
        /* Implement `T` in the IDL spec, only needed for non-primitive types */
        buildTypeTable(typeTable) {
            if (!typeTable.has(this)) {
                this._buildTypeTableImpl(typeTable);
            }
        }
    }
    class PrimitiveType extends Type {
        checkType(t) {
            if (this.name !== t.name) {
                throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);
            }
            return t;
        }
        _buildTypeTableImpl(typeTable) {
            // No type table encoding for Primitive types.
            return;
        }
    }
    class ConstructType extends Type {
        checkType(t) {
            if (t instanceof RecClass) {
                const ty = t.getType();
                if (typeof ty === 'undefined') {
                    throw new Error('type mismatch with uninitialized type');
                }
                return ty;
            }
            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);
        }
        encodeType(typeTable) {
            return typeTable.indexOf(this.name);
        }
    }
    /**
     * Represents an IDL Empty, a type which has no inhabitants.
     * Since no values exist for this type, it cannot be serialised or deserialised.
     * Result types like `Result<Text, Empty>` should always succeed.
     */
    class EmptyClass extends PrimitiveType {
        accept(v, d) {
            return v.visitEmpty(this, d);
        }
        covariant(x) {
            return false;
        }
        encodeValue() {
            throw new Error('Empty cannot appear as a function argument');
        }
        valueToString() {
            throw new Error('Empty cannot appear as a value');
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-17 /* Empty */);
        }
        decodeValue() {
            throw new Error('Empty cannot appear as an output');
        }
        get name() {
            return 'empty';
        }
    }
    /**
     * Represents an IDL Bool
     */
    class BoolClass extends PrimitiveType {
        accept(v, d) {
            return v.visitBool(this, d);
        }
        covariant(x) {
            return typeof x === 'boolean';
        }
        encodeValue(x) {
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(1);
            buf.writeInt8(x ? 1 : 0, 0);
            return buf;
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-2 /* Bool */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, 1).toString('hex');
            if (x === '00') {
                return false;
            }
            else if (x === '01') {
                return true;
            }
            else {
                throw new Error('Boolean value out of range');
            }
        }
        get name() {
            return 'bool';
        }
    }
    /**
     * Represents an IDL Null
     */
    class NullClass extends PrimitiveType {
        accept(v, d) {
            return v.visitNull(this, d);
        }
        covariant(x) {
            return x === null;
        }
        encodeValue() {
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(0);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-1 /* Null */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return null;
        }
        get name() {
            return 'null';
        }
    }
    /**
     * Represents an IDL Reserved
     */
    class ReservedClass extends PrimitiveType {
        accept(v, d) {
            return v.visitReserved(this, d);
        }
        covariant(x) {
            return true;
        }
        encodeValue() {
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(0);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-16 /* Reserved */);
        }
        decodeValue(b, t) {
            if (t.name !== this.name) {
                t.decodeValue(b, t);
            }
            return null;
        }
        get name() {
            return 'reserved';
        }
    }
    function isValidUTF8(buf) {
        return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.compare(new buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer(buf.toString(), 'utf8'), buf) === 0;
    }
    /**
     * Represents an IDL Text
     */
    class TextClass extends PrimitiveType {
        accept(v, d) {
            return v.visitText(this, d);
        }
        covariant(x) {
            return typeof x === 'string';
        }
        encodeValue(x) {
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(x, 'utf8');
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(buf.length);
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([len, buf]);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-15 /* Text */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(b);
            const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, Number(len));
            if (!isValidUTF8(buf)) {
                throw new Error('Not valid UTF8 text');
            }
            return buf.toString('utf8');
        }
        get name() {
            return 'text';
        }
        valueToString(x) {
            return '"' + x + '"';
        }
    }
    /**
     * Represents an IDL Int
     */
    class IntClass extends PrimitiveType {
        accept(v, d) {
            return v.visitInt(this, d);
        }
        covariant(x) {
            // We allow encoding of JavaScript plain numbers.
            // But we will always decode to bigint.
            return typeof x === 'bigint' || Number.isInteger(x);
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(x);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-4 /* Int */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(b);
        }
        get name() {
            return 'int';
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL Nat
     */
    class NatClass extends PrimitiveType {
        accept(v, d) {
            return v.visitNat(this, d);
        }
        covariant(x) {
            // We allow encoding of JavaScript plain numbers.
            // But we will always decode to bigint.
            return (typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0);
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(x);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-3 /* Nat */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(b);
        }
        get name() {
            return 'nat';
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL Float
     */
    class FloatClass extends PrimitiveType {
        constructor(_bits) {
            super();
            this._bits = _bits;
            if (_bits !== 32 && _bits !== 64) {
                throw new Error('not a valid float type');
            }
        }
        accept(v, d) {
            return v.visitFloat(this, d);
        }
        covariant(x) {
            return typeof x === 'number' || x instanceof Number;
        }
        encodeValue(x) {
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.allocUnsafe(this._bits / 8);
            if (this._bits === 32) {
                buf.writeFloatLE(x, 0);
            }
            else {
                buf.writeDoubleLE(x, 0);
            }
            return buf;
        }
        encodeType() {
            const opcode = this._bits === 32 ? -13 /* Float32 */ : -14 /* Float64 */;
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(opcode);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, this._bits / 8);
            if (this._bits === 32) {
                return x.readFloatLE(0);
            }
            else {
                return x.readDoubleLE(0);
            }
        }
        get name() {
            return 'float' + this._bits;
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL fixed-width Int(n)
     */
    class FixedIntClass extends PrimitiveType {
        constructor(_bits) {
            super();
            this._bits = _bits;
        }
        accept(v, d) {
            return v.visitFixedInt(this, d);
        }
        covariant(x) {
            const min = BigInt(2) ** BigInt(this._bits - 1) * BigInt(-1);
            const max = BigInt(2) ** BigInt(this._bits - 1) - BigInt(1);
            if (typeof x === 'bigint') {
                return x >= min && x <= max;
            }
            else if (Number.isInteger(x)) {
                const v = BigInt(x);
                return v >= min && v <= max;
            }
            else {
                return false;
            }
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.writeIntLE)(x, this._bits / 8);
        }
        encodeType() {
            const offset = Math.log2(this._bits) - 3;
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-9 - offset);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.readIntLE)(b, this._bits / 8);
            if (this._bits <= 32) {
                return Number(num);
            }
            else {
                return num;
            }
        }
        get name() {
            return `int${this._bits}`;
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL fixed-width Nat(n)
     */
    class FixedNatClass extends PrimitiveType {
        constructor(bits) {
            super();
            this.bits = bits;
        }
        accept(v, d) {
            return v.visitFixedNat(this, d);
        }
        covariant(x) {
            const max = BigInt(2) ** BigInt(this.bits);
            if (typeof x === 'bigint' && x >= BigInt(0)) {
                return x < max;
            }
            else if (Number.isInteger(x) && x >= 0) {
                const v = BigInt(x);
                return v < max;
            }
            else {
                return false;
            }
        }
        encodeValue(x) {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.writeUIntLE)(x, this.bits / 8);
        }
        encodeType() {
            const offset = Math.log2(this.bits) - 3;
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-5 - offset);
        }
        decodeValue(b, t) {
            this.checkType(t);
            const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.readUIntLE)(b, this.bits / 8);
            if (this.bits <= 32) {
                return Number(num);
            }
            else {
                return num;
            }
        }
        get name() {
            return `nat${this.bits}`;
        }
        valueToString(x) {
            return x.toString();
        }
    }
    /**
     * Represents an IDL Array
     * @param {Type} t
     */
    class VecClass extends ConstructType {
        constructor(_type) {
            super();
            this._type = _type;
            // If true, this vector is really a blob and we can just use memcpy.
            this._blobOptimization = false;
            if (_type instanceof FixedNatClass && _type.bits === 8) {
                this._blobOptimization = true;
            }
        }
        accept(v, d) {
            return v.visitVec(this, this._type, d);
        }
        covariant(x) {
            return Array.isArray(x) && x.every(v => this._type.covariant(v));
        }
        encodeValue(x) {
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(x.length);
            if (this._blobOptimization) {
                return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([len, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(x)]);
            }
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([len, ...x.map(d => this._type.encodeValue(d))]);
        }
        _buildTypeTableImpl(typeTable) {
            this._type.buildTypeTable(typeTable);
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-19 /* Vector */);
            const buffer = this._type.encodeType(typeTable);
            typeTable.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([opCode, buffer]));
        }
        decodeValue(b, t) {
            const vec = this.checkType(t);
            if (!(vec instanceof VecClass)) {
                throw new Error('Not a vector type');
            }
            const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(b));
            if (this._blobOptimization) {
                return [...new Uint8Array(b.read(len))];
            }
            const rets = [];
            for (let i = 0; i < len; i++) {
                rets.push(this._type.decodeValue(b, vec._type));
            }
            return rets;
        }
        get name() {
            return `vec ${this._type.name}`;
        }
        display() {
            return `vec ${this._type.display()}`;
        }
        valueToString(x) {
            const elements = x.map(e => this._type.valueToString(e));
            return 'vec {' + elements.join('; ') + '}';
        }
    }
    /**
     * Represents an IDL Option
     * @param {Type} t
     */
    class OptClass extends ConstructType {
        constructor(_type) {
            super();
            this._type = _type;
        }
        accept(v, d) {
            return v.visitOpt(this, this._type, d);
        }
        covariant(x) {
            return Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0])));
        }
        encodeValue(x) {
            if (x.length === 0) {
                return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([0]);
            }
            else {
                return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([1]), this._type.encodeValue(x[0])]);
            }
        }
        _buildTypeTableImpl(typeTable) {
            this._type.buildTypeTable(typeTable);
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-18 /* Opt */);
            const buffer = this._type.encodeType(typeTable);
            typeTable.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([opCode, buffer]));
        }
        decodeValue(b, t) {
            const opt = this.checkType(t);
            if (!(opt instanceof OptClass)) {
                throw new Error('Not an option type');
            }
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, 1).toString('hex');
            if (len === '00') {
                return [];
            }
            else if (len === '01') {
                return [this._type.decodeValue(b, opt._type)];
            }
            else {
                throw new Error('Not an option value');
            }
        }
        get name() {
            return `opt ${this._type.name}`;
        }
        display() {
            return `opt ${this._type.display()}`;
        }
        valueToString(x) {
            if (x.length === 0) {
                return 'null';
            }
            else {
                return `opt ${this._type.valueToString(x[0])}`;
            }
        }
    }
    /**
     * Represents an IDL Record
     * @param {Object} [fields] - mapping of function name to Type
     */
    class RecordClass extends ConstructType {
        constructor(fields = {}) {
            super();
            this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(b[0]));
        }
        accept(v, d) {
            return v.visitRecord(this, this._fields, d);
        }
        tryAsTuple() {
            const res = [];
            for (let i = 0; i < this._fields.length; i++) {
                const [key, type] = this._fields[i];
                if (key !== `_${i}_`) {
                    return null;
                }
                res.push(type);
            }
            return res;
        }
        covariant(x) {
            return (typeof x === 'object' &&
                this._fields.every(([k, t]) => {
                    // eslint-disable-next-line
                    if (!x.hasOwnProperty(k)) {
                        throw new Error(`Record is missing key "${k}".`);
                    }
                    return t.covariant(x[k]);
                }));
        }
        encodeValue(x) {
            const values = this._fields.map(([key]) => x[key]);
            const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(bufs);
        }
        _buildTypeTableImpl(T) {
            this._fields.forEach(([_, value]) => value.buildTypeTable(T));
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-20 /* Record */);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this._fields.length);
            const fields = this._fields.map(([key, value]) => buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([(0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(key)), value.encodeType(T)]));
            T.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([opCode, len, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(fields)]));
        }
        decodeValue(b, t) {
            const record = this.checkType(t);
            if (!(record instanceof RecordClass)) {
                throw new Error('Not a record type');
            }
            const x = {};
            let idx = 0;
            for (const [hash, type] of record._fields) {
                if (idx >= this._fields.length || (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(this._fields[idx][0]) !== (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(hash)) {
                    // skip field
                    type.decodeValue(b, type);
                    continue;
                }
                const [expectKey, expectType] = this._fields[idx];
                x[expectKey] = expectType.decodeValue(b, type);
                idx++;
            }
            if (idx < this._fields.length) {
                throw new Error('Cannot find field ' + this._fields[idx][0]);
            }
            return x;
        }
        get name() {
            const fields = this._fields.map(([key, value]) => key + ':' + value.name);
            return `record {${fields.join('; ')}}`;
        }
        display() {
            const fields = this._fields.map(([key, value]) => key + ':' + value.display());
            return `record {${fields.join('; ')}}`;
        }
        valueToString(x) {
            const values = this._fields.map(([key]) => x[key]);
            const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));
            return `record {${fields.join('; ')}}`;
        }
    }
    /**
     * Represents Tuple, a syntactic sugar for Record.
     * @param {Type} components
     */
    class TupleClass extends RecordClass {
        constructor(_components) {
            const x = {};
            _components.forEach((e, i) => (x['_' + i + '_'] = e));
            super(x);
            this._components = _components;
        }
        accept(v, d) {
            return v.visitTuple(this, this._components, d);
        }
        covariant(x) {
            // `>=` because tuples can be covariant when encoded.
            return (Array.isArray(x) &&
                x.length >= this._fields.length &&
                this._components.every((t, i) => t.covariant(x[i])));
        }
        encodeValue(x) {
            const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(bufs);
        }
        decodeValue(b, t) {
            const tuple = this.checkType(t);
            if (!(tuple instanceof TupleClass)) {
                throw new Error('not a tuple type');
            }
            if (tuple._components.length < this._components.length) {
                throw new Error('tuple mismatch');
            }
            const res = [];
            for (const [i, wireType] of tuple._components.entries()) {
                if (i >= this._components.length) {
                    // skip value
                    wireType.decodeValue(b, wireType);
                }
                else {
                    res.push(this._components[i].decodeValue(b, wireType));
                }
            }
            return res;
        }
        display() {
            const fields = this._components.map(value => value.display());
            return `record {${fields.join('; ')}}`;
        }
        valueToString(values) {
            const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));
            return `record {${fields.join('; ')}}`;
        }
    }
    /**
     * Represents an IDL Variant
     * @param {Object} [fields] - mapping of function name to Type
     */
    class VariantClass extends ConstructType {
        constructor(fields = {}) {
            super();
            this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(b[0]));
        }
        accept(v, d) {
            return v.visitVariant(this, this._fields, d);
        }
        covariant(x) {
            return (typeof x === 'object' &&
                Object.entries(x).length === 1 &&
                this._fields.every(([k, v]) => {
                    // eslint-disable-next-line
                    return !x.hasOwnProperty(k) || v.covariant(x[k]);
                }));
        }
        encodeValue(x) {
            for (let i = 0; i < this._fields.length; i++) {
                const [name, type] = this._fields[i];
                // eslint-disable-next-line
                if (x.hasOwnProperty(name)) {
                    const idx = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(i);
                    const buf = type.encodeValue(x[name]);
                    return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([idx, buf]);
                }
            }
            throw Error('Variant has no data: ' + x);
        }
        _buildTypeTableImpl(typeTable) {
            this._fields.forEach(([, type]) => {
                type.buildTypeTable(typeTable);
            });
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-21 /* Variant */);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this._fields.length);
            const fields = this._fields.map(([key, value]) => buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([(0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(key)), value.encodeType(typeTable)]));
            typeTable.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([opCode, len, ...fields]));
        }
        decodeValue(b, t) {
            const variant = this.checkType(t);
            if (!(variant instanceof VariantClass)) {
                throw new Error('Not a variant type');
            }
            const idx = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(b));
            if (idx >= variant._fields.length) {
                throw Error('Invalid variant index: ' + idx);
            }
            const [wireHash, wireType] = variant._fields[idx];
            for (const [key, expectType] of this._fields) {
                if ((0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(wireHash) === (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(key)) {
                    const value = expectType.decodeValue(b, wireType);
                    return { [key]: value };
                }
            }
            throw new Error('Cannot find field hash ' + wireHash);
        }
        get name() {
            const fields = this._fields.map(([key, type]) => key + ':' + type.name);
            return `variant {${fields.join('; ')}}`;
        }
        display() {
            const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));
            return `variant {${fields.join('; ')}}`;
        }
        valueToString(x) {
            for (const [name, type] of this._fields) {
                // eslint-disable-next-line
                if (x.hasOwnProperty(name)) {
                    const value = type.valueToString(x[name]);
                    if (value === 'null') {
                        return `variant {${name}}`;
                    }
                    else {
                        return `variant {${name}=${value}}`;
                    }
                }
            }
            throw new Error('Variant has no data: ' + x);
        }
    }
    /**
     * Represents a reference to an IDL type, used for defining recursive data
     * types.
     */
    class RecClass extends ConstructType {
        constructor() {
            super(...arguments);
            this._id = RecClass._counter++;
            this._type = undefined;
        }
        accept(v, d) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return v.visitRec(this, this._type, d);
        }
        fill(t) {
            this._type = t;
        }
        getType() {
            return this._type;
        }
        covariant(x) {
            return this._type ? this._type.covariant(x) : false;
        }
        encodeValue(x) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return this._type.encodeValue(x);
        }
        _buildTypeTableImpl(typeTable) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            typeTable.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(0));
            this._type.buildTypeTable(typeTable);
            typeTable.merge(this, this._type.name);
        }
        decodeValue(b, t) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return this._type.decodeValue(b, t);
        }
        get name() {
            return `rec_${this._id}`;
        }
        display() {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return `${this.name}.${this._type.name}`;
        }
        valueToString(x) {
            if (!this._type) {
                throw Error('Recursive type uninitialized.');
            }
            return this._type.valueToString(x);
        }
    }
    RecClass._counter = 0;
    function decodePrincipalId(b) {
        const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, 1).toString('hex');
        if (x !== '01') {
            throw new Error('Cannot decode principal');
        }
        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(b));
        const hex = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, len).toString('hex').toUpperCase();
        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_2__.Principal.fromHex(hex);
    }
    /**
     * Represents an IDL principal reference
     */
    class PrincipalClass extends PrimitiveType {
        accept(v, d) {
            return v.visitPrincipal(this, d);
        }
        covariant(x) {
            return x && x._isPrincipal;
        }
        encodeValue(x) {
            const hex = x.toHex();
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(hex, 'hex');
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(buf.length);
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([1]), len, buf]);
        }
        encodeType() {
            return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-24 /* Principal */);
        }
        decodeValue(b, t) {
            this.checkType(t);
            return decodePrincipalId(b);
        }
        get name() {
            return 'principal';
        }
        valueToString(x) {
            return `${this.name} "${x.toText()}"`;
        }
    }
    /**
     * Represents an IDL function reference.
     * @param argTypes Argument types.
     * @param retTypes Return types.
     * @param annotations Function annotations.
     */
    class FuncClass extends ConstructType {
        constructor(argTypes, retTypes, annotations = []) {
            super();
            this.argTypes = argTypes;
            this.retTypes = retTypes;
            this.annotations = annotations;
        }
        static argsToString(types, v) {
            if (types.length !== v.length) {
                throw new Error('arity mismatch');
            }
            return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';
        }
        accept(v, d) {
            return v.visitFunc(this, d);
        }
        covariant(x) {
            return (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string');
        }
        encodeValue(x) {
            const hex = x[0].toHex();
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(hex, 'hex');
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(buf.length);
            const canister = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([1]), len, buf]);
            const method = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(x[1], 'utf8');
            const methodLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(method.length);
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([1]), canister, methodLen, method]);
        }
        _buildTypeTableImpl(T) {
            this.argTypes.forEach(arg => arg.buildTypeTable(T));
            this.retTypes.forEach(arg => arg.buildTypeTable(T));
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-22 /* Func */);
            const argLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this.argTypes.length);
            const args = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(this.argTypes.map(arg => arg.encodeType(T)));
            const retLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this.retTypes.length);
            const rets = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(this.retTypes.map(arg => arg.encodeType(T)));
            const annLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this.annotations.length);
            const anns = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(this.annotations.map(a => this.encodeAnnotation(a)));
            T.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([opCode, argLen, args, retLen, rets, annLen, anns]));
        }
        decodeValue(b) {
            const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, 1).toString('hex');
            if (x !== '01') {
                throw new Error('Cannot decode function reference');
            }
            const canister = decodePrincipalId(b);
            const mLen = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(b));
            const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, mLen);
            if (!isValidUTF8(buf)) {
                throw new Error('Not valid UTF8 method name');
            }
            const method = buf.toString('utf8');
            return [canister, method];
        }
        get name() {
            const args = this.argTypes.map(arg => arg.name).join(', ');
            const rets = this.retTypes.map(arg => arg.name).join(', ');
            const annon = ' ' + this.annotations.join(' ');
            return `(${args}) -> (${rets})${annon}`;
        }
        valueToString([principal, str]) {
            return `func "${principal.toText()}".${str}`;
        }
        display() {
            const args = this.argTypes.map(arg => arg.display()).join(', ');
            const rets = this.retTypes.map(arg => arg.display()).join(', ');
            const annon = ' ' + this.annotations.join(' ');
            return `(${args})  (${rets})${annon}`;
        }
        encodeAnnotation(ann) {
            if (ann === 'query') {
                return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([1]);
            }
            else if (ann === 'oneway') {
                return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([2]);
            }
            else {
                throw new Error('Illeagal function annotation');
            }
        }
    }
    class ServiceClass extends ConstructType {
        constructor(fields) {
            super();
            this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_4__.idlLabelToId)(b[0]));
        }
        accept(v, d) {
            return v.visitService(this, d);
        }
        covariant(x) {
            return x && x._isPrincipal;
        }
        encodeValue(x) {
            const hex = x.toHex();
            const buf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(hex, 'hex');
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(buf.length);
            return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from([1]), len, buf]);
        }
        _buildTypeTableImpl(T) {
            this._fields.forEach(([_, func]) => func.buildTypeTable(T));
            const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebEncode)(-23 /* Service */);
            const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(this._fields.length);
            const meths = this._fields.map(([label, func]) => {
                const labelBuf = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(label, 'utf8');
                const labelLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(labelBuf.length);
                return buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([labelLen, labelBuf, func.encodeType(T)]);
            });
            T.add(this, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([opCode, len, buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(meths)]));
        }
        decodeValue(b) {
            return decodePrincipalId(b);
        }
        get name() {
            const fields = this._fields.map(([key, value]) => key + ':' + value.name);
            return `service {${fields.join('; ')}}`;
        }
        valueToString(x) {
            return `service "${x.toText()}"`;
        }
    }
    /**
     *
     * @param x
     * @returns {string}
     */
    function toReadableString(x) {
        return JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);
    }
    /**
     * Encode a array of values
     * @returns {Buffer} serialised value
     */
    function encode(argTypes, args) {
        if (args.length < argTypes.length) {
            throw Error('Wrong number of message arguments');
        }
        const typeTable = new TypeTable();
        argTypes.forEach(t => t.buildTypeTable(typeTable));
        const magic = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(magicNumber, 'utf8');
        const table = typeTable.encode();
        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebEncode)(args.length);
        const typs = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(argTypes.map(t => t.encodeType(typeTable)));
        const vals = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(zipWith(argTypes, args, (t, x) => {
            if (!t.covariant(x)) {
                throw new Error(`Invalid ${t.display()} argument: ${toReadableString(x)}`);
            }
            return t.encodeValue(x);
        }));
        return (0,_types__WEBPACK_IMPORTED_MODULE_3__.blobFromBuffer)(buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([magic, table, len, typs, vals]));
    }
    /**
     * Decode a binary value
     * @param retTypes - Types expected in the buffer.
     * @param bytes - hex-encoded string, or buffer.
     * @returns Value deserialised to JS type
     */
    function decode(retTypes, bytes) {
        const b = new (buffer_pipe__WEBPACK_IMPORTED_MODULE_0___default())(bytes);
        if (bytes.byteLength < magicNumber.length) {
            throw new Error('Message length smaller than magic number');
        }
        const magic = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(b, magicNumber.length).toString();
        if (magic !== magicNumber) {
            throw new Error('Wrong magic number: ' + magic);
        }
        function readTypeTable(pipe) {
            const typeTable = [];
            const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
            for (let i = 0; i < len; i++) {
                const ty = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(pipe));
                switch (ty) {
                    case -18 /* Opt */:
                    case -19 /* Vector */: {
                        const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(pipe));
                        typeTable.push([ty, t]);
                        break;
                    }
                    case -20 /* Record */:
                    case -21 /* Variant */: {
                        const fields = [];
                        let objectLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
                        let prevHash;
                        while (objectLength--) {
                            const hash = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
                            if (hash >= Math.pow(2, 32)) {
                                throw new Error('field id out of 32-bit range');
                            }
                            if (typeof prevHash === 'number' && prevHash >= hash) {
                                throw new Error('field id collision or not sorted');
                            }
                            prevHash = hash;
                            const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(pipe));
                            fields.push([hash, t]);
                        }
                        typeTable.push([ty, fields]);
                        break;
                    }
                    case -22 /* Func */: {
                        for (let k = 0; k < 2; k++) {
                            let funcLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
                            while (funcLength--) {
                                (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(pipe);
                            }
                        }
                        const annLen = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
                        (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(pipe, annLen);
                        typeTable.push([ty, undefined]);
                        break;
                    }
                    case -23 /* Service */: {
                        let servLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
                        while (servLength--) {
                            const l = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
                            (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.safeRead)(pipe, l);
                            (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(pipe);
                        }
                        typeTable.push([ty, undefined]);
                        break;
                    }
                    default:
                        throw new Error('Illegal op_code: ' + ty);
                }
            }
            const rawList = [];
            const length = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.lebDecode)(pipe));
            for (let i = 0; i < length; i++) {
                rawList.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_5__.slebDecode)(pipe)));
            }
            return [typeTable, rawList];
        }
        const [rawTable, rawTypes] = readTypeTable(b);
        if (rawTypes.length < retTypes.length) {
            throw new Error('Wrong number of return values');
        }
        const table = rawTable.map(_ => Rec());
        function getType(t) {
            if (t < -24) {
                throw new Error('future value not supported');
            }
            if (t < 0) {
                switch (t) {
                    case -1:
                        return Null;
                    case -2:
                        return Bool;
                    case -3:
                        return Nat;
                    case -4:
                        return Int;
                    case -5:
                        return Nat8;
                    case -6:
                        return Nat16;
                    case -7:
                        return Nat32;
                    case -8:
                        return Nat64;
                    case -9:
                        return Int8;
                    case -10:
                        return Int16;
                    case -11:
                        return Int32;
                    case -12:
                        return Int64;
                    case -13:
                        return Float32;
                    case -14:
                        return Float64;
                    case -15:
                        return Text;
                    case -16:
                        return Reserved;
                    case -17:
                        return Empty;
                    case -24:
                        return Principal;
                    default:
                        throw new Error('Illegal op_code: ' + t);
                }
            }
            if (t >= rawTable.length) {
                throw new Error('type index out of range');
            }
            return table[t];
        }
        function buildType(entry) {
            switch (entry[0]) {
                case -19 /* Vector */: {
                    const ty = getType(entry[1]);
                    return Vec(ty);
                }
                case -18 /* Opt */: {
                    const ty = getType(entry[1]);
                    return Opt(ty);
                }
                case -20 /* Record */: {
                    const fields = {};
                    for (const [hash, ty] of entry[1]) {
                        const name = `_${hash}_`;
                        fields[name] = getType(ty);
                    }
                    const record = Record(fields);
                    const tuple = record.tryAsTuple();
                    if (Array.isArray(tuple)) {
                        return Tuple(...tuple);
                    }
                    else {
                        return record;
                    }
                }
                case -21 /* Variant */: {
                    const fields = {};
                    for (const [hash, ty] of entry[1]) {
                        const name = `_${hash}_`;
                        fields[name] = getType(ty);
                    }
                    return Variant(fields);
                }
                case -22 /* Func */: {
                    return Func([], [], []);
                }
                case -23 /* Service */: {
                    return Service({});
                }
                default:
                    throw new Error('Illegal op_code: ' + entry[0]);
            }
        }
        rawTable.forEach((entry, i) => {
            const t = buildType(entry);
            table[i].fill(t);
        });
        const types = rawTypes.map(t => getType(t));
        const output = retTypes.map((t, i) => {
            return t.decodeValue(b, types[i]);
        });
        // skip unused values
        for (let ind = retTypes.length; ind < types.length; ind++) {
            types[ind].decodeValue(b, types[ind]);
        }
        if (b.buffer.length > 0) {
            throw new Error('decode: Left-over bytes');
        }
        return output;
    }
    // Export Types instances.
    const Empty = new EmptyClass();
    const Reserved = new ReservedClass();
    const Bool = new BoolClass();
    const Null = new NullClass();
    const Text = new TextClass();
    const Int = new IntClass();
    const Nat = new NatClass();
    const Float32 = new FloatClass(32);
    const Float64 = new FloatClass(64);
    const Int8 = new FixedIntClass(8);
    const Int16 = new FixedIntClass(16);
    const Int32 = new FixedIntClass(32);
    const Int64 = new FixedIntClass(64);
    const Nat8 = new FixedNatClass(8);
    const Nat16 = new FixedNatClass(16);
    const Nat32 = new FixedNatClass(32);
    const Nat64 = new FixedNatClass(64);
    const Principal = new PrincipalClass();
    /**
     *
     * @param types array of any types
     * @returns TupleClass from those types
     */
    function Tuple(...types) {
        return new TupleClass(types);
    }
    /**
     *
     * @param t IDL Type
     * @returns VecClass from that type
     */
    function Vec(t) {
        return new VecClass(t);
    }
    /**
     *
     * @param t IDL Type
     * @returns OptClass of Type
     */
    function Opt(t) {
        return new OptClass(t);
    }
    /**
     *
     * @param t Record of string and IDL Type
     * @returns RecordClass of string and Type
     */
    function Record(t) {
        return new RecordClass(t);
    }
    /**
     *
     * @param fields Record of string and IDL Type
     * @returns VariantClass
     */
    function Variant(fields) {
        return new VariantClass(fields);
    }
    /**
     *
     * @returns new RecClass
     */
    function Rec() {
        return new RecClass();
    }
    /**
     *
     * @param args array of IDL Types
     * @param ret array of IDL Types
     * @param annotations array of strings, [] by default
     * @returns new FuncClass
     */
    function Func(args, ret, annotations = []) {
        return new FuncClass(args, ret, annotations);
    }
    /**
     *
     * @param t Record of string and FuncClass
     * @returns ServiceClass
     */
    function Service(t) {
        return new ServiceClass(t);
    }
    //# sourceMappingURL=idl.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js":
    /*!****************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/index.js ***!
      \****************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   IDL: () => (/* reexport module object */ _idl__WEBPACK_IMPORTED_MODULE_2__),
    /* harmony export */   InputBox: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputBox),
    /* harmony export */   InputForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputForm),
    /* harmony export */   OptionForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.OptionForm),
    /* harmony export */   RecordForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.RecordForm),
    /* harmony export */   Render: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.Render),
    /* harmony export */   TupleForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.TupleForm),
    /* harmony export */   VariantForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VariantForm),
    /* harmony export */   VecForm: () => (/* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VecForm),
    /* harmony export */   blobFromBuffer: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobFromBuffer),
    /* harmony export */   blobFromHex: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobFromHex),
    /* harmony export */   blobFromText: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobFromText),
    /* harmony export */   blobFromUint32Array: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobFromUint32Array),
    /* harmony export */   blobFromUint8Array: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobFromUint8Array),
    /* harmony export */   blobToHex: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobToHex),
    /* harmony export */   blobToUint8Array: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.blobToUint8Array),
    /* harmony export */   derBlobFromBlob: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.derBlobFromBlob),
    /* harmony export */   idlLabelToId: () => (/* reexport safe */ _utils_hash__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId),
    /* harmony export */   inputBox: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.inputBox),
    /* harmony export */   lebDecode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebDecode),
    /* harmony export */   lebEncode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebEncode),
    /* harmony export */   makeNonce: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_5__.makeNonce),
    /* harmony export */   optForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.optForm),
    /* harmony export */   readIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readIntLE),
    /* harmony export */   readUIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readUIntLE),
    /* harmony export */   recordForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.recordForm),
    /* harmony export */   renderInput: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderInput),
    /* harmony export */   renderValue: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderValue),
    /* harmony export */   safeRead: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeRead),
    /* harmony export */   slebDecode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebDecode),
    /* harmony export */   slebEncode: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebEncode),
    /* harmony export */   tupleForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.tupleForm),
    /* harmony export */   variantForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.variantForm),
    /* harmony export */   vecForm: () => (/* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.vecForm),
    /* harmony export */   writeIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeIntLE),
    /* harmony export */   writeUIntLE: () => (/* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeUIntLE)
    /* harmony export */ });
    /* harmony import */ var _candid_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candid-ui */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-ui.js");
    /* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./candid-core */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/candid-core.js");
    /* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/idl.js");
    /* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/hash */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js");
    /* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/leb128 */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js");
    /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/types.js");
    
    
    
    
    
    
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/types.js":
    /*!****************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/types.js ***!
      \****************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   blobFromBuffer: () => (/* binding */ blobFromBuffer),
    /* harmony export */   blobFromHex: () => (/* binding */ blobFromHex),
    /* harmony export */   blobFromText: () => (/* binding */ blobFromText),
    /* harmony export */   blobFromUint32Array: () => (/* binding */ blobFromUint32Array),
    /* harmony export */   blobFromUint8Array: () => (/* binding */ blobFromUint8Array),
    /* harmony export */   blobToHex: () => (/* binding */ blobToHex),
    /* harmony export */   blobToUint8Array: () => (/* binding */ blobToUint8Array),
    /* harmony export */   derBlobFromBlob: () => (/* binding */ derBlobFromBlob),
    /* harmony export */   makeNonce: () => (/* binding */ makeNonce)
    /* harmony export */ });
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    /* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/leb128 */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js");
    /* eslint-disable @typescript-eslint/no-empty-interface */
    /* eslint-disable jsdoc/require-jsdoc */
    
    
    function blobFromBuffer(b) {
        return b;
    }
    function blobFromUint8Array(arr) {
        return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);
    }
    function blobFromText(text) {
        return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(text);
    }
    function blobFromUint32Array(arr) {
        return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);
    }
    function derBlobFromBlob(blob) {
        return blob;
    }
    function blobFromHex(hex) {
        return buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, 'hex');
    }
    function blobToHex(blob) {
        return blob.toString('hex');
    }
    function blobToUint8Array(blob) {
        return new Uint8Array(blob.slice(0, blob.byteLength));
    }
    /**
     * Create a random Nonce, based on date and a random suffix.
     */
    function makeNonce() {
        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_1__.lebEncode)(BigInt(+Date.now()) * BigInt(100000) + BigInt(Math.floor(Math.random() * 100000)));
    }
    //# sourceMappingURL=types.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js":
    /*!*********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/hash.js ***!
      \*********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   idlLabelToId: () => (/* binding */ idlLabelToId)
    /* harmony export */ });
    /**
     * Hashes a string to a number. Algorithm can be found here:
     * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf
     * @param s
     */
    function idlHash(s) {
        const utf8encoder = new TextEncoder();
        const array = utf8encoder.encode(s);
        let h = 0;
        for (const c of array) {
            h = (h * 223 + c) % 2 ** 32;
        }
        return h;
    }
    /**
     *
     * @param label string
     * @returns number representing hashed label
     */
    function idlLabelToId(label) {
        if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
            const num = +label.slice(1, -1);
            if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
                return num;
            }
        }
        return idlHash(label);
    }
    //# sourceMappingURL=hash.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js":
    /*!***********************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/candid/lib/esm/utils/leb128.js ***!
      \***********************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   lebDecode: () => (/* binding */ lebDecode),
    /* harmony export */   lebEncode: () => (/* binding */ lebEncode),
    /* harmony export */   readIntLE: () => (/* binding */ readIntLE),
    /* harmony export */   readUIntLE: () => (/* binding */ readUIntLE),
    /* harmony export */   safeRead: () => (/* binding */ safeRead),
    /* harmony export */   slebDecode: () => (/* binding */ slebDecode),
    /* harmony export */   slebEncode: () => (/* binding */ slebEncode),
    /* harmony export */   writeIntLE: () => (/* binding */ writeIntLE),
    /* harmony export */   writeUIntLE: () => (/* binding */ writeUIntLE)
    /* harmony export */ });
    /* harmony import */ var buffer_pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer-pipe */ "./node_modules/buffer-pipe/index.js");
    /* harmony import */ var buffer_pipe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer_pipe__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");
    
    
    /**
     *
     * @param pipe Pipe from buffer-pipe
     * @param num number
     * @returns Buffer
     */
    function safeRead(pipe, num) {
        if (pipe.buffer.length < num) {
            throw new Error('unexpected end of buffer');
        }
        return pipe.read(num);
    }
    /**
     * Encode a positive number (or bigint) into a Buffer. The number will be floored to the
     * nearest integer.
     * @param value The number to encode.
     */
    function lebEncode(value) {
        if (typeof value === 'number') {
            value = BigInt(value);
        }
        if (value < BigInt(0)) {
            throw new Error('Cannot leb encode negative values.');
        }
        const pipe = new (buffer_pipe__WEBPACK_IMPORTED_MODULE_0___default())();
        while (true) {
            const i = Number(value & BigInt(0x7f));
            value /= BigInt(0x80);
            if (value === BigInt(0)) {
                pipe.write([i]);
                break;
            }
            else {
                pipe.write([i | 0x80]);
            }
        }
        return new buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer(pipe.buffer);
    }
    /**
     * Decode a leb encoded buffer into a bigint. The number will always be positive (does not
     * support signed leb encoding).
     * @param pipe A Buffer containing the leb encoded bits.
     */
    function lebDecode(pipe) {
        let weight = BigInt(1);
        let value = BigInt(0);
        let byte;
        do {
            byte = safeRead(pipe, 1)[0];
            value += BigInt(byte & 0x7f).valueOf() * weight;
            weight *= BigInt(128);
        } while (byte >= 0x80);
        return value;
    }
    /**
     * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number
     * will be floored to the nearest integer.
     * @param value The number to encode.
     */
    function slebEncode(value) {
        if (typeof value === 'number') {
            value = BigInt(value);
        }
        const isNeg = value < BigInt(0);
        if (isNeg) {
            value = -value - BigInt(1);
        }
        const pipe = new (buffer_pipe__WEBPACK_IMPORTED_MODULE_0___default())();
        while (true) {
            const i = getLowerBytes(value);
            value /= BigInt(0x80);
            // prettier-ignore
            if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)
                || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {
                pipe.write([i]);
                break;
            }
            else {
                pipe.write([i | 0x80]);
            }
        }
        function getLowerBytes(num) {
            const bytes = num % BigInt(0x80);
            if (isNeg) {
                // We swap the bits here again, and remove 1 to do two's complement.
                return Number(BigInt(0x80) - bytes - BigInt(1));
            }
            else {
                return Number(bytes);
            }
        }
        return new buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer(pipe.buffer);
    }
    /**
     * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative
     * signed-leb encoding.
     * @param pipe A Buffer containing the signed leb encoded bits.
     */
    function slebDecode(pipe) {
        // Get the size of the buffer, then cut a buffer of that size.
        const pipeView = new Uint8Array(pipe.buffer);
        let len = 0;
        for (; len < pipeView.byteLength; len++) {
            if (pipeView[len] < 0x80) {
                // If it's a positive number, we reuse lebDecode.
                if ((pipeView[len] & 0x40) === 0) {
                    return lebDecode(pipe);
                }
                break;
            }
        }
        const bytes = new Uint8Array(safeRead(pipe, len + 1));
        let value = BigInt(0);
        for (let i = bytes.byteLength - 1; i >= 0; i--) {
            value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);
        }
        return -value - BigInt(1);
    }
    /**
     *
     * @param value bigint or number
     * @param byteLength number
     * @returns Buffer
     */
    function writeUIntLE(value, byteLength) {
        if (BigInt(value) < BigInt(0)) {
            throw new Error('Cannot write negative values.');
        }
        return writeIntLE(value, byteLength);
    }
    /**
     *
     * @param value bigint | number
     * @param byteLength number
     * @returns Buffer
     */
    function writeIntLE(value, byteLength) {
        value = BigInt(value);
        const pipe = new (buffer_pipe__WEBPACK_IMPORTED_MODULE_0___default())();
        let i = 0;
        let mul = BigInt(256);
        let sub = BigInt(0);
        let byte = Number(value % mul);
        pipe.write([byte]);
        while (++i < byteLength) {
            if (value < 0 && sub === BigInt(0) && byte !== 0) {
                sub = BigInt(1);
            }
            byte = Number((value / mul - sub) % BigInt(256));
            pipe.write([byte]);
            mul *= BigInt(256);
        }
        return new buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer(pipe.buffer);
    }
    /**
     *
     * @param pipe Pipe from buffer-pipe
     * @param byteLength number
     * @returns bigint
     */
    function readUIntLE(pipe, byteLength) {
        let val = BigInt(safeRead(pipe, 1)[0]);
        let mul = BigInt(1);
        let i = 0;
        while (++i < byteLength) {
            mul *= BigInt(256);
            const byte = BigInt(safeRead(pipe, 1)[0]);
            val = val + mul * byte;
        }
        return val;
    }
    /**
     *
     * @param pipe Pipe from buffer-pipe
     * @param byteLength number
     * @returns bigint
     */
    function readIntLE(pipe, byteLength) {
        let val = readUIntLE(pipe, byteLength);
        const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));
        if (val >= mul) {
            val -= mul * BigInt(2);
        }
        return val;
    }
    //# sourceMappingURL=leb128.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js":
    /*!*******************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/index.js ***!
      \*******************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Principal: () => (/* binding */ Principal)
    /* harmony export */ });
    /* harmony import */ var _utils_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/base32 */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js");
    /* harmony import */ var _utils_getCrc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getCrc */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js");
    /* harmony import */ var _utils_sha224__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/sha224 */ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/sha224.js");
    /* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
    
    
    
    const SELF_AUTHENTICATING_SUFFIX = 2;
    const ANONYMOUS_SUFFIX = 4;
    const fromHexString = (hexString) => { var _a; return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))); };
    const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
    class Principal {
        constructor(_arr) {
            this._arr = _arr;
            this._isPrincipal = true;
        }
        static anonymous() {
            return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
        }
        static selfAuthenticating(publicKey) {
            const sha = (0,_utils_sha224__WEBPACK_IMPORTED_MODULE_2__.sha224)(publicKey);
            return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));
        }
        static from(other) {
            if (typeof other === 'string') {
                return Principal.fromText(other);
            }
            else if (typeof other === 'object' &&
                other !== null &&
                other._isPrincipal === true) {
                return new Principal(other._arr);
            }
            throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
        }
        static fromHex(hex) {
            return new this(fromHexString(hex));
        }
        static fromText(text) {
            const canisterIdNoDash = text.toLowerCase().replace(/-/g, '');
            let arr = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.decode)(canisterIdNoDash);
            arr = arr.slice(4, arr.length);
            const principal = new this(arr);
            if (principal.toText() !== text) {
                throw new Error(`Principal "${principal.toText()}" does not have a valid checksum.`);
            }
            return principal;
        }
        static fromUint8Array(arr) {
            return new this(arr);
        }
        isAnonymous() {
            return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
        }
        toUint8Array() {
            return this._arr;
        }
        toHex() {
            return toHexString(this._arr).toUpperCase();
        }
        toText() {
            const checksumArrayBuf = new ArrayBuffer(4);
            const view = new DataView(checksumArrayBuf);
            view.setUint32(0, (0,_utils_getCrc__WEBPACK_IMPORTED_MODULE_1__.getCrc32)(this._arr));
            const checksum = Uint8Array.from(Buffer.from(checksumArrayBuf));
            const bytes = Uint8Array.from(this._arr);
            const array = new Uint8Array([...checksum, ...bytes]);
            const result = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.encode)(array);
            const matches = result.match(/.{1,5}/g);
            if (!matches) {
                // This should only happen if there's no character, which is unreachable.
                throw new Error();
            }
            return matches.join('-');
        }
        toString() {
            return this.toText();
        }
    }
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/base32.js ***!
      \**************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   decode: () => (/* binding */ decode),
    /* harmony export */   encode: () => (/* binding */ encode)
    /* harmony export */ });
    // tslint:disable:no-bitwise
    const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
    // Build a lookup table for decoding.
    const lookupTable = Object.create(null);
    for (let i = 0; i < alphabet.length; i++) {
        lookupTable[alphabet[i]] = i;
    }
    // Add aliases for rfc4648.
    lookupTable['0'] = lookupTable.o;
    lookupTable['1'] = lookupTable.i;
    /**
     * @param input The input array to encode.
     * @returns A Base32 string encoding the input.
     */
    function encode(input) {
        // How many bits will we skip from the first byte.
        let skip = 0;
        // 5 high bits, carry from one byte to the next.
        let bits = 0;
        // The output string in base32.
        let output = '';
        function encodeByte(byte) {
            if (skip < 0) {
                // we have a carry from the previous byte
                bits |= byte >> -skip;
            }
            else {
                // no carry
                bits = (byte << skip) & 248;
            }
            if (skip > 3) {
                // Not enough data to produce a character, get us another one
                skip -= 8;
                return 1;
            }
            if (skip < 4) {
                // produce a character
                output += alphabet[bits >> 3];
                skip += 5;
            }
            return 0;
        }
        for (let i = 0; i < input.length;) {
            i += encodeByte(input[i]);
        }
        return output + (skip < 0 ? alphabet[bits >> 3] : '');
    }
    /**
     * @param input The base32 encoded string to decode.
     */
    function decode(input) {
        // how many bits we have from the previous character.
        let skip = 0;
        // current byte we're producing.
        let byte = 0;
        const output = new Uint8Array(((input.length * 4) / 3) | 0);
        let o = 0;
        function decodeChar(char) {
            // Consume a character from the stream, store
            // the output in this.output. As before, better
            // to use update().
            let val = lookupTable[char.toLowerCase()];
            if (val === undefined) {
                throw new Error(`Invalid character: ${JSON.stringify(char)}`);
            }
            // move to the high bits
            val <<= 3;
            byte |= val >>> skip;
            skip += 5;
            if (skip >= 8) {
                // We have enough bytes to produce an output
                output[o++] = byte;
                skip -= 8;
                if (skip > 0) {
                    byte = (val << (5 - skip)) & 255;
                }
                else {
                    byte = 0;
                }
            }
        }
        for (const c of input) {
            decodeChar(c);
        }
        return output.slice(0, o);
    }
    //# sourceMappingURL=base32.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js ***!
      \**************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   getCrc32: () => (/* binding */ getCrc32)
    /* harmony export */ });
    // tslint:disable:no-bitwise
    // This file is translated to JavaScript from
    // https://lxp32.github.io/docs/a-simple-example-crc32-calculation/
    const lookUpTable = new Uint32Array([
        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
        0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
        0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
        0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
        0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
        0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
        0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
        0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
        0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
        0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
        0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
        0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
        0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
        0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
        0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
        0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
        0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
        0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
        0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
        0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
        0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
        0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
    ]);
    /**
     * Calculate the CRC32 of an ArrayBufferLike.
     * @param buf The BufferLike to calculate the CRC32 of.
     */
    function getCrc32(buf) {
        const b = new Uint8Array(buf);
        let crc = -1;
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < b.length; i++) {
            const byte = b[i];
            const t = (byte ^ crc) & 0xff;
            crc = lookUpTable[t] ^ (crc >>> 8);
        }
        return (crc ^ -1) >>> 0;
    }
    //# sourceMappingURL=getCrc.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/sha224.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/@psychedelic/dab-js/node_modules/@dfinity/principal/lib/esm/utils/sha224.js ***!
      \**************************************************************************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   sha224: () => (/* binding */ sha224)
    /* harmony export */ });
    /* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha256 */ "./node_modules/js-sha256/src/sha256.js");
    /* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha256__WEBPACK_IMPORTED_MODULE_0__);
    
    /**
     *
     * @param data Arraybuffer to encode
     * @returns sha244-encoded BinaryBlob
     */
    function sha224(data) {
        const shaObj = js_sha256__WEBPACK_IMPORTED_MODULE_0__.sha224.create();
        shaObj.update(data);
        return new Uint8Array(shaObj.array());
    }
    //# sourceMappingURL=sha224.js.map
    
    /***/ }),
    
    /***/ "./node_modules/axios/index.js":
    /*!*************************************!*\
      !*** ./node_modules/axios/index.js ***!
      \*************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/adapters/xhr.js":
    /*!************************************************!*\
      !*** ./node_modules/axios/lib/adapters/xhr.js ***!
      \************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
    var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
    var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
    var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
    var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
    var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
    var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
    var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
    var Cancel = __webpack_require__(/*! ../cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
    
          if (config.signal) {
            config.signal.removeEventListener('abort', onCanceled);
          }
        }
    
        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }
    
        var request = new XMLHttpRequest();
    
        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }
    
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    
        // Set the request timeout in MS
        request.timeout = config.timeout;
    
        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
            request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };
    
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
    
          // Clean up request
          request = null;
        }
    
        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
    
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }
    
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
    
          reject(createError('Request aborted', config, 'ECONNABORTED', request));
    
          // Clean up request
          request = null;
        };
    
        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));
    
          // Clean up request
          request = null;
        };
    
        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
            request));
    
          // Clean up request
          request = null;
        };
    
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;
    
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
    
        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }
    
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
    
        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }
    
        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }
    
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }
    
        if (config.cancelToken || config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
            request.abort();
            request = null;
          };
    
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
          }
        }
    
        if (!requestData) {
          requestData = null;
        }
    
        // Send the request
        request.send(requestData);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/axios.js":
    /*!*****************************************!*\
      !*** ./node_modules/axios/lib/axios.js ***!
      \*****************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
    var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
    var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
    var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
    var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
    
      // Copy axios.prototype to instance
      utils.extend(instance, Axios.prototype, context);
    
      // Copy context to instance
      utils.extend(instance, context);
    
      // Factory for creating new instances
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
    
      return instance;
    }
    
    // Create the default instance to be exported
    var axios = createInstance(defaults);
    
    // Expose Axios class to allow class inheritance
    axios.Axios = Axios;
    
    // Expose Cancel & CancelToken
    axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
    axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
    axios.VERSION = (__webpack_require__(/*! ./env/data */ "./node_modules/axios/lib/env/data.js").version);
    
    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");
    
    // Expose isAxiosError
    axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");
    
    module.exports = axios;
    
    // Allow use of default import syntax in TypeScript
    module.exports["default"] = axios;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/Cancel.js":
    /*!*************************************************!*\
      !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
      \*************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }
    
    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };
    
    Cancel.prototype.__CANCEL__ = true;
    
    module.exports = Cancel;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/CancelToken.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
      \******************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    
    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }
    
      var resolvePromise;
    
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
    
      var token = this;
    
      // eslint-disable-next-line func-names
      this.promise.then(function(cancel) {
        if (!token._listeners) return;
    
        var i;
        var l = token._listeners.length;
    
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
    
      // eslint-disable-next-line func-names
      this.promise.then = function(onfulfilled) {
        var _resolve;
        // eslint-disable-next-line func-names
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
    
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
    
        return promise;
      };
    
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }
    
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    
    /**
     * Subscribe to the cancel signal
     */
    
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
    
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    
    /**
     * Unsubscribe from the cancel signal
     */
    
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };
    
    module.exports = CancelToken;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/isCancel.js":
    /*!***************************************************!*\
      !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
      \***************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/Axios.js":
    /*!**********************************************!*\
      !*** ./node_modules/axios/lib/core/Axios.js ***!
      \**********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
    var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
    var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
    var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
    var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");
    
    var validators = validator.validators;
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    
    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
    
      config = mergeConfig(this.defaults, config);
    
      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }
    
      var transitional = config.transitional;
    
      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
    
      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }
    
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
    
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
    
      var promise;
    
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, undefined];
    
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
    
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
    
        return promise;
      }
    
    
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
    
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
    
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
    
      return promise;
    };
    
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };
    
    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });
    
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });
    
    module.exports = Axios;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/InterceptorManager.js":
    /*!***********************************************************!*\
      !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
      \***********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    function InterceptorManager() {
      this.handlers = [];
    }
    
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    
    module.exports = InterceptorManager;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/buildFullPath.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
      \******************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
    var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
    
    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/createError.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/core/createError.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
    
    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/dispatchRequest.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
      \********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
    var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
    var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
    var Cancel = __webpack_require__(/*! ../cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    
      if (config.signal && config.signal.aborted) {
        throw new Cancel('canceled');
      }
    }
    
    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
    
      // Ensure headers exist
      config.headers = config.headers || {};
    
      // Transform request data
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
    
      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
    
      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
    
      var adapter = config.adapter || defaults.adapter;
    
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
    
        // Transform response data
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
    
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
    
          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
    
        return Promise.reject(reason);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/enhanceError.js":
    /*!*****************************************************!*\
      !*** ./node_modules/axios/lib/core/enhanceError.js ***!
      \*****************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
    
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
    
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/mergeConfig.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
    
    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    module.exports = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};
    
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
    
      // eslint-disable-next-line consistent-return
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(undefined, config1[prop]);
        }
      }
    
      // eslint-disable-next-line consistent-return
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(undefined, config2[prop]);
        }
      }
    
      // eslint-disable-next-line consistent-return
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(undefined, config1[prop]);
        }
      }
    
      // eslint-disable-next-line consistent-return
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(undefined, config1[prop]);
        }
      }
    
      var mergeMap = {
        'url': valueFromConfig2,
        'method': valueFromConfig2,
        'data': valueFromConfig2,
        'baseURL': defaultToConfig2,
        'transformRequest': defaultToConfig2,
        'transformResponse': defaultToConfig2,
        'paramsSerializer': defaultToConfig2,
        'timeout': defaultToConfig2,
        'timeoutMessage': defaultToConfig2,
        'withCredentials': defaultToConfig2,
        'adapter': defaultToConfig2,
        'responseType': defaultToConfig2,
        'xsrfCookieName': defaultToConfig2,
        'xsrfHeaderName': defaultToConfig2,
        'onUploadProgress': defaultToConfig2,
        'onDownloadProgress': defaultToConfig2,
        'decompress': defaultToConfig2,
        'maxContentLength': defaultToConfig2,
        'maxBodyLength': defaultToConfig2,
        'transport': defaultToConfig2,
        'httpAgent': defaultToConfig2,
        'httpsAgent': defaultToConfig2,
        'cancelToken': defaultToConfig2,
        'socketPath': defaultToConfig2,
        'responseEncoding': defaultToConfig2,
        'validateStatus': mergeDirectKeys
      };
    
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
      });
    
      return config;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/settle.js":
    /*!***********************************************!*\
      !*** ./node_modules/axios/lib/core/settle.js ***!
      \***********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
    
    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/transformData.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/core/transformData.js ***!
      \******************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
    
      return data;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/defaults.js":
    /*!********************************************!*\
      !*** ./node_modules/axios/lib/defaults.js ***!
      \********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    /* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
    
    
    var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
    var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
    var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
    
    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };
    
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }
    
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
      }
      return adapter;
    }
    
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }
    
      return (encoder || JSON.stringify)(rawValue);
    }
    
    var defaults = {
    
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
    
      adapter: getDefaultAdapter(),
    
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
    
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      }],
    
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';
    
        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }
    
        return data;
      }],
    
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
    
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    
      maxContentLength: -1,
      maxBodyLength: -1,
    
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
    
      headers: {
        common: {
          'Accept': 'application/json, text/plain, */*'
        }
      }
    };
    
    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    
    module.exports = defaults;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/env/data.js":
    /*!********************************************!*\
      !*** ./node_modules/axios/lib/env/data.js ***!
      \********************************************/
    /***/ ((module) => {
    
    module.exports = {
      "version": "0.24.0"
    };
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/bind.js":
    /*!************************************************!*\
      !*** ./node_modules/axios/lib/helpers/bind.js ***!
      \************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/buildURL.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }
    
    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    module.exports = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }
    
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
    
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }
    
          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }
    
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });
    
        serializedParams = parts.join('&');
      }
    
      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
    
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }
    
      return url;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/combineURLs.js":
    /*!*******************************************************!*\
      !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
      \*******************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/cookies.js":
    /*!***************************************************!*\
      !*** ./node_modules/axios/lib/helpers/cookies.js ***!
      \***************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = (
      utils.isStandardBrowserEnv() ?
    
      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));
    
              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }
    
              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }
    
              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }
    
              if (secure === true) {
                cookie.push('secure');
              }
    
              document.cookie = cookie.join('; ');
            },
    
            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },
    
            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :
    
      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
    /*!*********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
      \*********************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    module.exports = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
      \********************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    module.exports = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
    /*!***********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
      \***********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = (
      utils.isStandardBrowserEnv() ?
    
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;
    
          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;
    
            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }
    
            urlParsingNode.setAttribute('href', href);
    
            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }
    
          originURL = resolveURL(window.location.href);
    
          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :
    
      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
    /*!***************************************************************!*\
      !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
      \***************************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
      \********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];
    
    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
    
      if (!headers) { return parsed; }
    
      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
    
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });
    
      return parsed;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/spread.js":
    /*!**************************************************!*\
      !*** ./node_modules/axios/lib/helpers/spread.js ***!
      \**************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/validator.js":
    /*!*****************************************************!*\
      !*** ./node_modules/axios/lib/helpers/validator.js ***!
      \*****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var VERSION = (__webpack_require__(/*! ../env/data */ "./node_modules/axios/lib/env/data.js").version);
    
    var validators = {};
    
    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });
    
    var deprecatedWarnings = {};
    
    /**
     * Transitional option validator
     * @param {function|boolean?} validator - set to false if the transitional option has been removed
     * @param {string?} version - deprecated version / removed since version
     * @param {string?} message - some message with additional info
     * @returns {function}
     */
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }
    
      // eslint-disable-next-line func-names
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
        }
    
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }
    
        return validator ? validator(value, opt, opts) : true;
      };
    };
    
    /**
     * Assert object's properties type
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     */
    
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new TypeError('options must be an object');
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError('option ' + opt + ' must be ' + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error('Unknown option ' + opt);
        }
      }
    }
    
    module.exports = {
      assertOptions: assertOptions,
      validators: validators
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/utils.js":
    /*!*****************************************!*\
      !*** ./node_modules/axios/lib/utils.js ***!
      \*****************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
    
    // utils is a library of generic helper functions non-specific to axios
    
    var toString = Object.prototype.toString;
    
    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }
    
    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }
    
    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }
    
    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }
    
    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }
    
    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }
    
    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }
    
    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }
    
    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }
    
    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }
    
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    
    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }
    
    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }
    
    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }
    
    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }
    
    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    
    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }
    
    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }
    
    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }
    
    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }
    
      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }
    
      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    
    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
    
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    
    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    
    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }
    
    module.exports = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
      \*******************************************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    /*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */
    (function(){
      "use strict";
    
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    
      // Use a lookup table to find the index.
      var lookup = new Uint8Array(256);
      for (var i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
      }
    
      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer),
        i, len = bytes.length, base64 = "";
    
        for (i = 0; i < len; i+=3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
          base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
          base64 += chars[bytes[i + 2] & 63];
        }
    
        if ((len % 3) === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }
    
        return base64;
      };
    
      exports.decode =  function(base64) {
        var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;
    
        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }
    
        var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);
    
        for (i = 0; i < len; i+=4) {
          encoded1 = lookup[base64.charCodeAt(i)];
          encoded2 = lookup[base64.charCodeAt(i+1)];
          encoded3 = lookup[base64.charCodeAt(i+2)];
          encoded4 = lookup[base64.charCodeAt(i+3)];
    
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }
    
        return arraybuffer;
      };
    })();
    
    
    /***/ }),
    
    /***/ "./node_modules/base64-js/index.js":
    /*!*****************************************!*\
      !*** ./node_modules/base64-js/index.js ***!
      \*****************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    
    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray
    
    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
    
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }
    
    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63
    
    function getLens (b64) {
      var len = b64.length
    
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
    
      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len
    
      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)
    
      return [validLen, placeHoldersLen]
    }
    
    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function toByteArray (b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
    
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
    
      var curByte = 0
    
      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen
    
      var i
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      return arr
    }
    
    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }
    
    function encodeChunk (uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }
    
    function fromByteArray (uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3
    
      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }
    
      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }
    
      return parts.join('')
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/bignumber.js/bignumber.js":
    /*!************************************************!*\
      !*** ./node_modules/bignumber.js/bignumber.js ***!
      \************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {
      'use strict';
    
    /*
     *      bignumber.js v9.1.2
     *      A JavaScript library for arbitrary-precision arithmetic.
     *      https://github.com/MikeMcl/bignumber.js
     *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *      MIT Licensed.
     *
     *      BigNumber.prototype methods     |  BigNumber methods
     *                                      |
     *      absoluteValue            abs    |  clone
     *      comparedTo                      |  config               set
     *      decimalPlaces            dp     |      DECIMAL_PLACES
     *      dividedBy                div    |      ROUNDING_MODE
     *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
     *      exponentiatedBy          pow    |      RANGE
     *      integerValue                    |      CRYPTO
     *      isEqualTo                eq     |      MODULO_MODE
     *      isFinite                        |      POW_PRECISION
     *      isGreaterThan            gt     |      FORMAT
     *      isGreaterThanOrEqualTo   gte    |      ALPHABET
     *      isInteger                       |  isBigNumber
     *      isLessThan               lt     |  maximum              max
     *      isLessThanOrEqualTo      lte    |  minimum              min
     *      isNaN                           |  random
     *      isNegative                      |  sum
     *      isPositive                      |
     *      isZero                          |
     *      minus                           |
     *      modulo                   mod    |
     *      multipliedBy             times  |
     *      negated                         |
     *      plus                            |
     *      precision                sd     |
     *      shiftedBy                       |
     *      squareRoot               sqrt   |
     *      toExponential                   |
     *      toFixed                         |
     *      toFormat                        |
     *      toFraction                      |
     *      toJSON                          |
     *      toNumber                        |
     *      toPrecision                     |
     *      toString                        |
     *      valueOf                         |
     *
     */
    
    
      var BigNumber,
        isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
    
        bignumberError = '[BigNumber Error] ',
        tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
    
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,
    
        // EDITABLE
        // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
        // the arguments to toExponential, toFixed, toFormat, and toPrecision.
        MAX = 1E9;                                   // 0 to MAX_INT32
    
    
      /*
       * Create and return a BigNumber constructor.
       */
      function clone(configObject) {
        var div, convertBase, parseNumeric,
          P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
          ONE = new BigNumber(1),
    
    
          //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
    
    
          // The default values below must be integers within the inclusive ranges stated.
          // The values can also be changed at run-time using BigNumber.set.
    
          // The maximum number of decimal places for operations involving division.
          DECIMAL_PLACES = 20,                     // 0 to MAX
    
          // The rounding mode used when rounding to the above decimal places, and when using
          // toExponential, toFixed, toFormat and toPrecision, and round (default value).
          // UP         0 Away from zero.
          // DOWN       1 Towards zero.
          // CEIL       2 Towards +Infinity.
          // FLOOR      3 Towards -Infinity.
          // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
          // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
          // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
          // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
          // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
          ROUNDING_MODE = 4,                       // 0 to 8
    
          // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
    
          // The exponent value at and beneath which toString returns exponential notation.
          // Number type: -7
          TO_EXP_NEG = -7,                         // 0 to -MAX
    
          // The exponent value at and above which toString returns exponential notation.
          // Number type: 21
          TO_EXP_POS = 21,                         // 0 to MAX
    
          // RANGE : [MIN_EXP, MAX_EXP]
    
          // The minimum exponent value, beneath which underflow to zero occurs.
          // Number type: -324  (5e-324)
          MIN_EXP = -1e7,                          // -1 to -MAX
    
          // The maximum exponent value, above which overflow to Infinity occurs.
          // Number type:  308  (1.7976931348623157e+308)
          // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
          MAX_EXP = 1e7,                           // 1 to MAX
    
          // Whether to use cryptographically-secure random number generation, if available.
          CRYPTO = false,                          // true or false
    
          // The modulo mode used when calculating the modulus: a mod n.
          // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
          // The remainder (r) is calculated as: r = a - n * q.
          //
          // UP        0 The remainder is positive if the dividend is negative, else is negative.
          // DOWN      1 The remainder has the same sign as the dividend.
          //             This modulo mode is commonly known as 'truncated division' and is
          //             equivalent to (a % n) in JavaScript.
          // FLOOR     3 The remainder has the same sign as the divisor (Python %).
          // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
          // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
          //             The remainder is always positive.
          //
          // The truncated division, floored division, Euclidian division and IEEE 754 remainder
          // modes are commonly used for the modulus operation.
          // Although the other rounding modes can also be used, they may not give useful results.
          MODULO_MODE = 1,                         // 0 to 9
    
          // The maximum number of significant digits of the result of the exponentiatedBy operation.
          // If POW_PRECISION is 0, there will be unlimited significant digits.
          POW_PRECISION = 0,                       // 0 to MAX
    
          // The format specification used by the BigNumber.prototype.toFormat method.
          FORMAT = {
            prefix: '',
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ',',
            decimalSeparator: '.',
            fractionGroupSize: 0,
            fractionGroupSeparator: '\xA0',        // non-breaking space
            suffix: ''
          },
    
          // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
          // '-', '.', whitespace, or repeated character.
          // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
          ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
          alphabetHasNormalDecimalDigits = true;
    
    
        //------------------------------------------------------------------------------------------
    
    
        // CONSTRUCTOR
    
    
        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * v {number|string|BigNumber} A numeric value.
         * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
         */
        function BigNumber(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str,
            x = this;
    
          // Enable constructor call without `new`.
          if (!(x instanceof BigNumber)) return new BigNumber(v, b);
    
          if (b == null) {
    
            if (v && v._isBigNumber === true) {
              x.s = v.s;
    
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
    
              return;
            }
    
            if ((isNum = typeof v == 'number') && v * 0 == 0) {
    
              // Use `1 / n` to handle minus zero also.
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
    
              // Fast path for integers, where n < 2147483648 (2**31).
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++);
    
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
    
                return;
              }
    
              str = String(v);
            } else {
    
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
    
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
    
            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
    
            // Exponential form?
            if ((i = str.search(/e/i)) > 0) {
    
              // Determine exponent.
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
    
              // Integer.
              e = str.length;
            }
    
          } else {
    
            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
            intCheck(b, 2, ALPHABET.length, 'Base');
    
            // Allow exponential notation to be used with base 10 argument, while
            // also rounding to DECIMAL_PLACES as with other bases.
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
    
            str = String(v);
    
            if (isNum = typeof v == 'number') {
    
              // Avoid potential interpretation of Infinity and NaN as base 44+ values.
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
    
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
    
              // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
              if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                throw Error
                 (tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
    
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
    
            // Check that str is a valid base b number.
            // Don't use RegExp, so alphabet can contain special characters.
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == '.') {
    
                  // If '.' is not the first character and it has not be found before.
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
    
                  // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                      str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
    
                return parseNumeric(x, String(v), isNum, b);
              }
            }
    
            // Prevent later check for length on converted number.
            isNum = false;
            str = convertBase(str, b, 10, x.s);
    
            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
            else e = str.length;
          }
    
          // Determine leading zeros.
          for (i = 0; str.charCodeAt(i) === 48; i++);
    
          // Determine trailing zeros.
          for (len = str.length; str.charCodeAt(--len) === 48;);
    
          if (str = str.slice(i, ++len)) {
            len -= i;
    
            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
            if (isNum && BigNumber.DEBUG &&
              len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error
                 (tooManyDigits + (x.s * v));
            }
    
             // Overflow?
            if ((e = e - i - 1) > MAX_EXP) {
    
              // Infinity.
              x.c = x.e = null;
    
            // Underflow?
            } else if (e < MIN_EXP) {
    
              // Zero.
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
    
              // Transform base
    
              // e is the base 10 exponent.
              // i is where to slice str to get the first element of the coefficient array.
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;  // i < 1
    
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
    
                for (len -= LOG_BASE; i < len;) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
    
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
    
              for (; i--; str += '0');
              x.c.push(+str);
            }
          } else {
    
            // Zero.
            x.c = [x.e = 0];
          }
        }
    
    
        // CONSTRUCTOR PROPERTIES
    
    
        BigNumber.clone = clone;
    
        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;
    
    
        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object with the following optional properties (if the value of a property is
         * a number, it must be an integer within the inclusive range stated):
         *
         *   DECIMAL_PLACES   {number}           0 to MAX
         *   ROUNDING_MODE    {number}           0 to 8
         *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
         *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
         *   CRYPTO           {boolean}          true or false
         *   MODULO_MODE      {number}           0 to 9
         *   POW_PRECISION       {number}           0 to MAX
         *   ALPHABET         {string}           A string of two or more unique characters which does
         *                                       not contain '.'.
         *   FORMAT           {object}           An object with some of the following properties:
         *     prefix                 {string}
         *     groupSize              {number}
         *     secondaryGroupSize     {number}
         *     groupSeparator         {string}
         *     decimalSeparator       {string}
         *     fractionGroupSize      {number}
         *     fractionGroupSeparator {string}
         *     suffix                 {string}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined, except for ALPHABET.
         *
         * Return an object with the properties current values.
         */
        BigNumber.config = BigNumber.set = function (obj) {
          var p, v;
    
          if (obj != null) {
    
            if (typeof obj == 'object') {
    
              // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
              // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
    
              // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
              // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
    
              // EXPONENTIAL_AT {number|number[]}
              // Integer, -MAX to MAX inclusive or
              // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
              // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
    
              // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
              // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
              // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
              if (obj.hasOwnProperty(p = 'RANGE')) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error
                     (bignumberError + p + ' cannot be zero: ' + v);
                  }
                }
              }
    
              // CRYPTO {boolean} true or false.
              // '[BigNumber Error] CRYPTO not true or false: {v}'
              // '[BigNumber Error] crypto unavailable'
              if (obj.hasOwnProperty(p = 'CRYPTO')) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != 'undefined' && crypto &&
                     (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error
                       (bignumberError + 'crypto unavailable');
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error
                   (bignumberError + p + ' not true or false: ' + v);
                }
              }
    
              // MODULO_MODE {number} Integer, 0 to 9 inclusive.
              // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
    
              // POW_PRECISION {number} Integer, 0 to MAX inclusive.
              // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
    
              // FORMAT {object}
              // '[BigNumber Error] FORMAT not an object: {v}'
              if (obj.hasOwnProperty(p = 'FORMAT')) {
                v = obj[p];
                if (typeof v == 'object') FORMAT = v;
                else throw Error
                 (bignumberError + p + ' not an object: ' + v);
              }
    
              // ALPHABET {string}
              // '[BigNumber Error] ALPHABET invalid: {v}'
              if (obj.hasOwnProperty(p = 'ALPHABET')) {
                v = obj[p];
    
                // Disallow if less than two characters,
                // or if it contains '+', '-', '.', whitespace, or a repeated character.
                if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                  ALPHABET = v;
                } else {
                  throw Error
                   (bignumberError + p + ' invalid: ' + v);
                }
              }
    
            } else {
    
              // '[BigNumber Error] Object expected: {v}'
              throw Error
               (bignumberError + 'Object expected: ' + obj);
            }
          }
    
          return {
            DECIMAL_PLACES: DECIMAL_PLACES,
            ROUNDING_MODE: ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO: CRYPTO,
            MODULO_MODE: MODULO_MODE,
            POW_PRECISION: POW_PRECISION,
            FORMAT: FORMAT,
            ALPHABET: ALPHABET
          };
        };
    
    
        /*
         * Return true if v is a BigNumber instance, otherwise return false.
         *
         * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
         *
         * v {any}
         *
         * '[BigNumber Error] Invalid BigNumber: {v}'
         */
        BigNumber.isBigNumber = function (v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber.DEBUG) return true;
    
          var i, n,
            c = v.c,
            e = v.e,
            s = v.s;
    
          out: if ({}.toString.call(c) == '[object Array]') {
    
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
    
              // If the first element is zero, the BigNumber value must be zero.
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
    
              // Calculate number of digits that c[0] should have, based on the exponent.
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
    
              // Calculate number of digits of c[0].
              //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
              if (String(c[0]).length == i) {
    
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
    
                // Last element cannot be zero, unless it is the only element.
                if (n !== 0) return true;
              }
            }
    
          // Infinity/NaN
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
    
          throw Error
            (bignumberError + 'Invalid BigNumber: ' + v);
        };
    
    
        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.maximum = BigNumber.max = function () {
          return maxOrMin(arguments, -1);
        };
    
    
        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.minimum = BigNumber.min = function () {
          return maxOrMin(arguments, 1);
        };
    
    
        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
         * '[BigNumber Error] crypto unavailable'
         */
        BigNumber.random = (function () {
          var pow2_53 = 0x20000000000000;
    
          // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
          // Check if Math.random() produces more than 32 bits of randomness.
          // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
          // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
          var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
           ? function () { return mathfloor(Math.random() * pow2_53); }
           : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
             (Math.random() * 0x800000 | 0); };
    
          return function (dp) {
            var a, b, e, k, v,
              i = 0,
              c = [],
              rand = new BigNumber(ONE);
    
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
    
            k = mathceil(dp / LOG_BASE);
    
            if (CRYPTO) {
    
              // Browsers supporting crypto.getRandomValues.
              if (crypto.getRandomValues) {
    
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
    
                for (; i < k;) {
    
                  // 53 bits:
                  // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                  // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                  // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                  //                                     11111 11111111 11111111
                  // 0x20000 is 2^21.
                  v = a[i] * 0x20000 + (a[i + 1] >>> 11);
    
                  // Rejection sampling:
                  // 0 <= v < 9007199254740992
                  // Probability that v >= 9e15, is
                  // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
    
                    // 0 <= v <= 8999999999999999
                    // 0 <= (v % 1e14) <= 99999999999999
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
    
              // Node.js supporting crypto.randomBytes.
              } else if (crypto.randomBytes) {
    
                // buffer
                a = crypto.randomBytes(k *= 7);
    
                for (; i < k;) {
    
                  // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                  // 0x100000000 is 2^32, 0x1000000 is 2^24
                  // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                  // 0 <= v < 9007199254740992
                  v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                     (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                     (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
    
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
    
                    // 0 <= (v % 1e14) <= 99999999999999
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            }
    
            // Use Math.random.
            if (!CRYPTO) {
    
              for (; i < k;) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
    
            k = c[--i];
            dp %= LOG_BASE;
    
            // Convert trailing digits to zeros according to dp.
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
    
            // Remove trailing elements which are zero.
            for (; c[i] === 0; c.pop(), i--);
    
            // Zero?
            if (i < 0) {
              c = [e = 0];
            } else {
    
              // Remove leading elements which are zero and adjust exponent accordingly.
              for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
    
              // Count the digits of the first element of c to determine leading zeros, and...
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++);
    
              // adjust the exponent accordingly.
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
    
            rand.e = e;
            rand.c = c;
            return rand;
          };
        })();
    
    
        /*
         * Return a BigNumber whose value is the sum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.sum = function () {
          var i = 1,
            args = arguments,
            sum = new BigNumber(args[0]);
          for (; i < args.length;) sum = sum.plus(args[i++]);
          return sum;
        };
    
    
        // PRIVATE FUNCTIONS
    
    
        // Called by BigNumber and BigNumber.prototype.toString.
        convertBase = (function () {
          var decimal = '0123456789';
    
          /*
           * Convert string of baseIn to an array of numbers of baseOut.
           * Eg. toBaseOut('255', 10, 16) returns [15, 15].
           * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
           */
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j,
              arr = [0],
              arrL,
              i = 0,
              len = str.length;
    
            for (; i < len;) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
    
              arr[0] += alphabet.indexOf(str.charAt(i++));
    
              for (j = 0; j < arr.length; j++) {
    
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
    
            return arr.reverse();
          }
    
          // Convert a numeric string of baseIn to a numeric string of baseOut.
          // If the caller is toString, we are converting from base 10 to baseOut.
          // If the caller is BigNumber, we are converting from baseIn to base 10.
          return function (str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y,
              i = str.indexOf('.'),
              dp = DECIMAL_PLACES,
              rm = ROUNDING_MODE;
    
            // Non-integer.
            if (i >= 0) {
              k = POW_PRECISION;
    
              // Unlimited precision.
              POW_PRECISION = 0;
              str = str.replace('.', '');
              y = new BigNumber(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
    
              // Convert str as if an integer, then restore the fraction part by dividing the
              // result by its base raised to a power.
    
              y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
               10, baseOut, decimal);
              y.e = y.c.length;
            }
    
            // Convert the number as integer.
    
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString
             ? (alphabet = ALPHABET, decimal)
             : (alphabet = decimal, ALPHABET));
    
            // xc now represents str as an integer and converted to baseOut. e is the exponent.
            e = k = xc.length;
    
            // Remove trailing zeros.
            for (; xc[--k] == 0; xc.pop());
    
            // Zero?
            if (!xc[0]) return alphabet.charAt(0);
    
            // Does str represent an integer? If so, no need for the division.
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
    
              // The sign is needed for correct rounding.
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
    
            // xc now represents str converted to baseOut.
    
            // THe index of the rounding digit.
            d = e + dp + 1;
    
            // The rounding digit: the digit to the right of the digit that may be rounded up.
            i = xc[d];
    
            // Look at the rounding digits and mode to determine whether to round up.
    
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
    
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                  : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                   rm == (x.s < 0 ? 8 : 7));
    
            // If the index of the rounding digit is not greater than zero, or xc represents
            // zero, then the result of the base conversion is zero or, if rounding up, a value
            // such as 0.00001.
            if (d < 1 || !xc[0]) {
    
              // 1^-dp or 0
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
    
              // Truncate xc to the required number of decimal places.
              xc.length = d;
    
              // Round up?
              if (r) {
    
                // Rounding up may mean the previous digit has to be rounded up and so on.
                for (--baseOut; ++xc[--d] > baseOut;) {
                  xc[d] = 0;
    
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
    
              // Determine trailing zeros.
              for (k = xc.length; !xc[--k];);
    
              // E.g. [4, 11, 15] becomes 4bf.
              for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
    
              // Add leading zeros, decimal point and trailing zeros as required.
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
    
            // The caller will add the sign.
            return str;
          };
        })();
    
    
        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {
    
          // Assume non-zero x and k.
          function multiply(x, k, base) {
            var m, temp, xlo, xhi,
              carry = 0,
              i = x.length,
              klo = k % SQRT_BASE,
              khi = k / SQRT_BASE | 0;
    
            for (x = x.slice(); i--;) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
    
            if (carry) x = [carry].concat(x);
    
            return x;
          }
    
          function compare(a, b, aL, bL) {
            var i, cmp;
    
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
    
              for (i = cmp = 0; i < aL; i++) {
    
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
    
            return cmp;
          }
    
          function subtract(a, b, aL, base) {
            var i = 0;
    
            // Subtract b from a.
            for (; aL--;) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
    
            // Remove leading zeros.
            for (; !a[0] && a.length > 1; a.splice(0, 1));
          }
    
          // x: dividend, y: divisor.
          return function (x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
              yL, yz,
              s = x.s == y.s ? 1 : -1,
              xc = x.c,
              yc = y.c;
    
            // Either NaN, Infinity or 0?
            if (!xc || !xc[0] || !yc || !yc[0]) {
    
              return new BigNumber(
    
               // Return NaN if either NaN, or both Infinity or 0.
               !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :
    
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0
             );
            }
    
            q = new BigNumber(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
    
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
    
            // Result exponent may be one less then the current value of e.
            // The coefficients of the BigNumbers from convertBase may have trailing zeros.
            for (i = 0; yc[i] == (xc[i] || 0); i++);
    
            if (yc[i] > (xc[i] || 0)) e--;
    
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
    
              // Normalise xc and yc so highest order digit of yc is >= base / 2.
    
              n = mathfloor(base / (yc[0] + 1));
    
              // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
              // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
    
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
    
              // Add zeros to make remainder as long as divisor.
              for (; remL < yL; rem[remL++] = 0);
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              // Not necessary, but to prevent trial digit n > base, when using base 3.
              // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;
    
              do {
                n = 0;
    
                // Compare divisor and remainder.
                cmp = compare(yc, rem, yL, remL);
    
                // If divisor < remainder.
                if (cmp < 0) {
    
                  // Calculate trial digit, n.
    
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
    
                  // n is how many times the divisor goes into the current remainder.
                  n = mathfloor(rem0 / yc0);
    
                  //  Algorithm:
                  //  product = divisor multiplied by trial digit (n).
                  //  Compare product and remainder.
                  //  If product is greater than remainder:
                  //    Subtract divisor from product, decrement trial digit.
                  //  Subtract product from remainder.
                  //  If product was less than remainder at the last compare:
                  //    Compare new remainder and divisor.
                  //    If remainder is greater than divisor:
                  //      Subtract divisor from remainder, increment trial digit.
    
                  if (n > 1) {
    
                    // n may be > base only when base is 3.
                    if (n >= base) n = base - 1;
    
                    // product = divisor * trial digit.
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
    
                    // Compare product and remainder.
                    // If product > remainder then trial digit n too high.
                    // n is 1 too high about 5% of the time, and is not known to have
                    // ever been more than 1 too high.
                    while (compare(prod, rem, prodL, remL) == 1) {
                      n--;
    
                      // Subtract divisor from product.
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
    
                    // n is 0 or 1, cmp is -1.
                    // If n is 0, there is no need to compare yc and rem again below,
                    // so change cmp to 1 to avoid it.
                    // If n is 1, leave cmp as -1, so yc and rem are compared again.
                    if (n == 0) {
    
                      // divisor < remainder, so n must be at least 1.
                      cmp = n = 1;
                    }
    
                    // product = divisor
                    prod = yc.slice();
                    prodL = prod.length;
                  }
    
                  if (prodL < remL) prod = [0].concat(prod);
    
                  // Subtract product from remainder.
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
    
                   // If product was < remainder.
                  if (cmp == -1) {
    
                    // Compare divisor and new remainder.
                    // If divisor < new remainder, subtract divisor from remainder.
                    // Trial digit n too low.
                    // n is 1 too low about 5% of the time, and very rarely 2 too low.
                    while (compare(yc, rem, yL, remL) < 1) {
                      n++;
    
                      // Subtract divisor from remainder.
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                } // else cmp === 1 and n will be 0
    
                // Add the next digit, n, to the result array.
                qc[i++] = n;
    
                // Update the remainder.
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
    
              more = rem[0] != null;
    
              // Leading zero?
              if (!qc[0]) qc.splice(0, 1);
            }
    
            if (base == BASE) {
    
              // To calculate q.e, first get the number of digits of qc[0].
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
    
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
    
            // Caller is convertBase.
            } else {
              q.e = e;
              q.r = +more;
            }
    
            return q;
          };
        })();
    
    
        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n: a BigNumber.
         * i: the index of the last digit required (i.e. the digit that may be rounded up).
         * rm: the rounding mode.
         * id: 1 (toExponential) or 2 (toPrecision).
         */
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
    
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
    
          if (!n.c) return n.toString();
    
          c0 = n.c[0];
          ne = n.e;
    
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
             ? toExponential(str, ne)
             : toFixedPoint(str, ne, '0');
          } else {
            n = round(new BigNumber(n), i, rm);
    
            // n.e may have changed if the value was rounded up.
            e = n.e;
    
            str = coeffToString(n.c);
            len = str.length;
    
            // toPrecision returns exponential notation if the number of significant digits
            // specified is less than the number of digits necessary to represent the integer
            // part of the value in fixed-point notation.
    
            // Exponential notation.
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
    
              // Append zeros?
              for (; len < i; str += '0', len++);
              str = toExponential(str, e);
    
            // Fixed-point notation.
            } else {
              i -= ne;
              str = toFixedPoint(str, e, '0');
    
              // Append zeros?
              if (e + 1 > len) {
                if (--i > 0) for (str += '.'; i--; str += '0');
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += '.';
                  for (; i--; str += '0');
                }
              }
            }
          }
    
          return n.s < 0 && c0 ? '-' + str : str;
        }
    
    
        // Handle BigNumber.max and BigNumber.min.
        // If any number is NaN, return NaN.
        function maxOrMin(args, n) {
          var k, y,
            i = 1,
            x = new BigNumber(args[0]);
    
          for (; i < args.length; i++) {
            y = new BigNumber(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
    
          return x;
        }
    
    
        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise(n, c, e) {
          var i = 1,
            j = c.length;
    
           // Remove trailing zeros.
          for (; !c[--j]; c.pop());
    
          // Calculate the base 10 exponent. First get the number of digits of c[0].
          for (j = c[0]; j >= 10; j /= 10, i++);
    
          // Overflow?
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
    
            // Infinity.
            n.c = n.e = null;
    
          // Underflow?
          } else if (e < MIN_EXP) {
    
            // Zero.
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
    
          return n;
        }
    
    
        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            dotAfter = /^([^.]+)\.$/,
            dotBefore = /^\.([^.]+)$/,
            isInfinityOrNaN = /^-?(Infinity|NaN)$/,
            whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    
          return function (x, str, isNum, b) {
            var base,
              s = isNum ? str : str.replace(whitespaceOrPlus, '');
    
            // No exception on Infinity or NaN.
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
    
                // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                s = s.replace(basePrefix, function (m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
    
                if (b) {
                  base = b;
    
                  // E.g. '1.' to '1', '.1' to '0.1'
                  s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                }
    
                if (str != s) return new BigNumber(s, base);
              }
    
              // '[BigNumber Error] Not a number: {n}'
              // '[BigNumber Error] Not a base {b} number: {n}'
              if (BigNumber.DEBUG) {
                throw Error
                  (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
              }
    
              // NaN
              x.s = null;
            }
    
            x.c = x.e = null;
          }
        })();
    
    
        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd,
            xc = x.c,
            pows10 = POWS_TEN;
    
          // if x is not Infinity or NaN...
          if (xc) {
    
            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
            // n is a base 1e14 number, the value of the element of array x.c containing rd.
            // ni is the index of n within x.c.
            // d is the number of digits of n.
            // i is the index of rd within n including leading zeros.
            // j is the actual index of rd within n (if < 0, rd is a leading zero).
            out: {
    
              // Get the number of digits of the first element of xc.
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
              i = sd - d;
    
              // If the rounding digit is in the first element of xc...
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
    
                // Get the rounding digit at index j of n.
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
    
                if (ni >= xc.length) {
    
                  if (r) {
    
                    // Needed by sqrt.
                    for (; xc.length <= ni; xc.push(0));
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
    
                  // Get the number of digits of n.
                  for (d = 1; k >= 10; k /= 10, d++);
    
                  // Get the index of rd within n.
                  i %= LOG_BASE;
    
                  // Get the index of rd within n, adjusted for leading zeros.
                  // The number of leading zeros of n is given by LOG_BASE - d.
                  j = i - LOG_BASE + d;
    
                  // Get the rounding digit at index j of n.
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
    
              r = r || sd < 0 ||
    
              // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
               xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
    
              r = rm < 4
               ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
               : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&
    
                // Check whether the digit to the left of the rounding digit is odd.
                ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
                 rm == (x.s < 0 ? 8 : 7));
    
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
    
                if (r) {
    
                  // Convert sd to decimal places.
                  sd -= x.e + 1;
    
                  // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
    
                  // Zero.
                  xc[0] = x.e = 0;
                }
    
                return x;
              }
    
              // Remove excess digits.
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
    
                // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                // j > 0 means i > number of leading zeros of n.
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
    
              // Round up?
              if (r) {
    
                for (; ;) {
    
                  // If the digit to be rounded up is in the first element of xc...
                  if (ni == 0) {
    
                    // i will be the length of xc[0] before k is added.
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++);
    
                    // if i != k the length has increased.
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
    
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
    
              // Remove trailing zeros.
              for (i = xc.length; xc[--i] === 0; xc.pop());
            }
    
            // Overflow? Infinity.
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
    
            // Underflow? Zero.
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
    
          return x;
        }
    
    
        function valueOf(n) {
          var str,
            e = n.e;
    
          if (e === null) return n.toString();
    
          str = coeffToString(n.c);
    
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
            ? toExponential(str, e)
            : toFixedPoint(str, e, '0');
    
          return n.s < 0 ? '-' + str : str;
        }
    
    
        // PROTOTYPE/INSTANCE METHODS
    
    
        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
          var x = new BigNumber(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
    
    
        /*
         * Return
         *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         *   0 if they have the same value,
         *   or null if the value of either is NaN.
         */
        P.comparedTo = function (y, b) {
          return compare(this, new BigNumber(y, b));
        };
    
    
        /*
         * If dp is undefined or null or true or false, return the number of decimal places of the
         * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
         *
         * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
         * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
         * ROUNDING_MODE if rm is omitted.
         *
         * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         */
        P.decimalPlaces = P.dp = function (dp, rm) {
          var c, n, v,
            x = this;
    
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
    
            return round(new BigNumber(x), dp + x.e + 1, rm);
          }
    
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    
          // Subtract the number of trailing zeros of the last number.
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
          if (n < 0) n = 0;
    
          return n;
        };
    
    
        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function (y, b) {
          return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
    
    
        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.idiv = function (y, b) {
          return div(this, new BigNumber(y, b), 0, 1);
        };
    
    
        /*
         * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
         *
         * If m is present, return the result modulo m.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
         *
         * The modular power operation works efficiently when x, n, and m are integers, otherwise it
         * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
         *
         * n {number|string|BigNumber} The exponent. An integer.
         * [m] {number|string|BigNumber} The modulus.
         *
         * '[BigNumber Error] Exponent not an integer: {n}'
         */
        P.exponentiatedBy = P.pow = function (n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
            x = this;
    
          n = new BigNumber(n);
    
          // Allow NaN and Infinity, but not other non-integers.
          if (n.c && !n.isInteger()) {
            throw Error
              (bignumberError + 'Exponent not an integer: ' + valueOf(n));
          }
    
          if (m != null) m = new BigNumber(m);
    
          // Exponent of MAX_SAFE_INTEGER is 15.
          nIsBig = n.e > 14;
    
          // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
    
            // The sign of the result of pow when x is negative depends on the evenness of n.
            // If +n overflows to Infinity, the evenness of n would be not be known.
            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
    
          nIsNeg = n.s < 0;
    
          if (m) {
    
            // x % m returns NaN if abs(m) is zero, or m is NaN.
            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
    
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
    
            if (isModExp) x = x.mod(m);
    
          // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
          // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
            // [1, 240000000]
            ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
            // [80000000000000]  [99999750000000]
            : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
    
            // If x is negative and n is odd, k = -0, else k = 0.
            k = x.s < 0 && isOdd(n) ? -0 : 0;
    
            // If x >= 1, k = Infinity.
            if (x.e > -1) k = 1 / k;
    
            // If n is negative return 0, else return Infinity.
            return new BigNumber(nIsNeg ? 1 / k : k);
    
          } else if (POW_PRECISION) {
    
            // Truncating each coefficient array to a length of k after each multiplication
            // equates to truncating significant digits to POW_PRECISION + [28, 41],
            // i.e. there will be a minimum of 28 guard digits retained.
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
    
          if (nIsBig) {
            half = new BigNumber(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
    
          y = new BigNumber(ONE);
    
          // Performs 54 loop iterations for n of 9007199254740991.
          for (; ;) {
    
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
    
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
              }
            }
    
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
    
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
    
            x = x.times(x);
    
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
            }
          }
    
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
    
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
    
    
        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
         * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
         */
        P.integerValue = function (rm) {
          var n = new BigNumber(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
    
    
        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise return false.
         */
        P.isEqualTo = P.eq = function (y, b) {
          return compare(this, new BigNumber(y, b)) === 0;
        };
    
    
        /*
         * Return true if the value of this BigNumber is a finite number, otherwise return false.
         */
        P.isFinite = function () {
          return !!this.c;
        };
    
    
        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise return false.
         */
        P.isGreaterThan = P.gt = function (y, b) {
          return compare(this, new BigNumber(y, b)) > 0;
        };
    
    
        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise return false.
         */
        P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
          return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
    
        };
    
    
        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = function () {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
    
    
        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise return false.
         */
        P.isLessThan = P.lt = function (y, b) {
          return compare(this, new BigNumber(y, b)) < 0;
        };
    
    
        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise return false.
         */
        P.isLessThanOrEqualTo = P.lte = function (y, b) {
          return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
        };
    
    
        /*
         * Return true if the value of this BigNumber is NaN, otherwise return false.
         */
        P.isNaN = function () {
          return !this.s;
        };
    
    
        /*
         * Return true if the value of this BigNumber is negative, otherwise return false.
         */
        P.isNegative = function () {
          return this.s < 0;
        };
    
    
        /*
         * Return true if the value of this BigNumber is positive, otherwise return false.
         */
        P.isPositive = function () {
          return this.s > 0;
        };
    
    
        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
         */
        P.isZero = function () {
          return !!this.c && this.c[0] == 0;
        };
    
    
        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = function (y, b) {
          var i, j, t, xLTy,
            x = this,
            a = x.s;
    
          y = new BigNumber(y, b);
          b = y.s;
    
          // Either NaN?
          if (!a || !b) return new BigNumber(NaN);
    
          // Signs differ?
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
    
          var xe = x.e / LOG_BASE,
            ye = y.e / LOG_BASE,
            xc = x.c,
            yc = y.c;
    
          if (!xe || !ye) {
    
            // Either Infinity?
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
    
            // Either zero?
            if (!xc[0] || !yc[0]) {
    
              // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
              return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :
    
               // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
               ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
    
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
    
          // Determine which is the bigger number.
          if (a = xe - ye) {
    
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
    
            t.reverse();
    
            // Prepend zeros to equalise exponents.
            for (b = a; b--; t.push(0));
            t.reverse();
          } else {
    
            // Exponents equal. Check digit by digit.
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
    
            for (a = b = 0; b < j; b++) {
    
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
    
          // x < y? Point xc to the array of the bigger number.
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
    
          b = (j = yc.length) - (i = xc.length);
    
          // Append zeros to xc if shorter.
          // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
          if (b > 0) for (; b--; xc[i++] = 0);
          b = BASE - 1;
    
          // Subtract yc from xc.
          for (; j > a;) {
    
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b);
              --xc[i];
              xc[j] += BASE;
            }
    
            xc[j] -= yc[j];
          }
    
          // Remove leading zeros and adjust exponent accordingly.
          for (; xc[0] == 0; xc.splice(0, 1), --ye);
    
          // Zero?
          if (!xc[0]) {
    
            // Following IEEE 754 (2008) 6.3,
            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
    
          // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
          // for finite x and y.
          return normalise(y, xc, ye);
        };
    
    
        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function (y, b) {
          var q, s,
            x = this;
    
          y = new BigNumber(y, b);
    
          // Return NaN if x is Infinity or NaN, or y is NaN or zero.
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber(NaN);
    
          // Return x if y is Infinity or x is zero.
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber(x);
          }
    
          if (MODULO_MODE == 9) {
    
            // Euclidian division: q = sign(y) * floor(x / abs(y))
            // r = x - qy    where  0 <= r < abs(y)
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
    
          y = x.minus(q.times(y));
    
          // To match JavaScript %, ensure sign of zero is sign of dividend.
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    
          return y;
        };
    
    
        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
         * of BigNumber(y, b).
         */
        P.multipliedBy = P.times = function (y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
            base, sqrtBase,
            x = this,
            xc = x.c,
            yc = (y = new BigNumber(y, b)).c;
    
          // Either NaN, Infinity or 0?
          if (!xc || !yc || !xc[0] || !yc[0]) {
    
            // Return NaN if either is NaN, or one is 0 and the other is Infinity.
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
    
              // Return Infinity if either is Infinity.
              if (!xc || !yc) {
                y.c = y.e = null;
    
              // Return 0 if either is 0.
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
    
            return y;
          }
    
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
    
          // Ensure xc points to longer array and xcL to its length.
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
    
          // Initialise the result array with zeros.
          for (i = xcL + ycL, zc = []; i--; zc.push(0));
    
          base = BASE;
          sqrtBase = SQRT_BASE;
    
          for (i = ycL; --i >= 0;) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
    
            for (k = xcL, j = i + k; j > i;) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
    
            zc[j] = c;
          }
    
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
    
          return normalise(y, zc, e);
        };
    
    
        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = function () {
          var x = new BigNumber(this);
          x.s = -x.s || null;
          return x;
        };
    
    
        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = function (y, b) {
          var t,
            x = this,
            a = x.s;
    
          y = new BigNumber(y, b);
          b = y.s;
    
          // Either NaN?
          if (!a || !b) return new BigNumber(NaN);
    
          // Signs differ?
           if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
    
          var xe = x.e / LOG_BASE,
            ye = y.e / LOG_BASE,
            xc = x.c,
            yc = y.c;
    
          if (!xe || !ye) {
    
            // Return Infinity if either Infinity.
            if (!xc || !yc) return new BigNumber(a / 0);
    
            // Either zero?
            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
          }
    
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
    
          // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
    
            t.reverse();
            for (; a--; t.push(0));
            t.reverse();
          }
    
          a = xc.length;
          b = yc.length;
    
          // Point xc to the longer array, and b to the shorter length.
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
    
          // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
          for (a = 0; b;) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
    
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
    
          // No need to check for zero, as +x + +y != 0 && -x + -y != 0
          // ye = MAX_EXP + 1 possible
          return normalise(y, xc, ye);
        };
    
    
        /*
         * If sd is undefined or null or true or false, return the number of significant digits of
         * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
         * If sd is true include integer-part trailing zeros in the count.
         *
         * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
         * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
         * ROUNDING_MODE if rm is omitted.
         *
         * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
         *                     boolean: whether to count integer-part trailing zeros: true or false.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
         */
        P.precision = P.sd = function (sd, rm) {
          var c, n, v,
            x = this;
    
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
    
            return round(new BigNumber(x), sd, rm);
          }
    
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
    
          if (v = c[v]) {
    
            // Subtract the number of trailing zeros of the last element.
            for (; v % 10 == 0; v /= 10, n--);
    
            // Add the number of digits of the first element.
            for (v = c[0]; v >= 10; v /= 10, n++);
          }
    
          if (sd && x.e + 1 > n) n = x.e + 1;
    
          return n;
        };
    
    
        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
         */
        P.shiftedBy = function (k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times('1e' + k);
        };
    
    
        /*
         *  sqrt(-n) =  N
         *  sqrt(N) =  N
         *  sqrt(-I) =  N
         *  sqrt(I) =  I
         *  sqrt(0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
          var m, n, r, rep, t,
            x = this,
            c = x.c,
            s = x.s,
            e = x.e,
            dp = DECIMAL_PLACES + 4,
            half = new BigNumber('0.5');
    
          // Negative/NaN/Infinity/zero?
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
    
          // Initial estimate.
          s = Math.sqrt(+valueOf(x));
    
          // Math.sqrt underflow/overflow?
          // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += '0';
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
    
            if (s == 1 / 0) {
              n = '5e' + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf('e') + 1) + e;
            }
    
            r = new BigNumber(n);
          } else {
            r = new BigNumber(s + '');
          }
    
          // Check for zero.
          // r could be zero if MIN_EXP is changed after the this value was created.
          // This would cause a division by zero (x/t) and hence Infinity below, which would cause
          // coeffToString to throw.
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
    
            // Newton-Raphson iteration.
            for (; ;) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
    
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
    
                // The exponent of r may here be one less than the final result exponent,
                // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                // are indexed correctly.
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
    
                // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                // iteration.
                if (n == '9999' || !rep && n == '4999') {
    
                  // On the first iteration only, check to see if rounding up gives the
                  // exact result as the nines may infinitely repeat.
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
    
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
    
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
    
                  // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                  // result. If not, then there are further digits and m will be truthy.
                  if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
    
                    // Truncate to the first rounding digit.
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
    
                  break;
                }
              }
            }
          }
    
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
    
    
        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         */
        P.toExponential = function (dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
    
    
        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         */
        P.toFixed = function (dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
    
    
        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the format or FORMAT object (see BigNumber.set).
         *
         * The formatting object may contain some or all of the properties shown below.
         *
         * FORMAT = {
         *   prefix: '',
         *   groupSize: 3,
         *   secondaryGroupSize: 0,
         *   groupSeparator: ',',
         *   decimalSeparator: '.',
         *   fractionGroupSize: 0,
         *   fractionGroupSeparator: '\xA0',      // non-breaking space
         *   suffix: ''
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         * [format] {object} Formatting options. See FORMAT pbject above.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         * '[BigNumber Error] Argument not an object: {format}'
         */
        P.toFormat = function (dp, rm, format) {
          var str,
            x = this;
    
          if (format == null) {
            if (dp != null && rm && typeof rm == 'object') {
              format = rm;
              rm = null;
            } else if (dp && typeof dp == 'object') {
              format = dp;
              dp = rm = null;
            } else {
              format = FORMAT;
            }
          } else if (typeof format != 'object') {
            throw Error
              (bignumberError + 'Argument not an object: ' + format);
          }
    
          str = x.toFixed(dp, rm);
    
          if (x.c) {
            var i,
              arr = str.split('.'),
              g1 = +format.groupSize,
              g2 = +format.secondaryGroupSize,
              groupSeparator = format.groupSeparator || '',
              intPart = arr[0],
              fractionPart = arr[1],
              isNeg = x.s < 0,
              intDigits = isNeg ? intPart.slice(1) : intPart,
              len = intDigits.length;
    
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
    
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = '-' + intPart;
            }
    
            str = fractionPart
             ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
              ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
               '$&' + (format.fractionGroupSeparator || ''))
              : fractionPart)
             : intPart;
          }
    
          return (format.prefix || '') + str + (format.suffix || '');
        };
    
    
        /*
         * Return an array of two BigNumbers representing the value of this BigNumber as a simple
         * fraction with an integer numerator and an integer denominator.
         * The denominator will be a positive non-zero value less than or equal to the specified
         * maximum denominator. If a maximum denominator is not specified, the denominator will be
         * the lowest value necessary to represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
         *
         * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
         */
        P.toFraction = function (md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
            x = this,
            xc = x.c;
    
          if (md != null) {
            n = new BigNumber(md);
    
            // Throw if md is less than one or is not an integer, unless it is Infinity.
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error
                (bignumberError + 'Argument ' +
                  (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
            }
          }
    
          if (!xc) return new BigNumber(x);
    
          d = new BigNumber(ONE);
          n1 = d0 = new BigNumber(ONE);
          d1 = n0 = new BigNumber(ONE);
          s = coeffToString(xc);
    
          // Determine initial denominator.
          // d is a power of 10 and the minimum max denominator that specifies the value exactly.
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;
    
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber(s);
    
          // n0 = d1 = 0
          n0.c[0] = 0;
    
          for (; ;)  {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
    
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
    
          // Determine which fraction is closer to x, n0/d0 or n1/d1
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
              div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    
          MAX_EXP = exp;
    
          return r;
        };
    
    
        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
          return +valueOf(this);
        };
    
    
        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
         */
        P.toPrecision = function (sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
    
    
        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to ALPHABET.length inclusive.
         *
         * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
         */
        P.toString = function (b) {
          var str,
            n = this,
            s = n.s,
            e = n.e;
    
          // Infinity or NaN?
          if (e === null) {
            if (s) {
              str = 'Infinity';
              if (s < 0) str = '-' + str;
            } else {
              str = 'NaN';
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS
               ? toExponential(coeffToString(n.c), e)
               : toFixedPoint(coeffToString(n.c), e, '0');
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, '0');
            } else {
              intCheck(b, 2, ALPHABET.length, 'Base');
              str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
            }
    
            if (s < 0 && n.c[0]) str = '-' + str;
          }
    
          return str;
        };
    
    
        /*
         * Return as toString, but do not accept a base argument, and include the minus sign for
         * negative zero.
         */
        P.valueOf = P.toJSON = function () {
          return valueOf(this);
        };
    
    
        P._isBigNumber = true;
    
        if (configObject != null) BigNumber.set(configObject);
    
        return BigNumber;
      }
    
    
      // PRIVATE HELPER FUNCTIONS
    
      // These functions don't need access to variables,
      // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.
    
    
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
    
    
      // Return a coefficient array as a string of base 10 digits.
      function coeffToString(a) {
        var s, z,
          i = 1,
          j = a.length,
          r = a[0] + '';
    
        for (; i < j;) {
          s = a[i++] + '';
          z = LOG_BASE - s.length;
          for (; z--; s = '0' + s);
          r += s;
        }
    
        // Determine trailing zeros.
        for (j = r.length; r.charCodeAt(--j) === 48;);
    
        return r.slice(0, j + 1 || 1);
      }
    
    
      // Compare the value of BigNumbers x and y.
      function compare(x, y) {
        var a, b,
          xc = x.c,
          yc = y.c,
          i = x.s,
          j = y.s,
          k = x.e,
          l = y.e;
    
        // Either NaN?
        if (!i || !j) return null;
    
        a = xc && !xc[0];
        b = yc && !yc[0];
    
        // Either zero?
        if (a || b) return a ? b ? 0 : -j : i;
    
        // Signs differ?
        if (i != j) return i;
    
        a = i < 0;
        b = k == l;
    
        // Either Infinity?
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
    
        // Compare exponents.
        if (!b) return k > l ^ a ? 1 : -1;
    
        j = (k = xc.length) < (l = yc.length) ? k : l;
    
        // Compare digit by digit.
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
    
        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
    
    
      /*
       * Check that n is a primitive number, an integer, and in range, otherwise throw.
       */
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error
           (bignumberError + (name || 'Argument') + (typeof n == 'number'
             ? n < min || n > max ? ' out of range: ' : ' not an integer: '
             : ' not a primitive number: ') + String(n));
        }
      }
    
    
      // Assumes finite n.
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
    
    
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
         (e < 0 ? 'e' : 'e+') + e;
      }
    
    
      function toFixedPoint(str, e, z) {
        var len, zs;
    
        // Negative exponent?
        if (e < 0) {
    
          // Prepend zeros.
          for (zs = z + '.'; ++e; zs += z);
          str = zs + str;
    
        // Positive exponent
        } else {
          len = str.length;
    
          // Append zeros.
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z);
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + '.' + str.slice(e);
          }
        }
    
        return str;
      }
    
    
      // EXPORT
    
    
      BigNumber = clone();
      BigNumber['default'] = BigNumber.BigNumber = BigNumber;
    
      // AMD.
      if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    
      // Node.js and other environments that support module.exports.
      } else {}
    })(this);
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/node_modules/buffer/index.js":
    /*!********************************************************!*\
      !*** ./node_modules/borc/node_modules/buffer/index.js ***!
      \********************************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */
    
    
    
    var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
    var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
    var customInspectSymbol =
      (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
        ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
        : null
    
    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    
    var K_MAX_LENGTH = 0x7fffffff
    exports.kMaxLength = K_MAX_LENGTH
    
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
    
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
        typeof console.error === 'function') {
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      )
    }
    
    function typedArraySupport () {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1)
        var proto = { foo: function () { return 42 } }
        Object.setPrototypeOf(proto, Uint8Array.prototype)
        Object.setPrototypeOf(arr, proto)
        return arr.foo() === 42
      } catch (e) {
        return false
      }
    }
    
    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.buffer
      }
    })
    
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.byteOffset
      }
    })
    
    function createBuffer (length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"')
      }
      // Return an augmented `Uint8Array` instance
      var buf = new Uint8Array(length)
      Object.setPrototypeOf(buf, Buffer.prototype)
      return buf
    }
    
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */
    
    function Buffer (arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          )
        }
        return allocUnsafe(arg)
      }
      return from(arg, encodingOrOffset, length)
    }
    
    Buffer.poolSize = 8192 // not used by this implementation
    
    function from (value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset)
      }
    
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value)
      }
    
      if (value == null) {
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }
    
      if (isInstance(value, ArrayBuffer) ||
          (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }
    
      if (typeof SharedArrayBuffer !== 'undefined' &&
          (isInstance(value, SharedArrayBuffer) ||
          (value && isInstance(value.buffer, SharedArrayBuffer)))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }
    
      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        )
      }
    
      var valueOf = value.valueOf && value.valueOf()
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length)
      }
    
      var b = fromObject(value)
      if (b) return b
    
      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
          typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(
          value[Symbol.toPrimitive]('string'), encodingOrOffset, length
        )
      }
    
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }
    
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length)
    }
    
    // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
    Object.setPrototypeOf(Buffer, Uint8Array)
    
    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number')
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"')
      }
    }
    
    function alloc (size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill)
      }
      return createBuffer(size)
    }
    
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding)
    }
    
    function allocUnsafe (size) {
      assertSize(size)
      return createBuffer(size < 0 ? 0 : checked(size) | 0)
    }
    
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size)
    }
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size)
    }
    
    function fromString (string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }
    
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    
      var length = byteLength(string, encoding) | 0
      var buf = createBuffer(length)
    
      var actual = buf.write(string, encoding)
    
      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual)
      }
    
      return buf
    }
    
    function fromArrayLike (array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0
      var buf = createBuffer(length)
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255
      }
      return buf
    }
    
    function fromArrayView (arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView)
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
      }
      return fromArrayLike(arrayView)
    }
    
    function fromArrayBuffer (array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds')
      }
    
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds')
      }
    
      var buf
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array)
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset)
      } else {
        buf = new Uint8Array(array, byteOffset, length)
      }
    
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(buf, Buffer.prototype)
    
      return buf
    }
    
    function fromObject (obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0
        var buf = createBuffer(len)
    
        if (buf.length === 0) {
          return buf
        }
    
        obj.copy(buf, 0, 0, len)
        return buf
      }
    
      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }
    
      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }
    
    function checked (length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
      }
      return length | 0
    }
    
    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }
    
    Buffer.isBuffer = function isBuffer (b) {
      return b != null && b._isBuffer === true &&
        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    }
    
    Buffer.compare = function compare (a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      }
    
      if (a === b) return 0
    
      var x = a.length
      var y = b.length
    
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }
    
    Buffer.concat = function concat (list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
    
      if (list.length === 0) {
        return Buffer.alloc(0)
      }
    
      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }
    
      var buffer = Buffer.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list.length; ++i) {
        var buf = list[i]
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer.from(buf).copy(buffer, pos)
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            )
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        } else {
          buf.copy(buffer, pos)
        }
        pos += buf.length
      }
      return buffer
    }
    
    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
          'Received type ' + typeof string
        )
      }
    
      var len = string.length
      var mustMatch = (arguments.length > 2 && arguments[2] === true)
      if (!mustMatch && len === 0) return 0
    
      // Use a for loop to avoid recursion
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            }
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength
    
    function slowToString (encoding, start, end) {
      var loweredCase = false
    
      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
    
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }
    
      if (end === undefined || end > this.length) {
        end = this.length
      }
    
      if (end <= 0) {
        return ''
      }
    
      // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0
    
      if (end <= start) {
        return ''
      }
    
      if (!encoding) encoding = 'utf8'
    
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)
    
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)
    
          case 'ascii':
            return asciiSlice(this, start, end)
    
          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)
    
          case 'base64':
            return base64Slice(this, start, end)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }
    
    // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154
    Buffer.prototype._isBuffer = true
    
    function swap (b, n, m) {
      var i = b[n]
      b[n] = b[m]
      b[m] = i
    }
    
    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }
    
    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }
    
    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }
    
    Buffer.prototype.toString = function toString () {
      var length = this.length
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    
    Buffer.prototype.toLocaleString = Buffer.prototype.toString
    
    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }
    
    Buffer.prototype.inspect = function inspect () {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
      if (this.length > max) str += ' ... '
      return '<Buffer ' + str + '>'
    }
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
    }
    
    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength)
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. ' +
          'Received type ' + (typeof target)
        )
      }
    
      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }
    
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }
    
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
    
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
    
      if (this === target) return 0
    
      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)
    
      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)
    
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1
    
      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset // Coerce to Number.
      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }
    
      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }
    
      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }
    
      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }
    
      throw new TypeError('val must be string, number or Buffer')
    }
    
    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1
      var arrLength = arr.length
      var valLength = val.length
    
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }
    
      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }
    
      var i
      if (dir) {
        var foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          var found = true
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }
    
      return -1
    }
    
    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    
    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }
    
    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }
    
    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }
    
      var strLen = string.length
    
      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (numberIsNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }
    
    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }
    
    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }
    
    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0
        if (isFinite(length)) {
          length = length >>> 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }
    
      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining
    
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }
    
      if (!encoding) encoding = 'utf8'
    
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)
    
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)
    
          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length)
    
          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    
    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    
    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }
    
    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []
    
      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF)
          ? 4
          : (firstByte > 0xDF)
              ? 3
              : (firstByte > 0xBF)
                  ? 2
                  : 1
    
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint
    
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }
    
        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
    
        res.push(codePoint)
        i += bytesPerSequence
      }
    
      return decodeCodePointsArray(res)
    }
    
    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000
    
    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }
    
      // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }
    
    function asciiSlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }
    
    function latin1Slice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }
    
    function hexSlice (buf, start, end) {
      var len = buf.length
    
      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len
    
      var out = ''
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]]
      }
      return out
    }
    
    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
      }
      return res
    }
    
    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end
    
      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }
    
      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }
    
      if (end < start) end = start
    
      var newBuf = this.subarray(start, end)
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(newBuf, Buffer.prototype)
    
      return newBuf
    }
    
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    
    Buffer.prototype.readUintLE =
    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUintBE =
    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }
    
      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUint8 =
    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }
    
    Buffer.prototype.readUint16LE =
    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }
    
    Buffer.prototype.readUint16BE =
    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }
    
    Buffer.prototype.readUint32LE =
    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    }
    
    Buffer.prototype.readUint32BE =
    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    }
    
    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }
    
    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }
    
    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }
    
    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }
    
    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }
    
    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }
    
    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }
    
    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }
    
    Buffer.prototype.writeUintLE =
    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUintBE =
    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUint8 =
    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeUint16LE =
    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      return offset + 2
    }
    
    Buffer.prototype.writeUint16BE =
    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
      return offset + 2
    }
    
    Buffer.prototype.writeUint32LE =
    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      this[offset + 3] = (value >>> 24)
      this[offset + 2] = (value >>> 16)
      this[offset + 1] = (value >>> 8)
      this[offset] = (value & 0xff)
      return offset + 4
    }
    
    Buffer.prototype.writeUint32BE =
    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
      return offset + 4
    }
    
    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = byteLength - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      return offset + 2
    }
    
    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
      return offset + 2
    }
    
    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      this[offset + 2] = (value >>> 16)
      this[offset + 3] = (value >>> 24)
      return offset + 4
    }
    
    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
      return offset + 4
    }
    
    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }
    
    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }
    
    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    
    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }
    
    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    
    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start
    
      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
    
      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
    
      var len = end - start
    
      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end)
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        )
      }
    
      return len
    }
    
    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if ((encoding === 'utf8' && code < 128) ||
              encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255
      } else if (typeof val === 'boolean') {
        val = Number(val)
      }
    
      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }
    
      if (end <= start) {
        return this
      }
    
      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0
    
      if (!val) val = 0
    
      var i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : Buffer.from(val, encoding)
        var len = bytes.length
        if (len === 0) {
          throw new TypeError('The value "' + val +
            '" is invalid for argument "value"')
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
    
      return this
    }
    
    // HELPER FUNCTIONS
    // ================
    
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
    
    function base64clean (str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = str.trim().replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }
    
    function utf8ToBytes (string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []
    
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)
    
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }
    
            // valid lead
            leadSurrogate = codePoint
    
            continue
          }
    
          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }
    
          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }
    
        leadSurrogate = null
    
        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }
    
      return bytes
    }
    
    function asciiToBytes (str) {
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }
    
    function utf16leToBytes (str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break
    
        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }
    
      return byteArray
    }
    
    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }
    
    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }
    
    // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166
    function isInstance (obj, type) {
      return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
          obj.constructor.name === type.name)
    }
    function numberIsNaN (obj) {
      // For IE11 support
      return obj !== obj // eslint-disable-line no-self-compare
    }
    
    // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219
    var hexSliceLookupTable = (function () {
      var alphabet = '0123456789abcdef'
      var table = new Array(256)
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j]
        }
      }
      return table
    })()
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/constants.js":
    /*!********************************************!*\
      !*** ./node_modules/borc/src/constants.js ***!
      \********************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    
    
    const Bignumber = (__webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js").BigNumber)
    
    exports.MT = {
      POS_INT: 0,
      NEG_INT: 1,
      BYTE_STRING: 2,
      UTF8_STRING: 3,
      ARRAY: 4,
      MAP: 5,
      TAG: 6,
      SIMPLE_FLOAT: 7
    }
    
    exports.TAG = {
      DATE_STRING: 0,
      DATE_EPOCH: 1,
      POS_BIGINT: 2,
      NEG_BIGINT: 3,
      DECIMAL_FRAC: 4,
      BIGFLOAT: 5,
      BASE64URL_EXPECTED: 21,
      BASE64_EXPECTED: 22,
      BASE16_EXPECTED: 23,
      CBOR: 24,
      URI: 32,
      BASE64URL: 33,
      BASE64: 34,
      REGEXP: 35,
      MIME: 36
    }
    
    exports.NUMBYTES = {
      ZERO: 0,
      ONE: 24,
      TWO: 25,
      FOUR: 26,
      EIGHT: 27,
      INDEFINITE: 31
    }
    
    exports.SIMPLE = {
      FALSE: 20,
      TRUE: 21,
      NULL: 22,
      UNDEFINED: 23
    }
    
    exports.SYMS = {
      NULL: Symbol('null'),
      UNDEFINED: Symbol('undef'),
      PARENT: Symbol('parent'),
      BREAK: Symbol('break'),
      STREAM: Symbol('stream')
    }
    
    exports.SHIFT32 = Math.pow(2, 32)
    exports.SHIFT16 = Math.pow(2, 16)
    
    exports.MAX_SAFE_HIGH = 0x1fffff
    exports.NEG_ONE = new Bignumber(-1)
    exports.TEN = new Bignumber(10)
    exports.TWO = new Bignumber(2)
    
    exports.PARENT = {
      ARRAY: 0,
      OBJECT: 1,
      MAP: 2,
      TAG: 3,
      BYTE_STRING: 4,
      UTF8_STRING: 5
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/decoder.asm.js":
    /*!**********************************************!*\
      !*** ./node_modules/borc/src/decoder.asm.js ***!
      \**********************************************/
    /***/ ((module) => {
    
    /* eslint-disable */
    
    module.exports = function decodeAsm (stdlib, foreign, buffer) {
      'use asm'
    
      // -- Imports
    
      var heap = new stdlib.Uint8Array(buffer)
      // var log = foreign.log
      var pushInt = foreign.pushInt
      var pushInt32 = foreign.pushInt32
      var pushInt32Neg = foreign.pushInt32Neg
      var pushInt64 = foreign.pushInt64
      var pushInt64Neg = foreign.pushInt64Neg
      var pushFloat = foreign.pushFloat
      var pushFloatSingle = foreign.pushFloatSingle
      var pushFloatDouble = foreign.pushFloatDouble
      var pushTrue = foreign.pushTrue
      var pushFalse = foreign.pushFalse
      var pushUndefined = foreign.pushUndefined
      var pushNull = foreign.pushNull
      var pushInfinity = foreign.pushInfinity
      var pushInfinityNeg = foreign.pushInfinityNeg
      var pushNaN = foreign.pushNaN
      var pushNaNNeg = foreign.pushNaNNeg
    
      var pushArrayStart = foreign.pushArrayStart
      var pushArrayStartFixed = foreign.pushArrayStartFixed
      var pushArrayStartFixed32 = foreign.pushArrayStartFixed32
      var pushArrayStartFixed64 = foreign.pushArrayStartFixed64
      var pushObjectStart = foreign.pushObjectStart
      var pushObjectStartFixed = foreign.pushObjectStartFixed
      var pushObjectStartFixed32 = foreign.pushObjectStartFixed32
      var pushObjectStartFixed64 = foreign.pushObjectStartFixed64
    
      var pushByteString = foreign.pushByteString
      var pushByteStringStart = foreign.pushByteStringStart
      var pushUtf8String = foreign.pushUtf8String
      var pushUtf8StringStart = foreign.pushUtf8StringStart
    
      var pushSimpleUnassigned = foreign.pushSimpleUnassigned
    
      var pushTagStart = foreign.pushTagStart
      var pushTagStart4 = foreign.pushTagStart4
      var pushTagStart8 = foreign.pushTagStart8
      var pushTagUnassigned = foreign.pushTagUnassigned
    
      var pushBreak = foreign.pushBreak
    
      var pow = stdlib.Math.pow
    
      // -- Constants
    
    
      // -- Mutable Variables
    
      var offset = 0
      var inputLength = 0
      var code = 0
    
      // Decode a cbor string represented as Uint8Array
      // which is allocated on the heap from 0 to inputLength
      //
      // input - Int
      //
      // Returns Code - Int,
      // Success = 0
      // Error > 0
      function parse (input) {
        input = input | 0
    
        offset = 0
        inputLength = input
    
        while ((offset | 0) < (inputLength | 0)) {
          code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0
    
          if ((code | 0) > 0) {
            break
          }
        }
    
        return code | 0
      }
    
      // -- Helper Function
    
      function checkOffset (n) {
        n = n | 0
    
        if ((((offset | 0) + (n | 0)) | 0) < (inputLength | 0)) {
          return 0
        }
    
        return 1
      }
    
      function readUInt16 (n) {
        n = n | 0
    
        return (
          (heap[n | 0] << 8) | heap[(n + 1) | 0]
        ) | 0
      }
    
      function readUInt32 (n) {
        n = n | 0
    
        return (
          (heap[n | 0] << 24) | (heap[(n + 1) | 0] << 16) | (heap[(n + 2) | 0] << 8) | heap[(n + 3) | 0]
        ) | 0
      }
    
      // -- Initial Byte Handlers
    
      function INT_P (octet) {
        octet = octet | 0
    
        pushInt(octet | 0)
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function UINT_P_8 (octet) {
        octet = octet | 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        pushInt(heap[(offset + 1) | 0] | 0)
    
        offset = (offset + 2) | 0
    
        return 0
      }
    
      function UINT_P_16 (octet) {
        octet = octet | 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        pushInt(
          readUInt16((offset + 1) | 0) | 0
        )
    
        offset = (offset + 3) | 0
    
        return 0
      }
    
      function UINT_P_32 (octet) {
        octet = octet | 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        pushInt32(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0
        )
    
        offset = (offset + 5) | 0
    
        return 0
      }
    
      function UINT_P_64 (octet) {
        octet = octet | 0
    
        if (checkOffset(8) | 0) {
          return 1
        }
    
        pushInt64(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0,
          readUInt16((offset + 5) | 0) | 0,
          readUInt16((offset + 7) | 0) | 0
        )
    
        offset = (offset + 9) | 0
    
        return 0
      }
    
      function INT_N (octet) {
        octet = octet | 0
    
        pushInt((-1 - ((octet - 32) | 0)) | 0)
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function UINT_N_8 (octet) {
        octet = octet | 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        pushInt(
          (-1 - (heap[(offset + 1) | 0] | 0)) | 0
        )
    
        offset = (offset + 2) | 0
    
        return 0
      }
    
      function UINT_N_16 (octet) {
        octet = octet | 0
    
        var val = 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        val = readUInt16((offset + 1) | 0) | 0
        pushInt((-1 - (val | 0)) | 0)
    
        offset = (offset + 3) | 0
    
        return 0
      }
    
      function UINT_N_32 (octet) {
        octet = octet | 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        pushInt32Neg(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0
        )
    
        offset = (offset + 5) | 0
    
        return 0
      }
    
      function UINT_N_64 (octet) {
        octet = octet | 0
    
        if (checkOffset(8) | 0) {
          return 1
        }
    
        pushInt64Neg(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0,
          readUInt16((offset + 5) | 0) | 0,
          readUInt16((offset + 7) | 0) | 0
        )
    
        offset = (offset + 9) | 0
    
        return 0
      }
    
      function BYTE_STRING (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var step = 0
    
        step = (octet - 64) | 0
        if (checkOffset(step | 0) | 0) {
          return 1
        }
    
        start = (offset + 1) | 0
        end = (((offset + 1) | 0) + (step | 0)) | 0
    
        pushByteString(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function BYTE_STRING_8 (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var length = 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        length = heap[(offset + 1) | 0] | 0
        start = (offset + 2) | 0
        end = (((offset + 2) | 0) + (length | 0)) | 0
    
        if (checkOffset((length + 1) | 0) | 0) {
          return 1
        }
    
        pushByteString(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function BYTE_STRING_16 (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var length = 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        length = readUInt16((offset + 1) | 0) | 0
        start = (offset + 3) | 0
        end = (((offset + 3) | 0) + (length | 0)) | 0
    
    
        if (checkOffset((length + 2) | 0) | 0) {
          return 1
        }
    
        pushByteString(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function BYTE_STRING_32 (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var length = 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        length = readUInt32((offset + 1) | 0) | 0
        start = (offset + 5) | 0
        end = (((offset + 5) | 0) + (length | 0)) | 0
    
    
        if (checkOffset((length + 4) | 0) | 0) {
          return 1
        }
    
        pushByteString(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function BYTE_STRING_64 (octet) {
        // NOT IMPLEMENTED
        octet = octet | 0
    
        return 1
      }
    
      function BYTE_STRING_BREAK (octet) {
        octet = octet | 0
    
        pushByteStringStart()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function UTF8_STRING (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var step = 0
    
        step = (octet - 96) | 0
    
        if (checkOffset(step | 0) | 0) {
          return 1
        }
    
        start = (offset + 1) | 0
        end = (((offset + 1) | 0) + (step | 0)) | 0
    
        pushUtf8String(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function UTF8_STRING_8 (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var length = 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        length = heap[(offset + 1) | 0] | 0
        start = (offset + 2) | 0
        end = (((offset + 2) | 0) + (length | 0)) | 0
    
        if (checkOffset((length + 1) | 0) | 0) {
          return 1
        }
    
        pushUtf8String(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function UTF8_STRING_16 (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var length = 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        length = readUInt16((offset + 1) | 0) | 0
        start = (offset + 3) | 0
        end = (((offset + 3) | 0) + (length | 0)) | 0
    
        if (checkOffset((length + 2) | 0) | 0) {
          return 1
        }
    
        pushUtf8String(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function UTF8_STRING_32 (octet) {
        octet = octet | 0
    
        var start = 0
        var end = 0
        var length = 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        length = readUInt32((offset + 1) | 0) | 0
        start = (offset + 5) | 0
        end = (((offset + 5) | 0) + (length | 0)) | 0
    
        if (checkOffset((length + 4) | 0) | 0) {
          return 1
        }
    
        pushUtf8String(start | 0, end | 0)
    
        offset = end | 0
    
        return 0
      }
    
      function UTF8_STRING_64 (octet) {
        // NOT IMPLEMENTED
        octet = octet | 0
    
        return 1
      }
    
      function UTF8_STRING_BREAK (octet) {
        octet = octet | 0
    
        pushUtf8StringStart()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function ARRAY (octet) {
        octet = octet | 0
    
        pushArrayStartFixed((octet - 128) | 0)
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function ARRAY_8 (octet) {
        octet = octet | 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        pushArrayStartFixed(heap[(offset + 1) | 0] | 0)
    
        offset = (offset + 2) | 0
    
        return 0
      }
    
      function ARRAY_16 (octet) {
        octet = octet | 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        pushArrayStartFixed(
          readUInt16((offset + 1) | 0) | 0
        )
    
        offset = (offset + 3) | 0
    
        return 0
      }
    
      function ARRAY_32 (octet) {
        octet = octet | 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        pushArrayStartFixed32(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0
        )
    
        offset = (offset + 5) | 0
    
        return 0
      }
    
      function ARRAY_64 (octet) {
        octet = octet | 0
    
        if (checkOffset(8) | 0) {
          return 1
        }
    
        pushArrayStartFixed64(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0,
          readUInt16((offset + 5) | 0) | 0,
          readUInt16((offset + 7) | 0) | 0
        )
    
        offset = (offset + 9) | 0
    
        return 0
      }
    
      function ARRAY_BREAK (octet) {
        octet = octet | 0
    
        pushArrayStart()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function MAP (octet) {
        octet = octet | 0
    
        var step = 0
    
        step = (octet - 160) | 0
    
        if (checkOffset(step | 0) | 0) {
          return 1
        }
    
        pushObjectStartFixed(step | 0)
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function MAP_8 (octet) {
        octet = octet | 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        pushObjectStartFixed(heap[(offset + 1) | 0] | 0)
    
        offset = (offset + 2) | 0
    
        return 0
      }
    
      function MAP_16 (octet) {
        octet = octet | 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        pushObjectStartFixed(
          readUInt16((offset + 1) | 0) | 0
        )
    
        offset = (offset + 3) | 0
    
        return 0
      }
    
      function MAP_32 (octet) {
        octet = octet | 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        pushObjectStartFixed32(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0
        )
    
        offset = (offset + 5) | 0
    
        return 0
      }
    
      function MAP_64 (octet) {
        octet = octet | 0
    
        if (checkOffset(8) | 0) {
          return 1
        }
    
        pushObjectStartFixed64(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0,
          readUInt16((offset + 5) | 0) | 0,
          readUInt16((offset + 7) | 0) | 0
        )
    
        offset = (offset + 9) | 0
    
        return 0
      }
    
      function MAP_BREAK (octet) {
        octet = octet | 0
    
        pushObjectStart()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function TAG_KNOWN (octet) {
        octet = octet | 0
    
        pushTagStart((octet - 192| 0) | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_BIGNUM_POS (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_BIGNUM_NEG (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_FRAC (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_BIGNUM_FLOAT (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_UNASSIGNED (octet) {
        octet = octet | 0
    
        pushTagStart((octet - 192| 0) | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_BASE64_URL (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_BASE64 (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_BASE16 (octet) {
        octet = octet | 0
    
        pushTagStart(octet | 0)
    
        offset = (offset + 1 | 0)
    
        return 0
      }
    
      function TAG_MORE_1 (octet) {
        octet = octet | 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        pushTagStart(heap[(offset + 1) | 0] | 0)
    
        offset = (offset + 2 | 0)
    
        return 0
      }
    
      function TAG_MORE_2 (octet) {
        octet = octet | 0
    
        if (checkOffset(2) | 0) {
          return 1
        }
    
        pushTagStart(
          readUInt16((offset + 1) | 0) | 0
        )
    
        offset = (offset + 3 | 0)
    
        return 0
      }
    
      function TAG_MORE_4 (octet) {
        octet = octet | 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        pushTagStart4(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0
        )
    
        offset = (offset + 5 | 0)
    
        return 0
      }
    
      function TAG_MORE_8 (octet) {
        octet = octet | 0
    
        if (checkOffset(8) | 0) {
          return 1
        }
    
        pushTagStart8(
          readUInt16((offset + 1) | 0) | 0,
          readUInt16((offset + 3) | 0) | 0,
          readUInt16((offset + 5) | 0) | 0,
          readUInt16((offset + 7) | 0) | 0
        )
    
        offset = (offset + 9 | 0)
    
        return 0
      }
    
      function SIMPLE_UNASSIGNED (octet) {
        octet = octet | 0
    
        pushSimpleUnassigned(((octet | 0) - 224) | 0)
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function SIMPLE_FALSE (octet) {
        octet = octet | 0
    
        pushFalse()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function SIMPLE_TRUE (octet) {
        octet = octet | 0
    
        pushTrue()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function SIMPLE_NULL (octet) {
        octet = octet | 0
    
        pushNull()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function SIMPLE_UNDEFINED (octet) {
        octet = octet | 0
    
        pushUndefined()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      function SIMPLE_BYTE (octet) {
        octet = octet | 0
    
        if (checkOffset(1) | 0) {
          return 1
        }
    
        pushSimpleUnassigned(heap[(offset + 1) | 0] | 0)
    
        offset = (offset + 2)  | 0
    
        return 0
      }
    
      function SIMPLE_FLOAT_HALF (octet) {
        octet = octet | 0
    
        var f = 0
        var g = 0
        var sign = 1.0
        var exp = 0.0
        var mant = 0.0
        var r = 0.0
        if (checkOffset(2) | 0) {
          return 1
        }
    
        f = heap[(offset + 1) | 0] | 0
        g = heap[(offset + 2) | 0] | 0
    
        if ((f | 0) & 0x80) {
          sign = -1.0
        }
    
        exp = +(((f | 0) & 0x7C) >> 2)
        mant = +((((f | 0) & 0x03) << 8) | g)
    
        if (+exp == 0.0) {
          pushFloat(+(
            (+sign) * +5.9604644775390625e-8 * (+mant)
          ))
        } else if (+exp == 31.0) {
          if (+sign == 1.0) {
            if (+mant > 0.0) {
              pushNaN()
            } else {
              pushInfinity()
            }
          } else {
            if (+mant > 0.0) {
              pushNaNNeg()
            } else {
              pushInfinityNeg()
            }
          }
        } else {
          pushFloat(+(
            +sign * pow(+2, +(+exp - 25.0)) * +(1024.0 + mant)
          ))
        }
    
        offset = (offset + 3) | 0
    
        return 0
      }
    
      function SIMPLE_FLOAT_SINGLE (octet) {
        octet = octet | 0
    
        if (checkOffset(4) | 0) {
          return 1
        }
    
        pushFloatSingle(
          heap[(offset + 1) | 0] | 0,
          heap[(offset + 2) | 0] | 0,
          heap[(offset + 3) | 0] | 0,
          heap[(offset + 4) | 0] | 0
        )
    
        offset = (offset + 5) | 0
    
        return 0
      }
    
      function SIMPLE_FLOAT_DOUBLE (octet) {
        octet = octet | 0
    
        if (checkOffset(8) | 0) {
          return 1
        }
    
        pushFloatDouble(
          heap[(offset + 1) | 0] | 0,
          heap[(offset + 2) | 0] | 0,
          heap[(offset + 3) | 0] | 0,
          heap[(offset + 4) | 0] | 0,
          heap[(offset + 5) | 0] | 0,
          heap[(offset + 6) | 0] | 0,
          heap[(offset + 7) | 0] | 0,
          heap[(offset + 8) | 0] | 0
        )
    
        offset = (offset + 9) | 0
    
        return 0
      }
    
      function ERROR (octet) {
        octet = octet | 0
    
        return 1
      }
    
      function BREAK (octet) {
        octet = octet | 0
    
        pushBreak()
    
        offset = (offset + 1) | 0
    
        return 0
      }
    
      // -- Jump Table
    
      var jumpTable = [
        // Integer 0x00..0x17 (0..23)
        INT_P, // 0x00
        INT_P, // 0x01
        INT_P, // 0x02
        INT_P, // 0x03
        INT_P, // 0x04
        INT_P, // 0x05
        INT_P, // 0x06
        INT_P, // 0x07
        INT_P, // 0x08
        INT_P, // 0x09
        INT_P, // 0x0A
        INT_P, // 0x0B
        INT_P, // 0x0C
        INT_P, // 0x0D
        INT_P, // 0x0E
        INT_P, // 0x0F
        INT_P, // 0x10
        INT_P, // 0x11
        INT_P, // 0x12
        INT_P, // 0x13
        INT_P, // 0x14
        INT_P, // 0x15
        INT_P, // 0x16
        INT_P, // 0x17
        // Unsigned integer (one-byte uint8_t follows)
        UINT_P_8, // 0x18
        // Unsigned integer (two-byte uint16_t follows)
        UINT_P_16, // 0x19
        // Unsigned integer (four-byte uint32_t follows)
        UINT_P_32, // 0x1a
        // Unsigned integer (eight-byte uint64_t follows)
        UINT_P_64, // 0x1b
        ERROR, // 0x1c
        ERROR, // 0x1d
        ERROR, // 0x1e
        ERROR, // 0x1f
        // Negative integer -1-0x00..-1-0x17 (-1..-24)
        INT_N, // 0x20
        INT_N, // 0x21
        INT_N, // 0x22
        INT_N, // 0x23
        INT_N, // 0x24
        INT_N, // 0x25
        INT_N, // 0x26
        INT_N, // 0x27
        INT_N, // 0x28
        INT_N, // 0x29
        INT_N, // 0x2A
        INT_N, // 0x2B
        INT_N, // 0x2C
        INT_N, // 0x2D
        INT_N, // 0x2E
        INT_N, // 0x2F
        INT_N, // 0x30
        INT_N, // 0x31
        INT_N, // 0x32
        INT_N, // 0x33
        INT_N, // 0x34
        INT_N, // 0x35
        INT_N, // 0x36
        INT_N, // 0x37
        // Negative integer -1-n (one-byte uint8_t for n follows)
        UINT_N_8, // 0x38
        // Negative integer -1-n (two-byte uint16_t for n follows)
        UINT_N_16, // 0x39
        // Negative integer -1-n (four-byte uint32_t for nfollows)
        UINT_N_32, // 0x3a
        // Negative integer -1-n (eight-byte uint64_t for n follows)
        UINT_N_64, // 0x3b
        ERROR, // 0x3c
        ERROR, // 0x3d
        ERROR, // 0x3e
        ERROR, // 0x3f
        // byte string (0x00..0x17 bytes follow)
        BYTE_STRING, // 0x40
        BYTE_STRING, // 0x41
        BYTE_STRING, // 0x42
        BYTE_STRING, // 0x43
        BYTE_STRING, // 0x44
        BYTE_STRING, // 0x45
        BYTE_STRING, // 0x46
        BYTE_STRING, // 0x47
        BYTE_STRING, // 0x48
        BYTE_STRING, // 0x49
        BYTE_STRING, // 0x4A
        BYTE_STRING, // 0x4B
        BYTE_STRING, // 0x4C
        BYTE_STRING, // 0x4D
        BYTE_STRING, // 0x4E
        BYTE_STRING, // 0x4F
        BYTE_STRING, // 0x50
        BYTE_STRING, // 0x51
        BYTE_STRING, // 0x52
        BYTE_STRING, // 0x53
        BYTE_STRING, // 0x54
        BYTE_STRING, // 0x55
        BYTE_STRING, // 0x56
        BYTE_STRING, // 0x57
        // byte string (one-byte uint8_t for n, and then n bytes follow)
        BYTE_STRING_8, // 0x58
        // byte string (two-byte uint16_t for n, and then n bytes follow)
        BYTE_STRING_16, // 0x59
        // byte string (four-byte uint32_t for n, and then n bytes follow)
        BYTE_STRING_32, // 0x5a
        // byte string (eight-byte uint64_t for n, and then n bytes follow)
        BYTE_STRING_64, // 0x5b
        ERROR, // 0x5c
        ERROR, // 0x5d
        ERROR, // 0x5e
        // byte string, byte strings follow, terminated by "break"
        BYTE_STRING_BREAK, // 0x5f
        // UTF-8 string (0x00..0x17 bytes follow)
        UTF8_STRING, // 0x60
        UTF8_STRING, // 0x61
        UTF8_STRING, // 0x62
        UTF8_STRING, // 0x63
        UTF8_STRING, // 0x64
        UTF8_STRING, // 0x65
        UTF8_STRING, // 0x66
        UTF8_STRING, // 0x67
        UTF8_STRING, // 0x68
        UTF8_STRING, // 0x69
        UTF8_STRING, // 0x6A
        UTF8_STRING, // 0x6B
        UTF8_STRING, // 0x6C
        UTF8_STRING, // 0x6D
        UTF8_STRING, // 0x6E
        UTF8_STRING, // 0x6F
        UTF8_STRING, // 0x70
        UTF8_STRING, // 0x71
        UTF8_STRING, // 0x72
        UTF8_STRING, // 0x73
        UTF8_STRING, // 0x74
        UTF8_STRING, // 0x75
        UTF8_STRING, // 0x76
        UTF8_STRING, // 0x77
        // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
        UTF8_STRING_8, // 0x78
        // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
        UTF8_STRING_16, // 0x79
        // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
        UTF8_STRING_32, // 0x7a
        // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
        UTF8_STRING_64, // 0x7b
        // UTF-8 string, UTF-8 strings follow, terminated by "break"
        ERROR, // 0x7c
        ERROR, // 0x7d
        ERROR, // 0x7e
        UTF8_STRING_BREAK, // 0x7f
        // array (0x00..0x17 data items follow)
        ARRAY, // 0x80
        ARRAY, // 0x81
        ARRAY, // 0x82
        ARRAY, // 0x83
        ARRAY, // 0x84
        ARRAY, // 0x85
        ARRAY, // 0x86
        ARRAY, // 0x87
        ARRAY, // 0x88
        ARRAY, // 0x89
        ARRAY, // 0x8A
        ARRAY, // 0x8B
        ARRAY, // 0x8C
        ARRAY, // 0x8D
        ARRAY, // 0x8E
        ARRAY, // 0x8F
        ARRAY, // 0x90
        ARRAY, // 0x91
        ARRAY, // 0x92
        ARRAY, // 0x93
        ARRAY, // 0x94
        ARRAY, // 0x95
        ARRAY, // 0x96
        ARRAY, // 0x97
        // array (one-byte uint8_t fo, and then n data items follow)
        ARRAY_8, // 0x98
        // array (two-byte uint16_t for n, and then n data items follow)
        ARRAY_16, // 0x99
        // array (four-byte uint32_t for n, and then n data items follow)
        ARRAY_32, // 0x9a
        // array (eight-byte uint64_t for n, and then n data items follow)
        ARRAY_64, // 0x9b
        // array, data items follow, terminated by "break"
        ERROR, // 0x9c
        ERROR, // 0x9d
        ERROR, // 0x9e
        ARRAY_BREAK, // 0x9f
        // map (0x00..0x17 pairs of data items follow)
        MAP, // 0xa0
        MAP, // 0xa1
        MAP, // 0xa2
        MAP, // 0xa3
        MAP, // 0xa4
        MAP, // 0xa5
        MAP, // 0xa6
        MAP, // 0xa7
        MAP, // 0xa8
        MAP, // 0xa9
        MAP, // 0xaA
        MAP, // 0xaB
        MAP, // 0xaC
        MAP, // 0xaD
        MAP, // 0xaE
        MAP, // 0xaF
        MAP, // 0xb0
        MAP, // 0xb1
        MAP, // 0xb2
        MAP, // 0xb3
        MAP, // 0xb4
        MAP, // 0xb5
        MAP, // 0xb6
        MAP, // 0xb7
        // map (one-byte uint8_t for n, and then n pairs of data items follow)
        MAP_8, // 0xb8
        // map (two-byte uint16_t for n, and then n pairs of data items follow)
        MAP_16, // 0xb9
        // map (four-byte uint32_t for n, and then n pairs of data items follow)
        MAP_32, // 0xba
        // map (eight-byte uint64_t for n, and then n pairs of data items follow)
        MAP_64, // 0xbb
        ERROR, // 0xbc
        ERROR, // 0xbd
        ERROR, // 0xbe
        // map, pairs of data items follow, terminated by "break"
        MAP_BREAK, // 0xbf
        // Text-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN, // 0xc0
        // Epoch-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN, // 0xc1
        // Positive bignum (data item "byte string" follows)
        TAG_KNOWN, // 0xc2
        // Negative bignum (data item "byte string" follows)
        TAG_KNOWN, // 0xc3
        // Decimal Fraction (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN, // 0xc4
        // Bigfloat (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN, // 0xc5
        // (tagged item)
        TAG_UNASSIGNED, // 0xc6
        TAG_UNASSIGNED, // 0xc7
        TAG_UNASSIGNED, // 0xc8
        TAG_UNASSIGNED, // 0xc9
        TAG_UNASSIGNED, // 0xca
        TAG_UNASSIGNED, // 0xcb
        TAG_UNASSIGNED, // 0xcc
        TAG_UNASSIGNED, // 0xcd
        TAG_UNASSIGNED, // 0xce
        TAG_UNASSIGNED, // 0xcf
        TAG_UNASSIGNED, // 0xd0
        TAG_UNASSIGNED, // 0xd1
        TAG_UNASSIGNED, // 0xd2
        TAG_UNASSIGNED, // 0xd3
        TAG_UNASSIGNED, // 0xd4
        // Expected Conversion (data item follows; see Section 2.4.4.2)
        TAG_UNASSIGNED, // 0xd5
        TAG_UNASSIGNED, // 0xd6
        TAG_UNASSIGNED, // 0xd7
        // (more tagged items, 1/2/4/8 bytes and then a data item follow)
        TAG_MORE_1, // 0xd8
        TAG_MORE_2, // 0xd9
        TAG_MORE_4, // 0xda
        TAG_MORE_8, // 0xdb
        ERROR, // 0xdc
        ERROR, // 0xdd
        ERROR, // 0xde
        ERROR, // 0xdf
        // (simple value)
        SIMPLE_UNASSIGNED, // 0xe0
        SIMPLE_UNASSIGNED, // 0xe1
        SIMPLE_UNASSIGNED, // 0xe2
        SIMPLE_UNASSIGNED, // 0xe3
        SIMPLE_UNASSIGNED, // 0xe4
        SIMPLE_UNASSIGNED, // 0xe5
        SIMPLE_UNASSIGNED, // 0xe6
        SIMPLE_UNASSIGNED, // 0xe7
        SIMPLE_UNASSIGNED, // 0xe8
        SIMPLE_UNASSIGNED, // 0xe9
        SIMPLE_UNASSIGNED, // 0xea
        SIMPLE_UNASSIGNED, // 0xeb
        SIMPLE_UNASSIGNED, // 0xec
        SIMPLE_UNASSIGNED, // 0xed
        SIMPLE_UNASSIGNED, // 0xee
        SIMPLE_UNASSIGNED, // 0xef
        SIMPLE_UNASSIGNED, // 0xf0
        SIMPLE_UNASSIGNED, // 0xf1
        SIMPLE_UNASSIGNED, // 0xf2
        SIMPLE_UNASSIGNED, // 0xf3
        // False
        SIMPLE_FALSE, // 0xf4
        // True
        SIMPLE_TRUE, // 0xf5
        // Null
        SIMPLE_NULL, // 0xf6
        // Undefined
        SIMPLE_UNDEFINED, // 0xf7
        // (simple value, one byte follows)
        SIMPLE_BYTE, // 0xf8
        // Half-Precision Float (two-byte IEEE 754)
        SIMPLE_FLOAT_HALF, // 0xf9
        // Single-Precision Float (four-byte IEEE 754)
        SIMPLE_FLOAT_SINGLE, // 0xfa
        // Double-Precision Float (eight-byte IEEE 754)
        SIMPLE_FLOAT_DOUBLE, // 0xfb
        ERROR, // 0xfc
        ERROR, // 0xfd
        ERROR, // 0xfe
        // "break" stop code
        BREAK // 0xff
      ]
    
      // --
    
      return {
        parse: parse
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/decoder.js":
    /*!******************************************!*\
      !*** ./node_modules/borc/src/decoder.js ***!
      \******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    const { Buffer } = __webpack_require__(/*! buffer */ "./node_modules/borc/node_modules/buffer/index.js")
    const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
    const Bignumber = (__webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js").BigNumber)
    
    const parser = __webpack_require__(/*! ./decoder.asm */ "./node_modules/borc/src/decoder.asm.js")
    const utils = __webpack_require__(/*! ./utils */ "./node_modules/borc/src/utils.js")
    const c = __webpack_require__(/*! ./constants */ "./node_modules/borc/src/constants.js")
    const Simple = __webpack_require__(/*! ./simple */ "./node_modules/borc/src/simple.js")
    const Tagged = __webpack_require__(/*! ./tagged */ "./node_modules/borc/src/tagged.js")
    const { URL } = __webpack_require__(/*! iso-url */ "./node_modules/iso-url/index.js")
    
    /**
     * Transform binary cbor data into JavaScript objects.
     */
    class Decoder {
      /**
       * @param {Object} [opts={}]
       * @param {number} [opts.size=65536] - Size of the allocated heap.
       */
      constructor (opts) {
        opts = opts || {}
    
        if (!opts.size || opts.size < 0x10000) {
          opts.size = 0x10000
        } else {
          // Ensure the size is a power of 2
          opts.size = utils.nextPowerOf2(opts.size)
        }
    
        // Heap use to share the input with the parser
        this._heap = new ArrayBuffer(opts.size)
        this._heap8 = new Uint8Array(this._heap)
        this._buffer = Buffer.from(this._heap)
    
        this._reset()
    
        // Known tags
        this._knownTags = Object.assign({
          0: (val) => new Date(val),
          1: (val) => new Date(val * 1000),
          2: (val) => utils.arrayBufferToBignumber(val),
          3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
          4: (v) => {
            // const v = new Uint8Array(val)
            return c.TEN.pow(v[0]).times(v[1])
          },
          5: (v) => {
            // const v = new Uint8Array(val)
            return c.TWO.pow(v[0]).times(v[1])
          },
          32: (val) => new URL(val),
          35: (val) => new RegExp(val)
        }, opts.tags)
    
        // Initialize asm based parser
        this.parser = parser(__webpack_require__.g, {
          // eslint-disable-next-line no-console
          log: console.log.bind(console),
          pushInt: this.pushInt.bind(this),
          pushInt32: this.pushInt32.bind(this),
          pushInt32Neg: this.pushInt32Neg.bind(this),
          pushInt64: this.pushInt64.bind(this),
          pushInt64Neg: this.pushInt64Neg.bind(this),
          pushFloat: this.pushFloat.bind(this),
          pushFloatSingle: this.pushFloatSingle.bind(this),
          pushFloatDouble: this.pushFloatDouble.bind(this),
          pushTrue: this.pushTrue.bind(this),
          pushFalse: this.pushFalse.bind(this),
          pushUndefined: this.pushUndefined.bind(this),
          pushNull: this.pushNull.bind(this),
          pushInfinity: this.pushInfinity.bind(this),
          pushInfinityNeg: this.pushInfinityNeg.bind(this),
          pushNaN: this.pushNaN.bind(this),
          pushNaNNeg: this.pushNaNNeg.bind(this),
          pushArrayStart: this.pushArrayStart.bind(this),
          pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
          pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
          pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
          pushObjectStart: this.pushObjectStart.bind(this),
          pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
          pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
          pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
          pushByteString: this.pushByteString.bind(this),
          pushByteStringStart: this.pushByteStringStart.bind(this),
          pushUtf8String: this.pushUtf8String.bind(this),
          pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
          pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
          pushTagUnassigned: this.pushTagUnassigned.bind(this),
          pushTagStart: this.pushTagStart.bind(this),
          pushTagStart4: this.pushTagStart4.bind(this),
          pushTagStart8: this.pushTagStart8.bind(this),
          pushBreak: this.pushBreak.bind(this)
        }, this._heap)
      }
    
      get _depth () {
        return this._parents.length
      }
    
      get _currentParent () {
        return this._parents[this._depth - 1]
      }
    
      get _ref () {
        return this._currentParent.ref
      }
    
      // Finish the current parent
      _closeParent () {
        var p = this._parents.pop()
    
        if (p.length > 0) {
          throw new Error(`Missing ${p.length} elements`)
        }
    
        switch (p.type) {
          case c.PARENT.TAG:
            this._push(
              this.createTag(p.ref[0], p.ref[1])
            )
            break
          case c.PARENT.BYTE_STRING:
            this._push(this.createByteString(p.ref, p.length))
            break
          case c.PARENT.UTF8_STRING:
            this._push(this.createUtf8String(p.ref, p.length))
            break
          case c.PARENT.MAP:
            if (p.values % 2 > 0) {
              throw new Error('Odd number of elements in the map')
            }
            this._push(this.createMap(p.ref, p.length))
            break
          case c.PARENT.OBJECT:
            if (p.values % 2 > 0) {
              throw new Error('Odd number of elements in the map')
            }
            this._push(this.createObject(p.ref, p.length))
            break
          case c.PARENT.ARRAY:
            this._push(this.createArray(p.ref, p.length))
            break
          default:
            break
        }
    
        if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
          this._dec()
        }
      }
    
      // Reduce the expected length of the current parent by one
      _dec () {
        const p = this._currentParent
        // The current parent does not know the epxected child length
    
        if (p.length < 0) {
          return
        }
    
        p.length--
    
        // All children were seen, we can close the current parent
        if (p.length === 0) {
          this._closeParent()
        }
      }
    
      // Push any value to the current parent
      _push (val, hasChildren) {
        const p = this._currentParent
        p.values++
    
        switch (p.type) {
          case c.PARENT.ARRAY:
          case c.PARENT.BYTE_STRING:
          case c.PARENT.UTF8_STRING:
            if (p.length > -1) {
              this._ref[this._ref.length - p.length] = val
            } else {
              this._ref.push(val)
            }
            this._dec()
            break
          case c.PARENT.OBJECT:
            if (p.tmpKey != null) {
              this._ref[p.tmpKey] = val
              p.tmpKey = null
              this._dec()
            } else {
              p.tmpKey = val
    
              if (typeof p.tmpKey !== 'string') {
                // too bad, convert to a Map
                p.type = c.PARENT.MAP
                p.ref = utils.buildMap(p.ref)
              }
            }
            break
          case c.PARENT.MAP:
            if (p.tmpKey != null) {
              this._ref.set(p.tmpKey, val)
              p.tmpKey = null
              this._dec()
            } else {
              p.tmpKey = val
            }
            break
          case c.PARENT.TAG:
            this._ref.push(val)
            if (!hasChildren) {
              this._dec()
            }
            break
          default:
            throw new Error('Unknown parent type')
        }
      }
    
      // Create a new parent in the parents list
      _createParent (obj, type, len) {
        this._parents[this._depth] = {
          type: type,
          length: len,
          ref: obj,
          values: 0,
          tmpKey: null
        }
      }
    
      // Reset all state back to the beginning, also used for initiatlization
      _reset () {
        this._res = []
        this._parents = [{
          type: c.PARENT.ARRAY,
          length: -1,
          ref: this._res,
          values: 0,
          tmpKey: null
        }]
      }
    
      // -- Interface to customize deoding behaviour
      createTag (tagNumber, value) {
        const typ = this._knownTags[tagNumber]
    
        if (!typ) {
          return new Tagged(tagNumber, value)
        }
    
        return typ(value)
      }
    
      createMap (obj, len) {
        return obj
      }
    
      createObject (obj, len) {
        return obj
      }
    
      createArray (arr, len) {
        return arr
      }
    
      createByteString (raw, len) {
        return Buffer.concat(raw)
      }
    
      createByteStringFromHeap (start, end) {
        if (start === end) {
          return Buffer.alloc(0)
        }
    
        return Buffer.from(this._heap.slice(start, end))
      }
    
      createInt (val) {
        return val
      }
    
      createInt32 (f, g) {
        return utils.buildInt32(f, g)
      }
    
      createInt64 (f1, f2, g1, g2) {
        return utils.buildInt64(f1, f2, g1, g2)
      }
    
      createFloat (val) {
        return val
      }
    
      createFloatSingle (a, b, c, d) {
        return ieee754.read([a, b, c, d], 0, false, 23, 4)
      }
    
      createFloatDouble (a, b, c, d, e, f, g, h) {
        return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)
      }
    
      createInt32Neg (f, g) {
        return -1 - utils.buildInt32(f, g)
      }
    
      createInt64Neg (f1, f2, g1, g2) {
        const f = utils.buildInt32(f1, f2)
        const g = utils.buildInt32(g1, g2)
    
        if (f > c.MAX_SAFE_HIGH) {
          return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))
        }
    
        return -1 - ((f * c.SHIFT32) + g)
      }
    
      createTrue () {
        return true
      }
    
      createFalse () {
        return false
      }
    
      createNull () {
        return null
      }
    
      createUndefined () {
        return undefined
      }
    
      createInfinity () {
        return Infinity
      }
    
      createInfinityNeg () {
        return -Infinity
      }
    
      createNaN () {
        return NaN
      }
    
      createNaNNeg () {
        return -NaN
      }
    
      createUtf8String (raw, len) {
        return raw.join('')
      }
    
      createUtf8StringFromHeap (start, end) {
        if (start === end) {
          return ''
        }
    
        return this._buffer.toString('utf8', start, end)
      }
    
      createSimpleUnassigned (val) {
        return new Simple(val)
      }
    
      // -- Interface for decoder.asm.js
    
      pushInt (val) {
        this._push(this.createInt(val))
      }
    
      pushInt32 (f, g) {
        this._push(this.createInt32(f, g))
      }
    
      pushInt64 (f1, f2, g1, g2) {
        this._push(this.createInt64(f1, f2, g1, g2))
      }
    
      pushFloat (val) {
        this._push(this.createFloat(val))
      }
    
      pushFloatSingle (a, b, c, d) {
        this._push(this.createFloatSingle(a, b, c, d))
      }
    
      pushFloatDouble (a, b, c, d, e, f, g, h) {
        this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))
      }
    
      pushInt32Neg (f, g) {
        this._push(this.createInt32Neg(f, g))
      }
    
      pushInt64Neg (f1, f2, g1, g2) {
        this._push(this.createInt64Neg(f1, f2, g1, g2))
      }
    
      pushTrue () {
        this._push(this.createTrue())
      }
    
      pushFalse () {
        this._push(this.createFalse())
      }
    
      pushNull () {
        this._push(this.createNull())
      }
    
      pushUndefined () {
        this._push(this.createUndefined())
      }
    
      pushInfinity () {
        this._push(this.createInfinity())
      }
    
      pushInfinityNeg () {
        this._push(this.createInfinityNeg())
      }
    
      pushNaN () {
        this._push(this.createNaN())
      }
    
      pushNaNNeg () {
        this._push(this.createNaNNeg())
      }
    
      pushArrayStart () {
        this._createParent([], c.PARENT.ARRAY, -1)
      }
    
      pushArrayStartFixed (len) {
        this._createArrayStartFixed(len)
      }
    
      pushArrayStartFixed32 (len1, len2) {
        const len = utils.buildInt32(len1, len2)
        this._createArrayStartFixed(len)
      }
    
      pushArrayStartFixed64 (len1, len2, len3, len4) {
        const len = utils.buildInt64(len1, len2, len3, len4)
        this._createArrayStartFixed(len)
      }
    
      pushObjectStart () {
        this._createObjectStartFixed(-1)
      }
    
      pushObjectStartFixed (len) {
        this._createObjectStartFixed(len)
      }
    
      pushObjectStartFixed32 (len1, len2) {
        const len = utils.buildInt32(len1, len2)
        this._createObjectStartFixed(len)
      }
    
      pushObjectStartFixed64 (len1, len2, len3, len4) {
        const len = utils.buildInt64(len1, len2, len3, len4)
        this._createObjectStartFixed(len)
      }
    
      pushByteStringStart () {
        this._parents[this._depth] = {
          type: c.PARENT.BYTE_STRING,
          length: -1,
          ref: [],
          values: 0,
          tmpKey: null
        }
      }
    
      pushByteString (start, end) {
        this._push(this.createByteStringFromHeap(start, end))
      }
    
      pushUtf8StringStart () {
        this._parents[this._depth] = {
          type: c.PARENT.UTF8_STRING,
          length: -1,
          ref: [],
          values: 0,
          tmpKey: null
        }
      }
    
      pushUtf8String (start, end) {
        this._push(this.createUtf8StringFromHeap(start, end))
      }
    
      pushSimpleUnassigned (val) {
        this._push(this.createSimpleUnassigned(val))
      }
    
      pushTagStart (tag) {
        this._parents[this._depth] = {
          type: c.PARENT.TAG,
          length: 1,
          ref: [tag]
        }
      }
    
      pushTagStart4 (f, g) {
        this.pushTagStart(utils.buildInt32(f, g))
      }
    
      pushTagStart8 (f1, f2, g1, g2) {
        this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))
      }
    
      pushTagUnassigned (tagNumber) {
        this._push(this.createTag(tagNumber))
      }
    
      pushBreak () {
        if (this._currentParent.length > -1) {
          throw new Error('Unexpected break')
        }
    
        this._closeParent()
      }
    
      _createObjectStartFixed (len) {
        if (len === 0) {
          this._push(this.createObject({}))
          return
        }
    
        this._createParent({}, c.PARENT.OBJECT, len)
      }
    
      _createArrayStartFixed (len) {
        if (len === 0) {
          this._push(this.createArray([]))
          return
        }
    
        this._createParent(new Array(len), c.PARENT.ARRAY, len)
      }
    
      _decode (input) {
        if (input.byteLength === 0) {
          throw new Error('Input too short')
        }
    
        this._reset()
        this._heap8.set(input)
        const code = this.parser.parse(input.byteLength)
    
        if (this._depth > 1) {
          while (this._currentParent.length === 0) {
            this._closeParent()
          }
          if (this._depth > 1) {
            throw new Error('Undeterminated nesting')
          }
        }
    
        if (code > 0) {
          throw new Error('Failed to parse')
        }
    
        if (this._res.length === 0) {
          throw new Error('No valid result')
        }
      }
    
      // -- Public Interface
    
      decodeFirst (input) {
        this._decode(input)
    
        return this._res[0]
      }
    
      decodeAll (input) {
        this._decode(input)
    
        return this._res
      }
    
      /**
       * Decode the first cbor object.
       *
       * @param {Buffer|string} input
       * @param {string} [enc='hex'] - Encoding used if a string is passed.
       * @returns {*}
       */
      static decode (input, enc) {
        if (typeof input === 'string') {
          input = Buffer.from(input, enc || 'hex')
        }
    
        const dec = new Decoder({ size: input.length })
        return dec.decodeFirst(input)
      }
    
      /**
       * Decode all cbor objects.
       *
       * @param {Buffer|string} input
       * @param {string} [enc='hex'] - Encoding used if a string is passed.
       * @returns {Array<*>}
       */
      static decodeAll (input, enc) {
        if (typeof input === 'string') {
          input = Buffer.from(input, enc || 'hex')
        }
    
        const dec = new Decoder({ size: input.length })
        return dec.decodeAll(input)
      }
    }
    
    Decoder.decodeFirst = Decoder.decode
    
    module.exports = Decoder
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/diagnose.js":
    /*!*******************************************!*\
      !*** ./node_modules/borc/src/diagnose.js ***!
      \*******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    const { Buffer } = __webpack_require__(/*! buffer */ "./node_modules/borc/node_modules/buffer/index.js")
    const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/borc/src/decoder.js")
    const utils = __webpack_require__(/*! ./utils */ "./node_modules/borc/src/utils.js")
    
    /**
     * Output the diagnostic format from a stream of CBOR bytes.
     *
     */
    class Diagnose extends Decoder {
      createTag (tagNumber, value) {
        return `${tagNumber}(${value})`
      }
    
      createInt (val) {
        return super.createInt(val).toString()
      }
    
      createInt32 (f, g) {
        return super.createInt32(f, g).toString()
      }
    
      createInt64 (f1, f2, g1, g2) {
        return super.createInt64(f1, f2, g1, g2).toString()
      }
    
      createInt32Neg (f, g) {
        return super.createInt32Neg(f, g).toString()
      }
    
      createInt64Neg (f1, f2, g1, g2) {
        return super.createInt64Neg(f1, f2, g1, g2).toString()
      }
    
      createTrue () {
        return 'true'
      }
    
      createFalse () {
        return 'false'
      }
    
      createFloat (val) {
        const fl = super.createFloat(val)
        if (utils.isNegativeZero(val)) {
          return '-0_1'
        }
    
        return `${fl}_1`
      }
    
      createFloatSingle (a, b, c, d) {
        const fl = super.createFloatSingle(a, b, c, d)
        return `${fl}_2`
      }
    
      createFloatDouble (a, b, c, d, e, f, g, h) {
        const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)
        return `${fl}_3`
      }
    
      createByteString (raw, len) {
        const val = raw.join(', ')
    
        if (len === -1) {
          return `(_ ${val})`
        }
        return `h'${val}`
      }
    
      createByteStringFromHeap (start, end) {
        const val = (Buffer.from(
          super.createByteStringFromHeap(start, end)
        )).toString('hex')
    
        return `h'${val}'`
      }
    
      createInfinity () {
        return 'Infinity_1'
      }
    
      createInfinityNeg () {
        return '-Infinity_1'
      }
    
      createNaN () {
        return 'NaN_1'
      }
    
      createNaNNeg () {
        return '-NaN_1'
      }
    
      createNull () {
        return 'null'
      }
    
      createUndefined () {
        return 'undefined'
      }
    
      createSimpleUnassigned (val) {
        return `simple(${val})`
      }
    
      createArray (arr, len) {
        const val = super.createArray(arr, len)
    
        if (len === -1) {
          // indefinite
          return `[_ ${val.join(', ')}]`
        }
    
        return `[${val.join(', ')}]`
      }
    
      createMap (map, len) {
        const val = super.createMap(map)
        const list = Array.from(val.keys())
          .reduce(collectObject(val), '')
    
        if (len === -1) {
          return `{_ ${list}}`
        }
    
        return `{${list}}`
      }
    
      createObject (obj, len) {
        const val = super.createObject(obj)
        const map = Object.keys(val)
          .reduce(collectObject(val), '')
    
        if (len === -1) {
          return `{_ ${map}}`
        }
    
        return `{${map}}`
      }
    
      createUtf8String (raw, len) {
        const val = raw.join(', ')
    
        if (len === -1) {
          return `(_ ${val})`
        }
    
        return `"${val}"`
      }
    
      createUtf8StringFromHeap (start, end) {
        const val = (Buffer.from(
          super.createUtf8StringFromHeap(start, end)
        )).toString('utf8')
    
        return `"${val}"`
      }
    
      static diagnose (input, enc) {
        if (typeof input === 'string') {
          input = Buffer.from(input, enc || 'hex')
        }
    
        const dec = new Diagnose()
        return dec.decodeFirst(input)
      }
    }
    
    module.exports = Diagnose
    
    function collectObject (val) {
      return (acc, key) => {
        if (acc) {
          return `${acc}, ${key}: ${val[key]}`
        }
        return `${key}: ${val[key]}`
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/encoder.js":
    /*!******************************************!*\
      !*** ./node_modules/borc/src/encoder.js ***!
      \******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    const { Buffer } = __webpack_require__(/*! buffer */ "./node_modules/borc/node_modules/buffer/index.js")
    const { URL } = __webpack_require__(/*! iso-url */ "./node_modules/iso-url/index.js")
    const Bignumber = (__webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js").BigNumber)
    
    const utils = __webpack_require__(/*! ./utils */ "./node_modules/borc/src/utils.js")
    const constants = __webpack_require__(/*! ./constants */ "./node_modules/borc/src/constants.js")
    const MT = constants.MT
    const NUMBYTES = constants.NUMBYTES
    const SHIFT32 = constants.SHIFT32
    const SYMS = constants.SYMS
    const TAG = constants.TAG
    const HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO
    const FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR
    const DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT
    const TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE
    const FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE
    const UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED
    const NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL
    
    const MAXINT_BN = new Bignumber('0x20000000000000')
    const BUF_NAN = Buffer.from('f97e00', 'hex')
    const BUF_INF_NEG = Buffer.from('f9fc00', 'hex')
    const BUF_INF_POS = Buffer.from('f97c00', 'hex')
    
    function toType (obj) {
      // [object Type]
      // --------8---1
      return ({}).toString.call(obj).slice(8, -1)
    }
    
    /**
     * Transform JavaScript values into CBOR bytes
     *
     */
    class Encoder {
      /**
       * @param {Object} [options={}]
       * @param {function(Buffer)} options.stream
       */
      constructor (options) {
        options = options || {}
    
        this.streaming = typeof options.stream === 'function'
        this.onData = options.stream
    
        this.semanticTypes = [
          [URL, this._pushUrl],
          [Bignumber, this._pushBigNumber]
        ]
    
        const addTypes = options.genTypes || []
        const len = addTypes.length
        for (let i = 0; i < len; i++) {
          this.addSemanticType(
            addTypes[i][0],
            addTypes[i][1]
          )
        }
    
        this._reset()
      }
    
      addSemanticType (type, fun) {
        const len = this.semanticTypes.length
        for (let i = 0; i < len; i++) {
          const typ = this.semanticTypes[i][0]
          if (typ === type) {
            const old = this.semanticTypes[i][1]
            this.semanticTypes[i][1] = fun
            return old
          }
        }
        this.semanticTypes.push([type, fun])
        return null
      }
    
      push (val) {
        if (!val) {
          return true
        }
    
        this.result[this.offset] = val
        this.resultMethod[this.offset] = 0
        this.resultLength[this.offset] = val.length
        this.offset++
    
        if (this.streaming) {
          this.onData(this.finalize())
        }
    
        return true
      }
    
      pushWrite (val, method, len) {
        this.result[this.offset] = val
        this.resultMethod[this.offset] = method
        this.resultLength[this.offset] = len
        this.offset++
    
        if (this.streaming) {
          this.onData(this.finalize())
        }
    
        return true
      }
    
      _pushUInt8 (val) {
        return this.pushWrite(val, 1, 1)
      }
    
      _pushUInt16BE (val) {
        return this.pushWrite(val, 2, 2)
      }
    
      _pushUInt32BE (val) {
        return this.pushWrite(val, 3, 4)
      }
    
      _pushDoubleBE (val) {
        return this.pushWrite(val, 4, 8)
      }
    
      _pushNaN () {
        return this.push(BUF_NAN)
      }
    
      _pushInfinity (obj) {
        const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS
        return this.push(half)
      }
    
      _pushFloat (obj) {
        const b2 = Buffer.allocUnsafe(2)
    
        if (utils.writeHalf(b2, obj)) {
          if (utils.parseHalf(b2) === obj) {
            return this._pushUInt8(HALF) && this.push(b2)
          }
        }
    
        const b4 = Buffer.allocUnsafe(4)
        b4.writeFloatBE(obj, 0)
        if (b4.readFloatBE(0) === obj) {
          return this._pushUInt8(FLOAT) && this.push(b4)
        }
    
        return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)
      }
    
      _pushInt (obj, mt, orig) {
        const m = mt << 5
        if (obj < 24) {
          return this._pushUInt8(m | obj)
        }
    
        if (obj <= 0xff) {
          return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)
        }
    
        if (obj <= 0xffff) {
          return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)
        }
    
        if (obj <= 0xffffffff) {
          return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)
        }
    
        if (obj <= Number.MAX_SAFE_INTEGER) {
          return this._pushUInt8(m | NUMBYTES.EIGHT) &&
            this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&
            this._pushUInt32BE(obj % SHIFT32)
        }
    
        if (mt === MT.NEG_INT) {
          return this._pushFloat(orig)
        }
    
        return this._pushFloat(obj)
      }
    
      _pushIntNum (obj) {
        if (obj < 0) {
          return this._pushInt(-obj - 1, MT.NEG_INT, obj)
        } else {
          return this._pushInt(obj, MT.POS_INT)
        }
      }
    
      _pushNumber (obj) {
        switch (false) {
          case (obj === obj): // eslint-disable-line
            return this._pushNaN(obj)
          case isFinite(obj):
            return this._pushInfinity(obj)
          case ((obj % 1) !== 0):
            return this._pushIntNum(obj)
          default:
            return this._pushFloat(obj)
        }
      }
    
      _pushString (obj) {
        const len = Buffer.byteLength(obj, 'utf8')
        return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len)
      }
    
      _pushBoolean (obj) {
        return this._pushUInt8(obj ? TRUE : FALSE)
      }
    
      _pushUndefined (obj) {
        return this._pushUInt8(UNDEFINED)
      }
    
      _pushArray (gen, obj) {
        const len = obj.length
        if (!gen._pushInt(len, MT.ARRAY)) {
          return false
        }
        for (let j = 0; j < len; j++) {
          if (!gen.pushAny(obj[j])) {
            return false
          }
        }
        return true
      }
    
      _pushTag (tag) {
        return this._pushInt(tag, MT.TAG)
      }
    
      _pushDate (gen, obj) {
        // Round date, to get seconds since 1970-01-01 00:00:00 as defined in
        // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is
        // still allowed to encode fractions of seconds which can be achieved by
        // changing overwriting the encode function for Date objects.
        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000))
      }
    
      _pushBuffer (gen, obj) {
        return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)
      }
    
      _pushNoFilter (gen, obj) {
        return gen._pushBuffer(gen, obj.slice())
      }
    
      _pushRegexp (gen, obj) {
        return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)
      }
    
      _pushSet (gen, obj) {
        if (!gen._pushInt(obj.size, MT.ARRAY)) {
          return false
        }
        for (const x of obj) {
          if (!gen.pushAny(x)) {
            return false
          }
        }
        return true
      }
    
      _pushUrl (gen, obj) {
        return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())
      }
    
      _pushBigint (obj) {
        let tag = TAG.POS_BIGINT
        if (obj.isNegative()) {
          obj = obj.negated().minus(1)
          tag = TAG.NEG_BIGINT
        }
        let str = obj.toString(16)
        if (str.length % 2) {
          str = '0' + str
        }
        const buf = Buffer.from(str, 'hex')
        return this._pushTag(tag) && this._pushBuffer(this, buf)
      }
    
      _pushBigNumber (gen, obj) {
        if (obj.isNaN()) {
          return gen._pushNaN()
        }
        if (!obj.isFinite()) {
          return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)
        }
        if (obj.isInteger()) {
          return gen._pushBigint(obj)
        }
        if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&
          gen._pushInt(2, MT.ARRAY))) {
          return false
        }
    
        const dec = obj.decimalPlaces()
        const slide = obj.multipliedBy(new Bignumber(10).pow(dec))
        if (!gen._pushIntNum(-dec)) {
          return false
        }
        if (slide.abs().isLessThan(MAXINT_BN)) {
          return gen._pushIntNum(slide.toNumber())
        } else {
          return gen._pushBigint(slide)
        }
      }
    
      _pushMap (gen, obj) {
        if (!gen._pushInt(obj.size, MT.MAP)) {
          return false
        }
    
        return this._pushRawMap(
          obj.size,
          Array.from(obj)
        )
      }
    
      _pushObject (obj) {
        if (!obj) {
          return this._pushUInt8(NULL)
        }
    
        var len = this.semanticTypes.length
        for (var i = 0; i < len; i++) {
          if (obj instanceof this.semanticTypes[i][0]) {
            return this.semanticTypes[i][1].call(obj, this, obj)
          }
        }
    
        var f = obj.encodeCBOR
        if (typeof f === 'function') {
          return f.call(obj, this)
        }
    
        var keys = Object.keys(obj)
        var keyLength = keys.length
        if (!this._pushInt(keyLength, MT.MAP)) {
          return false
        }
    
        return this._pushRawMap(
          keyLength,
          keys.map((k) => [k, obj[k]])
        )
      }
    
      _pushRawMap (len, map) {
        // Sort keys for canoncialization
        // 1. encode key
        // 2. shorter key comes before longer key
        // 3. same length keys are sorted with lower
        //    byte value before higher
    
        map = map.map(function (a) {
          a[0] = Encoder.encode(a[0])
          return a
        }).sort(utils.keySorter)
    
        for (var j = 0; j < len; j++) {
          if (!this.push(map[j][0])) {
            return false
          }
    
          if (!this.pushAny(map[j][1])) {
            return false
          }
        }
    
        return true
      }
    
      /**
       * Alias for `.pushAny`
       *
       * @param {*} obj
       * @returns {boolean} true on success
       */
      write (obj) {
        return this.pushAny(obj)
      }
    
      /**
       * Push any supported type onto the encoded stream
       *
       * @param {any} obj
       * @returns {boolean} true on success
       */
      pushAny (obj) {
        var typ = toType(obj)
    
        switch (typ) {
          case 'Number':
            return this._pushNumber(obj)
          case 'String':
            return this._pushString(obj)
          case 'Boolean':
            return this._pushBoolean(obj)
          case 'Object':
            return this._pushObject(obj)
          case 'Array':
            return this._pushArray(this, obj)
          case 'Uint8Array':
            return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj))
          case 'Null':
            return this._pushUInt8(NULL)
          case 'Undefined':
            return this._pushUndefined(obj)
          case 'Map':
            return this._pushMap(this, obj)
          case 'Set':
            return this._pushSet(this, obj)
          case 'URL':
            return this._pushUrl(this, obj)
          case 'BigNumber':
            return this._pushBigNumber(this, obj)
          case 'Date':
            return this._pushDate(this, obj)
          case 'RegExp':
            return this._pushRegexp(this, obj)
          case 'Symbol':
            switch (obj) {
              case SYMS.NULL:
                return this._pushObject(null)
              case SYMS.UNDEFINED:
                return this._pushUndefined(undefined)
              // TODO: Add pluggable support for other symbols
              default:
                throw new Error('Unknown symbol: ' + obj.toString())
            }
          default:
            throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''))
        }
      }
    
      finalize () {
        if (this.offset === 0) {
          return null
        }
    
        var result = this.result
        var resultLength = this.resultLength
        var resultMethod = this.resultMethod
        var offset = this.offset
    
        // Determine the size of the buffer
        var size = 0
        var i = 0
    
        for (; i < offset; i++) {
          size += resultLength[i]
        }
    
        var res = Buffer.allocUnsafe(size)
        var index = 0
        var length = 0
    
        // Write the content into the result buffer
        for (i = 0; i < offset; i++) {
          length = resultLength[i]
    
          switch (resultMethod[i]) {
            case 0:
              result[i].copy(res, index)
              break
            case 1:
              res.writeUInt8(result[i], index, true)
              break
            case 2:
              res.writeUInt16BE(result[i], index, true)
              break
            case 3:
              res.writeUInt32BE(result[i], index, true)
              break
            case 4:
              res.writeDoubleBE(result[i], index, true)
              break
            case 5:
              res.write(result[i], index, length, 'utf8')
              break
            default:
              throw new Error('unkown method')
          }
    
          index += length
        }
    
        var tmp = res
    
        this._reset()
    
        return tmp
      }
    
      _reset () {
        this.result = []
        this.resultMethod = []
        this.resultLength = []
        this.offset = 0
      }
    
      /**
       * Encode the given value
       * @param {*} o
       * @returns {Buffer}
       */
      static encode (o) {
        const enc = new Encoder()
        const ret = enc.pushAny(o)
        if (!ret) {
          throw new Error('Failed to encode input')
        }
    
        return enc.finalize()
      }
    }
    
    module.exports = Encoder
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/index.js":
    /*!****************************************!*\
      !*** ./node_modules/borc/src/index.js ***!
      \****************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    
    
    // exports.Commented = require('./commented')
    exports.Diagnose = __webpack_require__(/*! ./diagnose */ "./node_modules/borc/src/diagnose.js")
    exports.Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/borc/src/decoder.js")
    exports.Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/borc/src/encoder.js")
    exports.Simple = __webpack_require__(/*! ./simple */ "./node_modules/borc/src/simple.js")
    exports.Tagged = __webpack_require__(/*! ./tagged */ "./node_modules/borc/src/tagged.js")
    
    // exports.comment = exports.Commented.comment
    exports.decodeAll = exports.Decoder.decodeAll
    exports.decodeFirst = exports.Decoder.decodeFirst
    exports.diagnose = exports.Diagnose.diagnose
    exports.encode = exports.Encoder.encode
    exports.decode = exports.Decoder.decode
    
    exports.leveldb = {
      decode: exports.Decoder.decodeAll,
      encode: exports.Encoder.encode,
      buffer: true,
      name: 'cbor'
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/simple.js":
    /*!*****************************************!*\
      !*** ./node_modules/borc/src/simple.js ***!
      \*****************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    const constants = __webpack_require__(/*! ./constants */ "./node_modules/borc/src/constants.js")
    const MT = constants.MT
    const SIMPLE = constants.SIMPLE
    const SYMS = constants.SYMS
    
    /**
     * A CBOR Simple Value that does not map onto a known constant.
     */
    class Simple {
      /**
       * Creates an instance of Simple.
       *
       * @param {integer} value - the simple value's integer value
       */
      constructor (value) {
        if (typeof value !== 'number') {
          throw new Error('Invalid Simple type: ' + (typeof value))
        }
        if ((value < 0) || (value > 255) || ((value | 0) !== value)) {
          throw new Error('value must be a small positive integer: ' + value)
        }
        this.value = value
      }
    
      /**
       * Debug string for simple value
       *
       * @returns {string} simple(value)
       */
      toString () {
        return 'simple(' + this.value + ')'
      }
    
      /**
       * Debug string for simple value
       *
       * @returns {string} simple(value)
       */
      inspect () {
        return 'simple(' + this.value + ')'
      }
    
      /**
       * Push the simple value onto the CBOR stream
       *
       * @param {cbor.Encoder} gen The generator to push onto
       * @returns {number}
       */
      encodeCBOR (gen) {
        return gen._pushInt(this.value, MT.SIMPLE_FLOAT)
      }
    
      /**
       * Is the given object a Simple?
       *
       * @param {any} obj - object to test
       * @returns {bool} - is it Simple?
       */
      static isSimple (obj) {
        return obj instanceof Simple
      }
    
      /**
       * Decode from the CBOR additional information into a JavaScript value.
       * If the CBOR item has no parent, return a "safe" symbol instead of
       * `null` or `undefined`, so that the value can be passed through a
       * stream in object mode.
       *
       * @param {Number} val - the CBOR additional info to convert
       * @param {bool} hasParent - Does the CBOR item have a parent?
       * @returns {(null|undefined|Boolean|Symbol)} - the decoded value
       */
      static decode (val, hasParent) {
        if (hasParent == null) {
          hasParent = true
        }
        switch (val) {
          case SIMPLE.FALSE:
            return false
          case SIMPLE.TRUE:
            return true
          case SIMPLE.NULL:
            if (hasParent) {
              return null
            } else {
              return SYMS.NULL
            }
          case SIMPLE.UNDEFINED:
            if (hasParent) {
              return undefined
            } else {
              return SYMS.UNDEFINED
            }
          case -1:
            if (!hasParent) {
              throw new Error('Invalid BREAK')
            }
            return SYMS.BREAK
          default:
            return new Simple(val)
        }
      }
    }
    
    module.exports = Simple
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/tagged.js":
    /*!*****************************************!*\
      !*** ./node_modules/borc/src/tagged.js ***!
      \*****************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * A CBOR tagged item, where the tag does not have semantics specified at the
     * moment, or those semantics threw an error during parsing. Typically this will
     * be an extension point you're not yet expecting.
     */
    class Tagged {
      /**
       * Creates an instance of Tagged.
       *
       * @param {Number} tag - the number of the tag
       * @param {any} value - the value inside the tag
       * @param {Error} err - the error that was thrown parsing the tag, or null
       */
      constructor (tag, value, err) {
        this.tag = tag
        this.value = value
        this.err = err
        if (typeof this.tag !== 'number') {
          throw new Error('Invalid tag type (' + (typeof this.tag) + ')')
        }
        if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {
          throw new Error('Tag must be a positive integer: ' + this.tag)
        }
      }
    
      /**
       * Convert to a String
       *
       * @returns {String} string of the form '1(2)'
       */
      toString () {
        return `${this.tag}(${JSON.stringify(this.value)})`
      }
    
      /**
       * Push the simple value onto the CBOR stream
       *
       * @param {cbor.Encoder} gen The generator to push onto
       * @returns {number}
       */
      encodeCBOR (gen) {
        gen._pushTag(this.tag)
        return gen.pushAny(this.value)
      }
    
      /**
       * If we have a converter for this type, do the conversion.  Some converters
       * are built-in.  Additional ones can be passed in.  If you want to remove
       * a built-in converter, pass a converter in whose value is 'null' instead
       * of a function.
       *
       * @param {Object} converters - keys in the object are a tag number, the value
       *   is a function that takes the decoded CBOR and returns a JavaScript value
       *   of the appropriate type.  Throw an exception in the function on errors.
       * @returns {any} - the converted item
       */
      convert (converters) {
        var er, f
        f = converters != null ? converters[this.tag] : undefined
        if (typeof f !== 'function') {
          f = Tagged['_tag' + this.tag]
          if (typeof f !== 'function') {
            return this
          }
        }
        try {
          return f.call(Tagged, this.value)
        } catch (error) {
          er = error
          this.err = er
          return this
        }
      }
    }
    
    module.exports = Tagged
    
    
    /***/ }),
    
    /***/ "./node_modules/borc/src/utils.js":
    /*!****************************************!*\
      !*** ./node_modules/borc/src/utils.js ***!
      \****************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    
    
    const { Buffer } = __webpack_require__(/*! buffer */ "./node_modules/borc/node_modules/buffer/index.js")
    const Bignumber = (__webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js").BigNumber)
    
    const constants = __webpack_require__(/*! ./constants */ "./node_modules/borc/src/constants.js")
    const SHIFT32 = constants.SHIFT32
    const SHIFT16 = constants.SHIFT16
    const MAX_SAFE_HIGH = 0x1fffff
    
    exports.parseHalf = function parseHalf (buf) {
      var exp, mant, sign
      sign = buf[0] & 0x80 ? -1 : 1
      exp = (buf[0] & 0x7C) >> 2
      mant = ((buf[0] & 0x03) << 8) | buf[1]
      if (!exp) {
        return sign * 5.9604644775390625e-8 * mant
      } else if (exp === 0x1f) {
        return sign * (mant ? 0 / 0 : 2e308)
      } else {
        return sign * Math.pow(2, exp - 25) * (1024 + mant)
      }
    }
    
    function toHex (n) {
      if (n < 16) {
        return '0' + n.toString(16)
      }
    
      return n.toString(16)
    }
    
    exports.arrayBufferToBignumber = function (buf) {
      const len = buf.byteLength
      let res = ''
      for (let i = 0; i < len; i++) {
        res += toHex(buf[i])
      }
    
      return new Bignumber(res, 16)
    }
    
    // convert an Object into a Map
    exports.buildMap = (obj) => {
      const res = new Map()
      const keys = Object.keys(obj)
      const length = keys.length
      for (let i = 0; i < length; i++) {
        res.set(keys[i], obj[keys[i]])
      }
      return res
    }
    
    exports.buildInt32 = (f, g) => {
      return f * SHIFT16 + g
    }
    
    exports.buildInt64 = (f1, f2, g1, g2) => {
      const f = exports.buildInt32(f1, f2)
      const g = exports.buildInt32(g1, g2)
    
      if (f > MAX_SAFE_HIGH) {
        return new Bignumber(f).times(SHIFT32).plus(g)
      } else {
        return (f * SHIFT32) + g
      }
    }
    
    exports.writeHalf = function writeHalf (buf, half) {
      // assume 0, -0, NaN, Infinity, and -Infinity have already been caught
    
      // HACK: everyone settle in.  This isn't going to be pretty.
      // Translate cn-cbor's C code (from Carsten Borman):
    
      // uint32_t be32;
      // uint16_t be16, u16;
      // union {
      //   float f;
      //   uint32_t u;
      // } u32;
      // u32.f = float_val;
    
      const u32 = Buffer.allocUnsafe(4)
      u32.writeFloatBE(half, 0)
      const u = u32.readUInt32BE(0)
    
      // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */
    
      // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion
      if ((u & 0x1FFF) !== 0) {
        return false
      }
    
      //   int s16 = (u32.u >> 16) & 0x8000;
      //   int exp = (u32.u >> 23) & 0xff;
      //   int mant = u32.u & 0x7fffff;
    
      var s16 = (u >> 16) & 0x8000 // top bit is sign
      const exp = (u >> 23) & 0xff // then 5 bits of exponent
      const mant = u & 0x7fffff
    
      //   if (exp == 0 && mant == 0)
      //     ;              /* 0.0, -0.0 */
    
      // hildjj: zeros already handled.  Assert if you don't believe me.
    
      //   else if (exp >= 113 && exp <= 142) /* normalized */
      //     s16 += ((exp - 112) << 10) + (mant >> 13);
      if ((exp >= 113) && (exp <= 142)) {
        s16 += ((exp - 112) << 10) + (mant >> 13)
    
      //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */
      //     if (mant & ((1 << (126 - exp)) - 1))
      //       goto float32;         /* loss of precision */
      //     s16 += ((mant + 0x800000) >> (126 - exp));
      } else if ((exp >= 103) && (exp < 113)) {
        if (mant & ((1 << (126 - exp)) - 1)) {
          return false
        }
        s16 += ((mant + 0x800000) >> (126 - exp))
    
        //   } else if (exp == 255 && mant == 0) { /* Inf */
        //     s16 += 0x7c00;
    
        // hildjj: Infinity already handled
    
      //   } else
      //     goto float32;           /* loss of range */
      } else {
        return false
      }
    
      //   ensure_writable(3);
      //   u16 = s16;
      //   be16 = hton16p((const uint8_t*)&u16);
      buf.writeUInt16BE(s16, 0)
      return true
    }
    
    exports.keySorter = function (a, b) {
      var lenA = a[0].byteLength
      var lenB = b[0].byteLength
    
      if (lenA > lenB) {
        return 1
      }
    
      if (lenB > lenA) {
        return -1
      }
    
      return a[0].compare(b[0])
    }
    
    // Adapted from http://www.2ality.com/2012/03/signedzero.html
    exports.isNegativeZero = (x) => {
      return x === 0 && (1 / x < 0)
    }
    
    exports.nextPowerOf2 = (n) => {
      let count = 0
      // First n in the below condition is for
      // the case where n is 0
      if (n && !(n & (n - 1))) {
        return n
      }
    
      while (n !== 0) {
        n >>= 1
        count += 1
      }
    
      return 1 << count
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/buffer-crc32/index.js":
    /*!********************************************!*\
      !*** ./node_modules/buffer-crc32/index.js ***!
      \********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);
    
    var CRC_TABLE = [
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    ];
    
    if (typeof Int32Array !== 'undefined') {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    
    function ensureBuffer(input) {
      if (Buffer.isBuffer(input)) {
        return input;
      }
    
      var hasNewBufferAPI =
          typeof Buffer.alloc === "function" &&
          typeof Buffer.from === "function";
    
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
      }
      else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
      }
      else {
        throw new Error("input must be buffer, number, or string, received " +
                        typeof input);
      }
    }
    
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
      }
      return (crc ^ -1);
    }
    
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function () {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function () {
      return _crc32.apply(null, arguments) >>> 0;
    };
    
    module.exports = crc32;
    
    
    /***/ }),
    
    /***/ "./node_modules/buffer-pipe/index.js":
    /*!*******************************************!*\
      !*** ./node_modules/buffer-pipe/index.js ***!
      \*******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)
    
    module.exports = class BufferPipe {
      /**
       * Creates a new instance of a pipe
       * @param {Buffer} buf - an optional buffer to start with
       */
      constructor (buf = Buffer.from([])) {
        this.buffer = buf
        this._bytesRead = 0
        this._bytesWrote = 0
      }
    
      /**
       * read `num` number of bytes from the pipe
       * @param {Number} num
       * @return {Buffer}
       */
      read (num) {
        this._bytesRead += num
        const data = this.buffer.slice(0, num)
        this.buffer = this.buffer.slice(num)
        return data
      }
    
      /**
       * Wites a buffer to the pipe
       * @param {Buffer} buf
       */
      write (buf) {
        buf = Buffer.from(buf)
        this._bytesWrote += buf.length
        this.buffer = Buffer.concat([this.buffer, buf])
      }
    
      /**
       * Whether or not there is more data to read from the buffer
       * returns {Boolean}
       */
      get end () {
        return !this.buffer.length
      }
    
      /**
       * returns the number of bytes read from the stream
       * @return {Integer}
       */
      get bytesRead () {
        return this._bytesRead
      }
    
      /**
       * returns the number of bytes wrote to the stream
       * @return {Integer}
       */
      get bytesWrote () {
        return this._bytesWrote
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/buffer/index.js":
    /*!**************************************!*\
      !*** ./node_modules/buffer/index.js ***!
      \**************************************/
    /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    
    "use strict";
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */
    
    
    
    const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
    const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
    const customInspectSymbol =
      (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
        ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
        : null
    
    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    
    const K_MAX_LENGTH = 0x7fffffff
    exports.kMaxLength = K_MAX_LENGTH
    
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
    
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
        typeof console.error === 'function') {
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      )
    }
    
    function typedArraySupport () {
      // Can typed array instances can be augmented?
      try {
        const arr = new Uint8Array(1)
        const proto = { foo: function () { return 42 } }
        Object.setPrototypeOf(proto, Uint8Array.prototype)
        Object.setPrototypeOf(arr, proto)
        return arr.foo() === 42
      } catch (e) {
        return false
      }
    }
    
    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.buffer
      }
    })
    
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.byteOffset
      }
    })
    
    function createBuffer (length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"')
      }
      // Return an augmented `Uint8Array` instance
      const buf = new Uint8Array(length)
      Object.setPrototypeOf(buf, Buffer.prototype)
      return buf
    }
    
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */
    
    function Buffer (arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          )
        }
        return allocUnsafe(arg)
      }
      return from(arg, encodingOrOffset, length)
    }
    
    Buffer.poolSize = 8192 // not used by this implementation
    
    function from (value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset)
      }
    
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value)
      }
    
      if (value == null) {
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }
    
      if (isInstance(value, ArrayBuffer) ||
          (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }
    
      if (typeof SharedArrayBuffer !== 'undefined' &&
          (isInstance(value, SharedArrayBuffer) ||
          (value && isInstance(value.buffer, SharedArrayBuffer)))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }
    
      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        )
      }
    
      const valueOf = value.valueOf && value.valueOf()
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length)
      }
    
      const b = fromObject(value)
      if (b) return b
    
      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
          typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
      }
    
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }
    
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length)
    }
    
    // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
    Object.setPrototypeOf(Buffer, Uint8Array)
    
    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number')
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"')
      }
    }
    
    function alloc (size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill)
      }
      return createBuffer(size)
    }
    
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding)
    }
    
    function allocUnsafe (size) {
      assertSize(size)
      return createBuffer(size < 0 ? 0 : checked(size) | 0)
    }
    
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size)
    }
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size)
    }
    
    function fromString (string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }
    
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    
      const length = byteLength(string, encoding) | 0
      let buf = createBuffer(length)
    
      const actual = buf.write(string, encoding)
    
      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual)
      }
    
      return buf
    }
    
    function fromArrayLike (array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0
      const buf = createBuffer(length)
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255
      }
      return buf
    }
    
    function fromArrayView (arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView)
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
      }
      return fromArrayLike(arrayView)
    }
    
    function fromArrayBuffer (array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds')
      }
    
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds')
      }
    
      let buf
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array)
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset)
      } else {
        buf = new Uint8Array(array, byteOffset, length)
      }
    
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(buf, Buffer.prototype)
    
      return buf
    }
    
    function fromObject (obj) {
      if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0
        const buf = createBuffer(len)
    
        if (buf.length === 0) {
          return buf
        }
    
        obj.copy(buf, 0, 0, len)
        return buf
      }
    
      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }
    
      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }
    
    function checked (length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
      }
      return length | 0
    }
    
    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }
    
    Buffer.isBuffer = function isBuffer (b) {
      return b != null && b._isBuffer === true &&
        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    }
    
    Buffer.compare = function compare (a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      }
    
      if (a === b) return 0
    
      let x = a.length
      let y = b.length
    
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }
    
    Buffer.concat = function concat (list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
    
      if (list.length === 0) {
        return Buffer.alloc(0)
      }
    
      let i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }
    
      const buffer = Buffer.allocUnsafe(length)
      let pos = 0
      for (i = 0; i < list.length; ++i) {
        let buf = list[i]
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
            buf.copy(buffer, pos)
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            )
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        } else {
          buf.copy(buffer, pos)
        }
        pos += buf.length
      }
      return buffer
    }
    
    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
          'Received type ' + typeof string
        )
      }
    
      const len = string.length
      const mustMatch = (arguments.length > 2 && arguments[2] === true)
      if (!mustMatch && len === 0) return 0
    
      // Use a for loop to avoid recursion
      let loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            }
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength
    
    function slowToString (encoding, start, end) {
      let loweredCase = false
    
      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
    
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }
    
      if (end === undefined || end > this.length) {
        end = this.length
      }
    
      if (end <= 0) {
        return ''
      }
    
      // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0
    
      if (end <= start) {
        return ''
      }
    
      if (!encoding) encoding = 'utf8'
    
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)
    
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)
    
          case 'ascii':
            return asciiSlice(this, start, end)
    
          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)
    
          case 'base64':
            return base64Slice(this, start, end)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }
    
    // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154
    Buffer.prototype._isBuffer = true
    
    function swap (b, n, m) {
      const i = b[n]
      b[n] = b[m]
      b[m] = i
    }
    
    Buffer.prototype.swap16 = function swap16 () {
      const len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }
    
    Buffer.prototype.swap32 = function swap32 () {
      const len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }
    
    Buffer.prototype.swap64 = function swap64 () {
      const len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }
    
    Buffer.prototype.toString = function toString () {
      const length = this.length
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    
    Buffer.prototype.toLocaleString = Buffer.prototype.toString
    
    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }
    
    Buffer.prototype.inspect = function inspect () {
      let str = ''
      const max = exports.INSPECT_MAX_BYTES
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
      if (this.length > max) str += ' ... '
      return '<Buffer ' + str + '>'
    }
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
    }
    
    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength)
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. ' +
          'Received type ' + (typeof target)
        )
      }
    
      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }
    
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }
    
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
    
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
    
      if (this === target) return 0
    
      let x = thisEnd - thisStart
      let y = end - start
      const len = Math.min(x, y)
    
      const thisCopy = this.slice(thisStart, thisEnd)
      const targetCopy = target.slice(start, end)
    
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1
    
      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset // Coerce to Number.
      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }
    
      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }
    
      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }
    
      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }
    
      throw new TypeError('val must be string, number or Buffer')
    }
    
    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      let indexSize = 1
      let arrLength = arr.length
      let valLength = val.length
    
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }
    
      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }
    
      let i
      if (dir) {
        let foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          let found = true
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }
    
      return -1
    }
    
    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    
    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }
    
    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }
    
    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      const remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }
    
      const strLen = string.length
    
      if (length > strLen / 2) {
        length = strLen / 2
      }
      let i
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16)
        if (numberIsNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }
    
    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }
    
    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }
    
    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0
        if (isFinite(length)) {
          length = length >>> 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }
    
      const remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining
    
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }
    
      if (!encoding) encoding = 'utf8'
    
      let loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)
    
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)
    
          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length)
    
          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    
    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    
    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }
    
    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      const res = []
    
      let i = start
      while (i < end) {
        const firstByte = buf[i]
        let codePoint = null
        let bytesPerSequence = (firstByte > 0xEF)
          ? 4
          : (firstByte > 0xDF)
              ? 3
              : (firstByte > 0xBF)
                  ? 2
                  : 1
    
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint
    
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }
    
        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
    
        res.push(codePoint)
        i += bytesPerSequence
      }
    
      return decodeCodePointsArray(res)
    }
    
    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    const MAX_ARGUMENTS_LENGTH = 0x1000
    
    function decodeCodePointsArray (codePoints) {
      const len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }
    
      // Decode in chunks to avoid "call stack size exceeded".
      let res = ''
      let i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }
    
    function asciiSlice (buf, start, end) {
      let ret = ''
      end = Math.min(buf.length, end)
    
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }
    
    function latin1Slice (buf, start, end) {
      let ret = ''
      end = Math.min(buf.length, end)
    
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }
    
    function hexSlice (buf, start, end) {
      const len = buf.length
    
      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len
    
      let out = ''
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]]
      }
      return out
    }
    
    function utf16leSlice (buf, start, end) {
      const bytes = buf.slice(start, end)
      let res = ''
      // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
      }
      return res
    }
    
    Buffer.prototype.slice = function slice (start, end) {
      const len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end
    
      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }
    
      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }
    
      if (end < start) end = start
    
      const newBuf = this.subarray(start, end)
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(newBuf, Buffer.prototype)
    
      return newBuf
    }
    
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    
    Buffer.prototype.readUintLE =
    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      let val = this[offset]
      let mul = 1
      let i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUintBE =
    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }
    
      let val = this[offset + --byteLength]
      let mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUint8 =
    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }
    
    Buffer.prototype.readUint16LE =
    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }
    
    Buffer.prototype.readUint16BE =
    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }
    
    Buffer.prototype.readUint32LE =
    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    }
    
    Buffer.prototype.readUint32BE =
    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    }
    
    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
      offset = offset >>> 0
      validateNumber(offset, 'offset')
      const first = this[offset]
      const last = this[offset + 7]
      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8)
      }
    
      const lo = first +
        this[++offset] * 2 ** 8 +
        this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 24
    
      const hi = this[++offset] +
        this[++offset] * 2 ** 8 +
        this[++offset] * 2 ** 16 +
        last * 2 ** 24
    
      return BigInt(lo) + (BigInt(hi) << BigInt(32))
    })
    
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
      offset = offset >>> 0
      validateNumber(offset, 'offset')
      const first = this[offset]
      const last = this[offset + 7]
      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8)
      }
    
      const hi = first * 2 ** 24 +
        this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 8 +
        this[++offset]
    
      const lo = this[++offset] * 2 ** 24 +
        this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 8 +
        last
    
      return (BigInt(hi) << BigInt(32)) + BigInt(lo)
    })
    
    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      let val = this[offset]
      let mul = 1
      let i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      let i = byteLength
      let mul = 1
      let val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }
    
    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      const val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      const val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }
    
    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }
    
    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
      offset = offset >>> 0
      validateNumber(offset, 'offset')
      const first = this[offset]
      const last = this[offset + 7]
      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8)
      }
    
      const val = this[offset + 4] +
        this[offset + 5] * 2 ** 8 +
        this[offset + 6] * 2 ** 16 +
        (last << 24) // Overflow
    
      return (BigInt(val) << BigInt(32)) +
        BigInt(first +
        this[++offset] * 2 ** 8 +
        this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 24)
    })
    
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
      offset = offset >>> 0
      validateNumber(offset, 'offset')
      const first = this[offset]
      const last = this[offset + 7]
      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8)
      }
    
      const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 8 +
        this[++offset]
    
      return (BigInt(val) << BigInt(32)) +
        BigInt(this[++offset] * 2 ** 24 +
        this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 8 +
        last)
    })
    
    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }
    
    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }
    
    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }
    
    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }
    
    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }
    
    Buffer.prototype.writeUintLE =
    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      let mul = 1
      let i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUintBE =
    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      let i = byteLength - 1
      let mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUint8 =
    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeUint16LE =
    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      return offset + 2
    }
    
    Buffer.prototype.writeUint16BE =
    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
      return offset + 2
    }
    
    Buffer.prototype.writeUint32LE =
    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      this[offset + 3] = (value >>> 24)
      this[offset + 2] = (value >>> 16)
      this[offset + 1] = (value >>> 8)
      this[offset] = (value & 0xff)
      return offset + 4
    }
    
    Buffer.prototype.writeUint32BE =
    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
      return offset + 4
    }
    
    function wrtBigUInt64LE (buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7)
    
      let lo = Number(value & BigInt(0xffffffff))
      buf[offset++] = lo
      lo = lo >> 8
      buf[offset++] = lo
      lo = lo >> 8
      buf[offset++] = lo
      lo = lo >> 8
      buf[offset++] = lo
      let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
      buf[offset++] = hi
      hi = hi >> 8
      buf[offset++] = hi
      hi = hi >> 8
      buf[offset++] = hi
      hi = hi >> 8
      buf[offset++] = hi
      return offset
    }
    
    function wrtBigUInt64BE (buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7)
    
      let lo = Number(value & BigInt(0xffffffff))
      buf[offset + 7] = lo
      lo = lo >> 8
      buf[offset + 6] = lo
      lo = lo >> 8
      buf[offset + 5] = lo
      lo = lo >> 8
      buf[offset + 4] = lo
      let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
      buf[offset + 3] = hi
      hi = hi >> 8
      buf[offset + 2] = hi
      hi = hi >> 8
      buf[offset + 1] = hi
      hi = hi >> 8
      buf[offset] = hi
      return offset + 8
    }
    
    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    })
    
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    })
    
    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        const limit = Math.pow(2, (8 * byteLength) - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      let i = 0
      let mul = 1
      let sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        const limit = Math.pow(2, (8 * byteLength) - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      let i = byteLength - 1
      let mul = 1
      let sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      return offset + 2
    }
    
    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
      return offset + 2
    }
    
    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      this[offset + 2] = (value >>> 16)
      this[offset + 3] = (value >>> 24)
      return offset + 4
    }
    
    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
      return offset + 4
    }
    
    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    })
    
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    })
    
    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }
    
    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }
    
    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    
    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }
    
    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    
    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start
    
      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
    
      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
    
      const len = end - start
    
      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end)
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        )
      }
    
      return len
    }
    
    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0)
          if ((encoding === 'utf8' && code < 128) ||
              encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255
      } else if (typeof val === 'boolean') {
        val = Number(val)
      }
    
      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }
    
      if (end <= start) {
        return this
      }
    
      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0
    
      if (!val) val = 0
    
      let i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        const bytes = Buffer.isBuffer(val)
          ? val
          : Buffer.from(val, encoding)
        const len = bytes.length
        if (len === 0) {
          throw new TypeError('The value "' + val +
            '" is invalid for argument "value"')
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
    
      return this
    }
    
    // CUSTOM ERRORS
    // =============
    
    // Simplified versions from Node, changed for Buffer-only usage
    const errors = {}
    function E (sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor () {
          super()
    
          Object.defineProperty(this, 'message', {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          })
    
          // Add the error code to the name to include it in the stack trace.
          this.name = `${this.name} [${sym}]`
          // Access the stack to generate the error message including the error code
          // from the name.
          this.stack // eslint-disable-line no-unused-expressions
          // Reset the name to the actual name.
          delete this.name
        }
    
        get code () {
          return sym
        }
    
        set code (value) {
          Object.defineProperty(this, 'code', {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          })
        }
    
        toString () {
          return `${this.name} [${sym}]: ${this.message}`
        }
      }
    }
    
    E('ERR_BUFFER_OUT_OF_BOUNDS',
      function (name) {
        if (name) {
          return `${name} is outside of buffer bounds`
        }
    
        return 'Attempt to access memory outside buffer bounds'
      }, RangeError)
    E('ERR_INVALID_ARG_TYPE',
      function (name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`
      }, TypeError)
    E('ERR_OUT_OF_RANGE',
      function (str, range, input) {
        let msg = `The value of "${str}" is out of range.`
        let received = input
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input))
        } else if (typeof input === 'bigint') {
          received = String(input)
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received)
          }
          received += 'n'
        }
        msg += ` It must be ${range}. Received ${received}`
        return msg
      }, RangeError)
    
    function addNumericalSeparator (val) {
      let res = ''
      let i = val.length
      const start = val[0] === '-' ? 1 : 0
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`
      }
      return `${val.slice(0, i)}${res}`
    }
    
    // CHECK FUNCTIONS
    // ===============
    
    function checkBounds (buf, offset, byteLength) {
      validateNumber(offset, 'offset')
      if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1))
      }
    }
    
    function checkIntBI (value, min, max, buf, offset, byteLength) {
      if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : ''
        let range
        if (byteLength > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
          } else {
            range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                    `${(byteLength + 1) * 8 - 1}${n}`
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`
        }
        throw new errors.ERR_OUT_OF_RANGE('value', range, value)
      }
      checkBounds(buf, offset, byteLength)
    }
    
    function validateNumber (value, name) {
      if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
      }
    }
    
    function boundsError (value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type)
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
      }
    
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
      }
    
      throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                        `>= ${type ? 1 : 0} and <= ${length}`,
                                        value)
    }
    
    // HELPER FUNCTIONS
    // ================
    
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
    
    function base64clean (str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = str.trim().replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }
    
    function utf8ToBytes (string, units) {
      units = units || Infinity
      let codePoint
      const length = string.length
      let leadSurrogate = null
      const bytes = []
    
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)
    
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }
    
            // valid lead
            leadSurrogate = codePoint
    
            continue
          }
    
          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }
    
          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }
    
        leadSurrogate = null
    
        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }
    
      return bytes
    }
    
    function asciiToBytes (str) {
      const byteArray = []
      for (let i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }
    
    function utf16leToBytes (str, units) {
      let c, hi, lo
      const byteArray = []
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break
    
        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }
    
      return byteArray
    }
    
    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }
    
    function blitBuffer (src, dst, offset, length) {
      let i
      for (i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }
    
    // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166
    function isInstance (obj, type) {
      return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
          obj.constructor.name === type.name)
    }
    function numberIsNaN (obj) {
      // For IE11 support
      return obj !== obj // eslint-disable-line no-self-compare
    }
    
    // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219
    const hexSliceLookupTable = (function () {
      const alphabet = '0123456789abcdef'
      const table = new Array(256)
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j]
        }
      }
      return table
    })()
    
    // Return not function with Error if BigInt not supported
    function defineBigIntMethod (fn) {
      return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
    }
    
    function BufferBigIntNotDefined () {
      throw new Error('BigInt not supported')
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
    /*!***********************************************************!*\
      !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
      \***********************************************************/
    /***/ (function(module, exports) {
    
    var global = typeof self !== 'undefined' ? self : this;
    var __self__ = (function () {
    function F() {
    this.fetch = false;
    this.DOMException = global.DOMException
    }
    F.prototype = global;
    return new F();
    })();
    (function(self) {
    
    var irrelevant = (function (exports) {
    
      var support = {
        searchParams: 'URLSearchParams' in self,
        iterable: 'Symbol' in self && 'iterator' in Symbol,
        blob:
          'FileReader' in self &&
          'Blob' in self &&
          (function() {
            try {
              new Blob();
              return true
            } catch (e) {
              return false
            }
          })(),
        formData: 'FormData' in self,
        arrayBuffer: 'ArrayBuffer' in self
      };
    
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj)
      }
    
      if (support.arrayBuffer) {
        var viewClasses = [
          '[object Int8Array]',
          '[object Uint8Array]',
          '[object Uint8ClampedArray]',
          '[object Int16Array]',
          '[object Uint16Array]',
          '[object Int32Array]',
          '[object Uint32Array]',
          '[object Float32Array]',
          '[object Float64Array]'
        ];
    
        var isArrayBufferView =
          ArrayBuffer.isView ||
          function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          };
      }
    
      function normalizeName(name) {
        if (typeof name !== 'string') {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError('Invalid character in header field name')
        }
        return name.toLowerCase()
      }
    
      function normalizeValue(value) {
        if (typeof value !== 'string') {
          value = String(value);
        }
        return value
      }
    
      // Build a destructive iterator for the value list
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return {done: value === undefined, value: value}
          }
        };
    
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator
          };
        }
    
        return iterator
      }
    
      function Headers(headers) {
        this.map = {};
    
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
    
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ', ' + value : value;
      };
    
      Headers.prototype['delete'] = function(name) {
        delete this.map[normalizeName(name)];
      };
    
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null
      };
    
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name))
      };
    
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
    
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
    
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items)
      };
    
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items)
      };
    
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items)
      };
    
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
    
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError('Already read'))
        }
        body.bodyUsed = true;
      }
    
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        })
      }
    
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise
      }
    
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise
      }
    
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
    
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join('')
      }
    
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0)
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer
        }
      }
    
      function Body() {
        this.bodyUsed = false;
    
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = '';
          } else if (typeof body === 'string') {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            // IE 10-11 can't handle a DataView body.
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
    
          if (!this.headers.get('content-type')) {
            if (typeof body === 'string') {
              this.headers.set('content-type', 'text/plain;charset=UTF-8');
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set('content-type', this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }
          }
        };
    
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected
            }
    
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as blob')
            } else {
              return Promise.resolve(new Blob([this._bodyText]))
            }
          };
    
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
            } else {
              return this.blob().then(readBlobAsArrayBuffer)
            }
          };
        }
    
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected
          }
    
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob)
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as text')
          } else {
            return Promise.resolve(this._bodyText)
          }
        };
    
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode)
          };
        }
    
        this.json = function() {
          return this.text().then(JSON.parse)
        };
    
        return this
      }
    
      // HTTP methods whose capitalization should be normalized
      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
    
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method
      }
    
      function Request(input, options) {
        options = options || {};
        var body = options.body;
    
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError('Already read')
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
    
        this.credentials = options.credentials || this.credentials || 'same-origin';
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || 'GET');
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
    
        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
          throw new TypeError('Body not allowed for GET or HEAD requests')
        }
        this._initBody(body);
      }
    
      Request.prototype.clone = function() {
        return new Request(this, {body: this._bodyInit})
      };
    
      function decode(body) {
        var form = new FormData();
        body
          .trim()
          .split('&')
          .forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=');
              var name = split.shift().replace(/\+/g, ' ');
              var value = split.join('=').replace(/\+/g, ' ');
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
        return form
      }
    
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
        // https://tools.ietf.org/html/rfc7230#section-3.2
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(':');
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(':').trim();
            headers.append(key, value);
          }
        });
        return headers
      }
    
      Body.call(Request.prototype);
    
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
    
        this.type = 'default';
        this.status = options.status === undefined ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = 'statusText' in options ? options.statusText : 'OK';
        this.headers = new Headers(options.headers);
        this.url = options.url || '';
        this._initBody(bodyInit);
      }
    
      Body.call(Response.prototype);
    
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        })
      };
    
      Response.error = function() {
        var response = new Response(null, {status: 0, statusText: ''});
        response.type = 'error';
        return response
      };
    
      var redirectStatuses = [301, 302, 303, 307, 308];
    
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError('Invalid status code')
        }
    
        return new Response(null, {status: status, headers: {location: url}})
      };
    
      exports.DOMException = self.DOMException;
      try {
        new exports.DOMException();
      } catch (err) {
        exports.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports.DOMException.prototype = Object.create(Error.prototype);
        exports.DOMException.prototype.constructor = exports.DOMException;
      }
    
      function fetch(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
    
          if (request.signal && request.signal.aborted) {
            return reject(new exports.DOMException('Aborted', 'AbortError'))
          }
    
          var xhr = new XMLHttpRequest();
    
          function abortXhr() {
            xhr.abort();
          }
    
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || '')
            };
            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
            var body = 'response' in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
    
          xhr.onerror = function() {
            reject(new TypeError('Network request failed'));
          };
    
          xhr.ontimeout = function() {
            reject(new TypeError('Network request failed'));
          };
    
          xhr.onabort = function() {
            reject(new exports.DOMException('Aborted', 'AbortError'));
          };
    
          xhr.open(request.method, request.url, true);
    
          if (request.credentials === 'include') {
            xhr.withCredentials = true;
          } else if (request.credentials === 'omit') {
            xhr.withCredentials = false;
          }
    
          if ('responseType' in xhr && support.blob) {
            xhr.responseType = 'blob';
          }
    
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
    
          if (request.signal) {
            request.signal.addEventListener('abort', abortXhr);
    
            xhr.onreadystatechange = function() {
              // DONE (success or failure)
              if (xhr.readyState === 4) {
                request.signal.removeEventListener('abort', abortXhr);
              }
            };
          }
    
          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        })
      }
    
      fetch.polyfill = true;
    
      if (!self.fetch) {
        self.fetch = fetch;
        self.Headers = Headers;
        self.Request = Request;
        self.Response = Response;
      }
    
      exports.Headers = Headers;
      exports.Request = Request;
      exports.Response = Response;
      exports.fetch = fetch;
    
      Object.defineProperty(exports, '__esModule', { value: true });
    
      return exports;
    
    })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    // Remove "polyfill" property added by whatwg-fetch
    delete __self__.fetch.polyfill;
    // Choose between native implementation (global) or custom implementation (__self__)
    // var ctx = global.fetch ? global : __self__;
    var ctx = __self__; // this line disable service worker support temporarily
    exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
    exports["default"] = ctx.fetch // For TypeScript consumers without esModuleInterop.
    exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
    exports.Headers = ctx.Headers
    exports.Request = ctx.Request
    exports.Response = ctx.Response
    module.exports = exports
    
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/aes.js":
    /*!***************************************!*\
      !*** ./node_modules/crypto-js/aes.js ***!
      \***************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;
    
            // Lookup tables
            var SBOX = [];
            var INV_SBOX = [];
            var SUB_MIX_0 = [];
            var SUB_MIX_1 = [];
            var SUB_MIX_2 = [];
            var SUB_MIX_3 = [];
            var INV_SUB_MIX_0 = [];
            var INV_SUB_MIX_1 = [];
            var INV_SUB_MIX_2 = [];
            var INV_SUB_MIX_3 = [];
    
            // Compute lookup tables
            (function () {
                // Compute double table
                var d = [];
                for (var i = 0; i < 256; i++) {
                    if (i < 128) {
                        d[i] = i << 1;
                    } else {
                        d[i] = (i << 1) ^ 0x11b;
                    }
                }
    
                // Walk GF(2^8)
                var x = 0;
                var xi = 0;
                for (var i = 0; i < 256; i++) {
                    // Compute sbox
                    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                    SBOX[x] = sx;
                    INV_SBOX[sx] = x;
    
                    // Compute multiplication
                    var x2 = d[x];
                    var x4 = d[x2];
                    var x8 = d[x4];
    
                    // Compute sub bytes, mix columns tables
                    var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                    SUB_MIX_0[x] = (t << 24) | (t >>> 8);
                    SUB_MIX_1[x] = (t << 16) | (t >>> 16);
                    SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
                    SUB_MIX_3[x] = t;
    
                    // Compute inv sub bytes, inv mix columns tables
                    var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
                    INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
                    INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
                    INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
                    INV_SUB_MIX_3[sx] = t;
    
                    // Compute next counter
                    if (!x) {
                        x = xi = 1;
                    } else {
                        x = x2 ^ d[d[d[x8 ^ x2]]];
                        xi ^= d[d[xi]];
                    }
                }
            }());
    
            // Precomputed Rcon lookup
            var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    
            /**
             * AES block cipher algorithm.
             */
            var AES = C_algo.AES = BlockCipher.extend({
                _doReset: function () {
                    var t;
    
                    // Skip reset of nRounds has been set before and key did not change
                    if (this._nRounds && this._keyPriorReset === this._key) {
                        return;
                    }
    
                    // Shortcuts
                    var key = this._keyPriorReset = this._key;
                    var keyWords = key.words;
                    var keySize = key.sigBytes / 4;
    
                    // Compute number of rounds
                    var nRounds = this._nRounds = keySize + 6;
    
                    // Compute number of key schedule rows
                    var ksRows = (nRounds + 1) * 4;
    
                    // Compute key schedule
                    var keySchedule = this._keySchedule = [];
                    for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                        if (ksRow < keySize) {
                            keySchedule[ksRow] = keyWords[ksRow];
                        } else {
                            t = keySchedule[ksRow - 1];
    
                            if (!(ksRow % keySize)) {
                                // Rot word
                                t = (t << 8) | (t >>> 24);
    
                                // Sub word
                                t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
    
                                // Mix Rcon
                                t ^= RCON[(ksRow / keySize) | 0] << 24;
                            } else if (keySize > 6 && ksRow % keySize == 4) {
                                // Sub word
                                t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                            }
    
                            keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                        }
                    }
    
                    // Compute inv key schedule
                    var invKeySchedule = this._invKeySchedule = [];
                    for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                        var ksRow = ksRows - invKsRow;
    
                        if (invKsRow % 4) {
                            var t = keySchedule[ksRow];
                        } else {
                            var t = keySchedule[ksRow - 4];
                        }
    
                        if (invKsRow < 4 || ksRow <= 4) {
                            invKeySchedule[invKsRow] = t;
                        } else {
                            invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                                       INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                        }
                    }
                },
    
                encryptBlock: function (M, offset) {
                    this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                },
    
                decryptBlock: function (M, offset) {
                    // Swap 2nd and 4th rows
                    var t = M[offset + 1];
                    M[offset + 1] = M[offset + 3];
                    M[offset + 3] = t;
    
                    this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
    
                    // Inv swap 2nd and 4th rows
                    var t = M[offset + 1];
                    M[offset + 1] = M[offset + 3];
                    M[offset + 3] = t;
                },
    
                _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
                    // Shortcut
                    var nRounds = this._nRounds;
    
                    // Get input, add round key
                    var s0 = M[offset]     ^ keySchedule[0];
                    var s1 = M[offset + 1] ^ keySchedule[1];
                    var s2 = M[offset + 2] ^ keySchedule[2];
                    var s3 = M[offset + 3] ^ keySchedule[3];
    
                    // Key schedule row counter
                    var ksRow = 4;
    
                    // Rounds
                    for (var round = 1; round < nRounds; round++) {
                        // Shift rows, sub bytes, mix columns, add round key
                        var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                        var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                        var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                        var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];
    
                        // Update state
                        s0 = t0;
                        s1 = t1;
                        s2 = t2;
                        s3 = t3;
                    }
    
                    // Shift rows, sub bytes, add round key
                    var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
                    var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
                    var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
                    var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    
                    // Set output
                    M[offset]     = t0;
                    M[offset + 1] = t1;
                    M[offset + 2] = t2;
                    M[offset + 3] = t3;
                },
    
                keySize: 256/32
            });
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
             */
            C.AES = BlockCipher._createHelper(AES);
        }());
    
    
        return CryptoJS.AES;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/blowfish.js":
    /*!********************************************!*\
      !*** ./node_modules/crypto-js/blowfish.js ***!
      \********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;
    
            const N = 16;
    
            //Origin pbox and sbox, derived from PI
            const ORIG_P = [
                0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
                0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
                0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
                0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
                0x9216D5D9, 0x8979FB1B
            ];
    
            const ORIG_S = [
                [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
                    0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
                    0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
                    0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
                    0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
                    0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
                    0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
                    0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
                    0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
                    0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
                    0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
                    0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
                    0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
                    0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
                    0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
                    0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
                    0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
                    0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
                    0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
                    0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
                    0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
                    0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
                    0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
                    0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
                    0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
                    0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
                    0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
                    0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
                    0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
                    0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
                    0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
                    0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
                    0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
                    0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
                    0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
                    0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
                    0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
                    0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
                    0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
                    0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
                    0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
                    0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
                    0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
                    0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
                    0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
                    0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
                    0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
                    0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
                    0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
                    0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
                    0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
                    0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
                    0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
                    0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
                    0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
                    0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
                    0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
                    0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
                    0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
                    0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
                    0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
                    0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
                    0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
                    0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],
                [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
                    0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
                    0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
                    0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
                    0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
                    0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
                    0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
                    0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
                    0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
                    0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
                    0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
                    0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
                    0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
                    0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
                    0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
                    0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
                    0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
                    0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
                    0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
                    0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
                    0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
                    0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
                    0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
                    0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
                    0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
                    0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
                    0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
                    0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
                    0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
                    0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
                    0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
                    0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
                    0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
                    0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
                    0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
                    0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
                    0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
                    0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
                    0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
                    0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
                    0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
                    0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
                    0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
                    0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
                    0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
                    0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
                    0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
                    0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
                    0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
                    0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
                    0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
                    0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
                    0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
                    0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
                    0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
                    0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
                    0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
                    0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
                    0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
                    0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
                    0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
                    0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
                    0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
                    0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],
                [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
                    0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
                    0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
                    0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
                    0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
                    0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
                    0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
                    0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
                    0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
                    0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
                    0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
                    0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
                    0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
                    0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
                    0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
                    0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
                    0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
                    0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
                    0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
                    0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
                    0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
                    0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
                    0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
                    0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
                    0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
                    0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
                    0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
                    0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
                    0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
                    0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
                    0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
                    0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
                    0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
                    0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
                    0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
                    0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
                    0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
                    0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
                    0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
                    0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
                    0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
                    0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
                    0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
                    0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
                    0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
                    0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
                    0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
                    0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
                    0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
                    0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
                    0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
                    0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
                    0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
                    0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
                    0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
                    0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
                    0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
                    0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
                    0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
                    0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
                    0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
                    0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
                    0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
                    0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],
                [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
                    0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
                    0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
                    0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
                    0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
                    0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
                    0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
                    0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
                    0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
                    0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
                    0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
                    0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
                    0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
                    0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
                    0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
                    0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
                    0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
                    0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
                    0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
                    0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
                    0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
                    0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
                    0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
                    0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
                    0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
                    0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
                    0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
                    0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
                    0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
                    0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
                    0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
                    0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
                    0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
                    0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
                    0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
                    0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
                    0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
                    0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
                    0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
                    0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
                    0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
                    0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
                    0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
                    0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
                    0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
                    0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
                    0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
                    0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
                    0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
                    0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
                    0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
                    0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
                    0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
                    0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
                    0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
                    0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
                    0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
                    0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
                    0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
                    0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
                    0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
                    0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
                    0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
                    0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]
            ];
    
            var BLOWFISH_CTX = {
                pbox: [],
                sbox: []
            }
    
            function F(ctx, x){
                let a = (x >> 24) & 0xFF;
                let b = (x >> 16) & 0xFF;
                let c = (x >> 8) & 0xFF;
                let d = x & 0xFF;
    
                let y = ctx.sbox[0][a] + ctx.sbox[1][b];
                y = y ^ ctx.sbox[2][c];
                y = y + ctx.sbox[3][d];
    
                return y;
            }
    
            function BlowFish_Encrypt(ctx, left, right){
                let Xl = left;
                let Xr = right;
                let temp;
    
                for(let i = 0; i < N; ++i){
                    Xl = Xl ^ ctx.pbox[i];
                    Xr = F(ctx, Xl) ^ Xr;
    
                    temp = Xl;
                    Xl = Xr;
                    Xr = temp;
                }
    
                temp = Xl;
                Xl = Xr;
                Xr = temp;
    
                Xr = Xr ^ ctx.pbox[N];
                Xl = Xl ^ ctx.pbox[N + 1];
    
                return {left: Xl, right: Xr};
            }
    
            function BlowFish_Decrypt(ctx, left, right){
                let Xl = left;
                let Xr = right;
                let temp;
    
                for(let i = N + 1; i > 1; --i){
                    Xl = Xl ^ ctx.pbox[i];
                    Xr = F(ctx, Xl) ^ Xr;
    
                    temp = Xl;
                    Xl = Xr;
                    Xr = temp;
                }
    
                temp = Xl;
                Xl = Xr;
                Xr = temp;
    
                Xr = Xr ^ ctx.pbox[1];
                Xl = Xl ^ ctx.pbox[0];
    
                return {left: Xl, right: Xr};
            }
    
            /**
             * Initialization ctx's pbox and sbox.
             *
             * @param {Object} ctx The object has pbox and sbox.
             * @param {Array} key An array of 32-bit words.
             * @param {int} keysize The length of the key.
             *
             * @example
             *
             *     BlowFishInit(BLOWFISH_CTX, key, 128/32);
             */
            function BlowFishInit(ctx, key, keysize)
            {
                for(let Row = 0; Row < 4; Row++)
                {
                    ctx.sbox[Row] = [];
                    for(let Col = 0; Col < 256; Col++)
                    {
                        ctx.sbox[Row][Col] = ORIG_S[Row][Col];
                    }
                }
    
                let keyIndex = 0;
                for(let index = 0; index < N + 2; index++)
                {
                    ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
                    keyIndex++;
                    if(keyIndex >= keysize)
                    {
                        keyIndex = 0;
                    }
                }
    
                let Data1 = 0;
                let Data2 = 0;
                let res = 0;
                for(let i = 0; i < N + 2; i += 2)
                {
                    res = BlowFish_Encrypt(ctx, Data1, Data2);
                    Data1 = res.left;
                    Data2 = res.right;
                    ctx.pbox[i] = Data1;
                    ctx.pbox[i + 1] = Data2;
                }
    
                for(let i = 0; i < 4; i++)
                {
                    for(let j = 0; j < 256; j += 2)
                    {
                        res = BlowFish_Encrypt(ctx, Data1, Data2);
                        Data1 = res.left;
                        Data2 = res.right;
                        ctx.sbox[i][j] = Data1;
                        ctx.sbox[i][j + 1] = Data2;
                    }
                }
    
                return true;
            }
    
            /**
             * Blowfish block cipher algorithm.
             */
            var Blowfish = C_algo.Blowfish = BlockCipher.extend({
                _doReset: function () {
                    // Skip reset of nRounds has been set before and key did not change
                    if (this._keyPriorReset === this._key) {
                        return;
                    }
    
                    // Shortcuts
                    var key = this._keyPriorReset = this._key;
                    var keyWords = key.words;
                    var keySize = key.sigBytes / 4;
    
                    //Initialization pbox and sbox
                    BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
                },
    
                encryptBlock: function (M, offset) {
                    var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                    M[offset] = res.left;
                    M[offset + 1] = res.right;
                },
    
                decryptBlock: function (M, offset) {
                    var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                    M[offset] = res.left;
                    M[offset + 1] = res.right;
                },
    
                blockSize: 64/32,
    
                keySize: 128/32,
    
                ivSize: 64/32
            });
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);
             */
            C.Blowfish = BlockCipher._createHelper(Blowfish);
        }());
    
    
        return CryptoJS.Blowfish;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/cipher-core.js":
    /*!***********************************************!*\
      !*** ./node_modules/crypto-js/cipher-core.js ***!
      \***********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * Cipher core components.
         */
        CryptoJS.lib.Cipher || (function (undefined) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var Base64 = C_enc.Base64;
            var C_algo = C.algo;
            var EvpKDF = C_algo.EvpKDF;
    
            /**
             * Abstract base cipher template.
             *
             * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
             * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
             * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
             * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
             */
            var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 *
                 * @property {WordArray} iv The IV to use for this operation.
                 */
                cfg: Base.extend(),
    
                /**
                 * Creates this cipher in encryption mode.
                 *
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {Cipher} A cipher instance.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                 */
                createEncryptor: function (key, cfg) {
                    return this.create(this._ENC_XFORM_MODE, key, cfg);
                },
    
                /**
                 * Creates this cipher in decryption mode.
                 *
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {Cipher} A cipher instance.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                 */
                createDecryptor: function (key, cfg) {
                    return this.create(this._DEC_XFORM_MODE, key, cfg);
                },
    
                /**
                 * Initializes a newly created cipher.
                 *
                 * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                 */
                init: function (xformMode, key, cfg) {
                    // Apply config defaults
                    this.cfg = this.cfg.extend(cfg);
    
                    // Store transform mode and key
                    this._xformMode = xformMode;
                    this._key = key;
    
                    // Set initial values
                    this.reset();
                },
    
                /**
                 * Resets this cipher to its initial state.
                 *
                 * @example
                 *
                 *     cipher.reset();
                 */
                reset: function () {
                    // Reset data buffer
                    BufferedBlockAlgorithm.reset.call(this);
    
                    // Perform concrete-cipher logic
                    this._doReset();
                },
    
                /**
                 * Adds data to be encrypted or decrypted.
                 *
                 * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                 *
                 * @return {WordArray} The data after processing.
                 *
                 * @example
                 *
                 *     var encrypted = cipher.process('data');
                 *     var encrypted = cipher.process(wordArray);
                 */
                process: function (dataUpdate) {
                    // Append
                    this._append(dataUpdate);
    
                    // Process available blocks
                    return this._process();
                },
    
                /**
                 * Finalizes the encryption or decryption process.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                 *
                 * @return {WordArray} The data after final processing.
                 *
                 * @example
                 *
                 *     var encrypted = cipher.finalize();
                 *     var encrypted = cipher.finalize('data');
                 *     var encrypted = cipher.finalize(wordArray);
                 */
                finalize: function (dataUpdate) {
                    // Final data update
                    if (dataUpdate) {
                        this._append(dataUpdate);
                    }
    
                    // Perform concrete-cipher logic
                    var finalProcessedData = this._doFinalize();
    
                    return finalProcessedData;
                },
    
                keySize: 128/32,
    
                ivSize: 128/32,
    
                _ENC_XFORM_MODE: 1,
    
                _DEC_XFORM_MODE: 2,
    
                /**
                 * Creates shortcut functions to a cipher's object interface.
                 *
                 * @param {Cipher} cipher The cipher to create a helper for.
                 *
                 * @return {Object} An object with encrypt and decrypt shortcut functions.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                 */
                _createHelper: (function () {
                    function selectCipherStrategy(key) {
                        if (typeof key == 'string') {
                            return PasswordBasedCipher;
                        } else {
                            return SerializableCipher;
                        }
                    }
    
                    return function (cipher) {
                        return {
                            encrypt: function (message, key, cfg) {
                                return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                            },
    
                            decrypt: function (ciphertext, key, cfg) {
                                return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                            }
                        };
                    };
                }())
            });
    
            /**
             * Abstract base stream cipher template.
             *
             * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
             */
            var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                _doFinalize: function () {
                    // Process partial blocks
                    var finalProcessedBlocks = this._process(!!'flush');
    
                    return finalProcessedBlocks;
                },
    
                blockSize: 1
            });
    
            /**
             * Mode namespace.
             */
            var C_mode = C.mode = {};
    
            /**
             * Abstract base block cipher mode template.
             */
            var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                /**
                 * Creates this mode for encryption.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                 */
                createEncryptor: function (cipher, iv) {
                    return this.Encryptor.create(cipher, iv);
                },
    
                /**
                 * Creates this mode for decryption.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                 */
                createDecryptor: function (cipher, iv) {
                    return this.Decryptor.create(cipher, iv);
                },
    
                /**
                 * Initializes a newly created mode.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                 */
                init: function (cipher, iv) {
                    this._cipher = cipher;
                    this._iv = iv;
                }
            });
    
            /**
             * Cipher Block Chaining mode.
             */
            var CBC = C_mode.CBC = (function () {
                /**
                 * Abstract base CBC mode.
                 */
                var CBC = BlockCipherMode.extend();
    
                /**
                 * CBC encryptor.
                 */
                CBC.Encryptor = CBC.extend({
                    /**
                     * Processes the data block at offset.
                     *
                     * @param {Array} words The data words to operate on.
                     * @param {number} offset The offset where the block starts.
                     *
                     * @example
                     *
                     *     mode.processBlock(data.words, offset);
                     */
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
    
                        // XOR and encrypt
                        xorBlock.call(this, words, offset, blockSize);
                        cipher.encryptBlock(words, offset);
    
                        // Remember this block to use with next block
                        this._prevBlock = words.slice(offset, offset + blockSize);
                    }
                });
    
                /**
                 * CBC decryptor.
                 */
                CBC.Decryptor = CBC.extend({
                    /**
                     * Processes the data block at offset.
                     *
                     * @param {Array} words The data words to operate on.
                     * @param {number} offset The offset where the block starts.
                     *
                     * @example
                     *
                     *     mode.processBlock(data.words, offset);
                     */
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
    
                        // Remember this block to use with next block
                        var thisBlock = words.slice(offset, offset + blockSize);
    
                        // Decrypt and XOR
                        cipher.decryptBlock(words, offset);
                        xorBlock.call(this, words, offset, blockSize);
    
                        // This block becomes the previous block
                        this._prevBlock = thisBlock;
                    }
                });
    
                function xorBlock(words, offset, blockSize) {
                    var block;
    
                    // Shortcut
                    var iv = this._iv;
    
                    // Choose mixing block
                    if (iv) {
                        block = iv;
    
                        // Remove IV for subsequent blocks
                        this._iv = undefined;
                    } else {
                        block = this._prevBlock;
                    }
    
                    // XOR blocks
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= block[i];
                    }
                }
    
                return CBC;
            }());
    
            /**
             * Padding namespace.
             */
            var C_pad = C.pad = {};
    
            /**
             * PKCS #5/7 padding strategy.
             */
            var Pkcs7 = C_pad.Pkcs7 = {
                /**
                 * Pads data using the algorithm defined in PKCS #5/7.
                 *
                 * @param {WordArray} data The data to pad.
                 * @param {number} blockSize The multiple that the data should be padded to.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                 */
                pad: function (data, blockSize) {
                    // Shortcut
                    var blockSizeBytes = blockSize * 4;
    
                    // Count padding bytes
                    var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
    
                    // Create padding word
                    var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;
    
                    // Create padding
                    var paddingWords = [];
                    for (var i = 0; i < nPaddingBytes; i += 4) {
                        paddingWords.push(paddingWord);
                    }
                    var padding = WordArray.create(paddingWords, nPaddingBytes);
    
                    // Add padding
                    data.concat(padding);
                },
    
                /**
                 * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                 *
                 * @param {WordArray} data The data to unpad.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                 */
                unpad: function (data) {
                    // Get number of padding bytes from last byte
                    var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
    
                    // Remove padding
                    data.sigBytes -= nPaddingBytes;
                }
            };
    
            /**
             * Abstract base block cipher template.
             *
             * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
             */
            var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {Mode} mode The block mode to use. Default: CBC
                 * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                 */
                cfg: Cipher.cfg.extend({
                    mode: CBC,
                    padding: Pkcs7
                }),
    
                reset: function () {
                    var modeCreator;
    
                    // Reset cipher
                    Cipher.reset.call(this);
    
                    // Shortcuts
                    var cfg = this.cfg;
                    var iv = cfg.iv;
                    var mode = cfg.mode;
    
                    // Reset block mode
                    if (this._xformMode == this._ENC_XFORM_MODE) {
                        modeCreator = mode.createEncryptor;
                    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                        modeCreator = mode.createDecryptor;
                        // Keep at least one block in the buffer for unpadding
                        this._minBufferSize = 1;
                    }
    
                    if (this._mode && this._mode.__creator == modeCreator) {
                        this._mode.init(this, iv && iv.words);
                    } else {
                        this._mode = modeCreator.call(mode, this, iv && iv.words);
                        this._mode.__creator = modeCreator;
                    }
                },
    
                _doProcessBlock: function (words, offset) {
                    this._mode.processBlock(words, offset);
                },
    
                _doFinalize: function () {
                    var finalProcessedBlocks;
    
                    // Shortcut
                    var padding = this.cfg.padding;
    
                    // Finalize
                    if (this._xformMode == this._ENC_XFORM_MODE) {
                        // Pad data
                        padding.pad(this._data, this.blockSize);
    
                        // Process final blocks
                        finalProcessedBlocks = this._process(!!'flush');
                    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                        // Process final blocks
                        finalProcessedBlocks = this._process(!!'flush');
    
                        // Unpad data
                        padding.unpad(finalProcessedBlocks);
                    }
    
                    return finalProcessedBlocks;
                },
    
                blockSize: 128/32
            });
    
            /**
             * A collection of cipher parameters.
             *
             * @property {WordArray} ciphertext The raw ciphertext.
             * @property {WordArray} key The key to this ciphertext.
             * @property {WordArray} iv The IV used in the ciphering operation.
             * @property {WordArray} salt The salt used with a key derivation function.
             * @property {Cipher} algorithm The cipher algorithm.
             * @property {Mode} mode The block mode used in the ciphering operation.
             * @property {Padding} padding The padding scheme used in the ciphering operation.
             * @property {number} blockSize The block size of the cipher.
             * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
             */
            var CipherParams = C_lib.CipherParams = Base.extend({
                /**
                 * Initializes a newly created cipher params object.
                 *
                 * @param {Object} cipherParams An object with any of the possible cipher parameters.
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.lib.CipherParams.create({
                 *         ciphertext: ciphertextWordArray,
                 *         key: keyWordArray,
                 *         iv: ivWordArray,
                 *         salt: saltWordArray,
                 *         algorithm: CryptoJS.algo.AES,
                 *         mode: CryptoJS.mode.CBC,
                 *         padding: CryptoJS.pad.PKCS7,
                 *         blockSize: 4,
                 *         formatter: CryptoJS.format.OpenSSL
                 *     });
                 */
                init: function (cipherParams) {
                    this.mixIn(cipherParams);
                },
    
                /**
                 * Converts this cipher params object to a string.
                 *
                 * @param {Format} formatter (Optional) The formatting strategy to use.
                 *
                 * @return {string} The stringified cipher params.
                 *
                 * @throws Error If neither the formatter nor the default formatter is set.
                 *
                 * @example
                 *
                 *     var string = cipherParams + '';
                 *     var string = cipherParams.toString();
                 *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                 */
                toString: function (formatter) {
                    return (formatter || this.formatter).stringify(this);
                }
            });
    
            /**
             * Format namespace.
             */
            var C_format = C.format = {};
    
            /**
             * OpenSSL formatting strategy.
             */
            var OpenSSLFormatter = C_format.OpenSSL = {
                /**
                 * Converts a cipher params object to an OpenSSL-compatible string.
                 *
                 * @param {CipherParams} cipherParams The cipher params object.
                 *
                 * @return {string} The OpenSSL-compatible string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                 */
                stringify: function (cipherParams) {
                    var wordArray;
    
                    // Shortcuts
                    var ciphertext = cipherParams.ciphertext;
                    var salt = cipherParams.salt;
    
                    // Format
                    if (salt) {
                        wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
                    } else {
                        wordArray = ciphertext;
                    }
    
                    return wordArray.toString(Base64);
                },
    
                /**
                 * Converts an OpenSSL-compatible string to a cipher params object.
                 *
                 * @param {string} openSSLStr The OpenSSL-compatible string.
                 *
                 * @return {CipherParams} The cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                 */
                parse: function (openSSLStr) {
                    var salt;
    
                    // Parse base64
                    var ciphertext = Base64.parse(openSSLStr);
    
                    // Shortcut
                    var ciphertextWords = ciphertext.words;
    
                    // Test for salt
                    if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                        // Extract salt
                        salt = WordArray.create(ciphertextWords.slice(2, 4));
    
                        // Remove salt from ciphertext
                        ciphertextWords.splice(0, 4);
                        ciphertext.sigBytes -= 16;
                    }
    
                    return CipherParams.create({ ciphertext: ciphertext, salt: salt });
                }
            };
    
            /**
             * A cipher wrapper that returns ciphertext as a serializable cipher params object.
             */
            var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                 */
                cfg: Base.extend({
                    format: OpenSSLFormatter
                }),
    
                /**
                 * Encrypts a message.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {WordArray|string} message The message to encrypt.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {CipherParams} A cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 */
                encrypt: function (cipher, message, key, cfg) {
                    // Apply config defaults
                    cfg = this.cfg.extend(cfg);
    
                    // Encrypt
                    var encryptor = cipher.createEncryptor(key, cfg);
                    var ciphertext = encryptor.finalize(message);
    
                    // Shortcut
                    var cipherCfg = encryptor.cfg;
    
                    // Create and return serializable cipher params
                    return CipherParams.create({
                        ciphertext: ciphertext,
                        key: key,
                        iv: cipherCfg.iv,
                        algorithm: cipher,
                        mode: cipherCfg.mode,
                        padding: cipherCfg.padding,
                        blockSize: cipher.blockSize,
                        formatter: cfg.format
                    });
                },
    
                /**
                 * Decrypts serialized ciphertext.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {WordArray} The plaintext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 */
                decrypt: function (cipher, ciphertext, key, cfg) {
                    // Apply config defaults
                    cfg = this.cfg.extend(cfg);
    
                    // Convert string to CipherParams
                    ciphertext = this._parse(ciphertext, cfg.format);
    
                    // Decrypt
                    var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
    
                    return plaintext;
                },
    
                /**
                 * Converts serialized ciphertext to CipherParams,
                 * else assumed CipherParams already and returns ciphertext unchanged.
                 *
                 * @param {CipherParams|string} ciphertext The ciphertext.
                 * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                 *
                 * @return {CipherParams} The unserialized ciphertext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                 */
                _parse: function (ciphertext, format) {
                    if (typeof ciphertext == 'string') {
                        return format.parse(ciphertext, this);
                    } else {
                        return ciphertext;
                    }
                }
            });
    
            /**
             * Key derivation function namespace.
             */
            var C_kdf = C.kdf = {};
    
            /**
             * OpenSSL key derivation function.
             */
            var OpenSSLKdf = C_kdf.OpenSSL = {
                /**
                 * Derives a key and IV from a password.
                 *
                 * @param {string} password The password to derive from.
                 * @param {number} keySize The size in words of the key to generate.
                 * @param {number} ivSize The size in words of the IV to generate.
                 * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                 *
                 * @return {CipherParams} A cipher params object with the key, IV, and salt.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                 *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                 */
                execute: function (password, keySize, ivSize, salt, hasher) {
                    // Generate random salt
                    if (!salt) {
                        salt = WordArray.random(64/8);
                    }
    
                    // Derive key and IV
                    if (!hasher) {
                        var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
                    } else {
                        var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);
                    }
    
    
                    // Separate key and IV
                    var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                    key.sigBytes = keySize * 4;
    
                    // Return params
                    return CipherParams.create({ key: key, iv: iv, salt: salt });
                }
            };
    
            /**
             * A serializable cipher wrapper that derives the key from a password,
             * and returns ciphertext as a serializable cipher params object.
             */
            var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                 */
                cfg: SerializableCipher.cfg.extend({
                    kdf: OpenSSLKdf
                }),
    
                /**
                 * Encrypts a message using a password.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {WordArray|string} message The message to encrypt.
                 * @param {string} password The password.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {CipherParams} A cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                 *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                 */
                encrypt: function (cipher, message, password, cfg) {
                    // Apply config defaults
                    cfg = this.cfg.extend(cfg);
    
                    // Derive key and other params
                    var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
    
                    // Add IV to config
                    cfg.iv = derivedParams.iv;
    
                    // Encrypt
                    var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
    
                    // Mix in derived params
                    ciphertext.mixIn(derivedParams);
    
                    return ciphertext;
                },
    
                /**
                 * Decrypts serialized ciphertext using a password.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                 * @param {string} password The password.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {WordArray} The plaintext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                 *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                 */
                decrypt: function (cipher, ciphertext, password, cfg) {
                    // Apply config defaults
                    cfg = this.cfg.extend(cfg);
    
                    // Convert string to CipherParams
                    ciphertext = this._parse(ciphertext, cfg.format);
    
                    // Derive key and other params
                    var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
    
                    // Add IV to config
                    cfg.iv = derivedParams.iv;
    
                    // Decrypt
                    var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
    
                    return plaintext;
                }
            });
        }());
    
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/core.js":
    /*!****************************************!*\
      !*** ./node_modules/crypto-js/core.js ***!
      \****************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory();
        }
        else {}
    }(this, function () {
    
        /*globals window, global, require*/
    
        /**
         * CryptoJS core components.
         */
        var CryptoJS = CryptoJS || (function (Math, undefined) {
    
            var crypto;
    
            // Native crypto from window (Browser)
            if (typeof window !== 'undefined' && window.crypto) {
                crypto = window.crypto;
            }
    
            // Native crypto in web worker (Browser)
            if (typeof self !== 'undefined' && self.crypto) {
                crypto = self.crypto;
            }
    
            // Native crypto from worker
            if (typeof globalThis !== 'undefined' && globalThis.crypto) {
                crypto = globalThis.crypto;
            }
    
            // Native (experimental IE 11) crypto from window (Browser)
            if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
                crypto = window.msCrypto;
            }
    
            // Native crypto from global (NodeJS)
            if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
                crypto = __webpack_require__.g.crypto;
            }
    
            // Native crypto import via require (NodeJS)
            if (!crypto && "function" === 'function') {
                try {
                    crypto = __webpack_require__(/*! crypto */ "?9157");
                } catch (err) {}
            }
    
            /*
             * Cryptographically secure pseudorandom number generator
             *
             * As Math.random() is cryptographically not safe to use
             */
            var cryptoSecureRandomInt = function () {
                if (crypto) {
                    // Use getRandomValues method (Browser)
                    if (typeof crypto.getRandomValues === 'function') {
                        try {
                            return crypto.getRandomValues(new Uint32Array(1))[0];
                        } catch (err) {}
                    }
    
                    // Use randomBytes method (NodeJS)
                    if (typeof crypto.randomBytes === 'function') {
                        try {
                            return crypto.randomBytes(4).readInt32LE();
                        } catch (err) {}
                    }
                }
    
                throw new Error('Native crypto module could not be used to get secure random number.');
            };
    
            /*
             * Local polyfill of Object.create
    
             */
            var create = Object.create || (function () {
                function F() {}
    
                return function (obj) {
                    var subtype;
    
                    F.prototype = obj;
    
                    subtype = new F();
    
                    F.prototype = null;
    
                    return subtype;
                };
            }());
    
            /**
             * CryptoJS namespace.
             */
            var C = {};
    
            /**
             * Library namespace.
             */
            var C_lib = C.lib = {};
    
            /**
             * Base object for prototypal inheritance.
             */
            var Base = C_lib.Base = (function () {
    
    
                return {
                    /**
                     * Creates a new object that inherits from this object.
                     *
                     * @param {Object} overrides Properties to copy into the new object.
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         field: 'value',
                     *
                     *         method: function () {
                     *         }
                     *     });
                     */
                    extend: function (overrides) {
                        // Spawn
                        var subtype = create(this);
    
                        // Augment
                        if (overrides) {
                            subtype.mixIn(overrides);
                        }
    
                        // Create default initializer
                        if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                            subtype.init = function () {
                                subtype.$super.init.apply(this, arguments);
                            };
                        }
    
                        // Initializer's prototype is the subtype object
                        subtype.init.prototype = subtype;
    
                        // Reference supertype
                        subtype.$super = this;
    
                        return subtype;
                    },
    
                    /**
                     * Extends this object and runs the init method.
                     * Arguments to create() will be passed to init().
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var instance = MyType.create();
                     */
                    create: function () {
                        var instance = this.extend();
                        instance.init.apply(instance, arguments);
    
                        return instance;
                    },
    
                    /**
                     * Initializes a newly created object.
                     * Override this method to add some logic when your objects are created.
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         init: function () {
                     *             // ...
                     *         }
                     *     });
                     */
                    init: function () {
                    },
    
                    /**
                     * Copies properties into this object.
                     *
                     * @param {Object} properties The properties to mix in.
                     *
                     * @example
                     *
                     *     MyType.mixIn({
                     *         field: 'value'
                     *     });
                     */
                    mixIn: function (properties) {
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                                this[propertyName] = properties[propertyName];
                            }
                        }
    
                        // IE won't copy toString using the loop above
                        if (properties.hasOwnProperty('toString')) {
                            this.toString = properties.toString;
                        }
                    },
    
                    /**
                     * Creates a copy of this object.
                     *
                     * @return {Object} The clone.
                     *
                     * @example
                     *
                     *     var clone = instance.clone();
                     */
                    clone: function () {
                        return this.init.prototype.extend(this);
                    }
                };
            }());
    
            /**
             * An array of 32-bit words.
             *
             * @property {Array} words The array of 32-bit words.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var WordArray = C_lib.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of 32-bit words.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.create();
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                 */
                init: function (words, sigBytes) {
                    words = this.words = words || [];
    
                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 4;
                    }
                },
    
                /**
                 * Converts this word array to a string.
                 *
                 * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                 *
                 * @return {string} The stringified word array.
                 *
                 * @example
                 *
                 *     var string = wordArray + '';
                 *     var string = wordArray.toString();
                 *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                 */
                toString: function (encoder) {
                    return (encoder || Hex).stringify(this);
                },
    
                /**
                 * Concatenates a word array to this word array.
                 *
                 * @param {WordArray} wordArray The word array to append.
                 *
                 * @return {WordArray} This word array.
                 *
                 * @example
                 *
                 *     wordArray1.concat(wordArray2);
                 */
                concat: function (wordArray) {
                    // Shortcuts
                    var thisWords = this.words;
                    var thatWords = wordArray.words;
                    var thisSigBytes = this.sigBytes;
                    var thatSigBytes = wordArray.sigBytes;
    
                    // Clamp excess bits
                    this.clamp();
    
                    // Concat
                    if (thisSigBytes % 4) {
                        // Copy one byte at a time
                        for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                            thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                        }
                    } else {
                        // Copy one word at a time
                        for (var j = 0; j < thatSigBytes; j += 4) {
                            thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
                        }
                    }
                    this.sigBytes += thatSigBytes;
    
                    // Chainable
                    return this;
                },
    
                /**
                 * Removes insignificant bits.
                 *
                 * @example
                 *
                 *     wordArray.clamp();
                 */
                clamp: function () {
                    // Shortcuts
                    var words = this.words;
                    var sigBytes = this.sigBytes;
    
                    // Clamp
                    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                    words.length = Math.ceil(sigBytes / 4);
                },
    
                /**
                 * Creates a copy of this word array.
                 *
                 * @return {WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = wordArray.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone.words = this.words.slice(0);
    
                    return clone;
                },
    
                /**
                 * Creates a word array filled with random bytes.
                 *
                 * @param {number} nBytes The number of random bytes to generate.
                 *
                 * @return {WordArray} The random word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.random(16);
                 */
                random: function (nBytes) {
                    var words = [];
    
                    for (var i = 0; i < nBytes; i += 4) {
                        words.push(cryptoSecureRandomInt());
                    }
    
                    return new WordArray.init(words, nBytes);
                }
            });
    
            /**
             * Encoder namespace.
             */
            var C_enc = C.enc = {};
    
            /**
             * Hex encoding strategy.
             */
            var Hex = C_enc.Hex = {
                /**
                 * Converts a word array to a hex string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The hex string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
    
                    // Convert
                    var hexChars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                        hexChars.push((bite >>> 4).toString(16));
                        hexChars.push((bite & 0x0f).toString(16));
                    }
    
                    return hexChars.join('');
                },
    
                /**
                 * Converts a hex string to a word array.
                 *
                 * @param {string} hexStr The hex string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                 */
                parse: function (hexStr) {
                    // Shortcut
                    var hexStrLength = hexStr.length;
    
                    // Convert
                    var words = [];
                    for (var i = 0; i < hexStrLength; i += 2) {
                        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                    }
    
                    return new WordArray.init(words, hexStrLength / 2);
                }
            };
    
            /**
             * Latin1 encoding strategy.
             */
            var Latin1 = C_enc.Latin1 = {
                /**
                 * Converts a word array to a Latin1 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Latin1 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
    
                    // Convert
                    var latin1Chars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                        latin1Chars.push(String.fromCharCode(bite));
                    }
    
                    return latin1Chars.join('');
                },
    
                /**
                 * Converts a Latin1 string to a word array.
                 *
                 * @param {string} latin1Str The Latin1 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                 */
                parse: function (latin1Str) {
                    // Shortcut
                    var latin1StrLength = latin1Str.length;
    
                    // Convert
                    var words = [];
                    for (var i = 0; i < latin1StrLength; i++) {
                        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                    }
    
                    return new WordArray.init(words, latin1StrLength);
                }
            };
    
            /**
             * UTF-8 encoding strategy.
             */
            var Utf8 = C_enc.Utf8 = {
                /**
                 * Converts a word array to a UTF-8 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-8 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    try {
                        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                    } catch (e) {
                        throw new Error('Malformed UTF-8 data');
                    }
                },
    
                /**
                 * Converts a UTF-8 string to a word array.
                 *
                 * @param {string} utf8Str The UTF-8 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                 */
                parse: function (utf8Str) {
                    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
            };
    
            /**
             * Abstract buffered block algorithm template.
             *
             * The property blockSize must be implemented in a concrete subtype.
             *
             * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
             */
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                /**
                 * Resets this block algorithm's data buffer to its initial state.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm.reset();
                 */
                reset: function () {
                    // Initial values
                    this._data = new WordArray.init();
                    this._nDataBytes = 0;
                },
    
                /**
                 * Adds new data to this block algorithm's buffer.
                 *
                 * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm._append('data');
                 *     bufferedBlockAlgorithm._append(wordArray);
                 */
                _append: function (data) {
                    // Convert string to WordArray, else assume WordArray already
                    if (typeof data == 'string') {
                        data = Utf8.parse(data);
                    }
    
                    // Append
                    this._data.concat(data);
                    this._nDataBytes += data.sigBytes;
                },
    
                /**
                 * Processes available data blocks.
                 *
                 * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                 *
                 * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                 *
                 * @return {WordArray} The processed data.
                 *
                 * @example
                 *
                 *     var processedData = bufferedBlockAlgorithm._process();
                 *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                 */
                _process: function (doFlush) {
                    var processedWords;
    
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
                    var dataSigBytes = data.sigBytes;
                    var blockSize = this.blockSize;
                    var blockSizeBytes = blockSize * 4;
    
                    // Count blocks ready
                    var nBlocksReady = dataSigBytes / blockSizeBytes;
                    if (doFlush) {
                        // Round up to include partial blocks
                        nBlocksReady = Math.ceil(nBlocksReady);
                    } else {
                        // Round down to include only full blocks,
                        // less the number of blocks that must remain in the buffer
                        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                    }
    
                    // Count words ready
                    var nWordsReady = nBlocksReady * blockSize;
    
                    // Count bytes ready
                    var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
    
                    // Process blocks
                    if (nWordsReady) {
                        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            // Perform concrete-algorithm logic
                            this._doProcessBlock(dataWords, offset);
                        }
    
                        // Remove processed words
                        processedWords = dataWords.splice(0, nWordsReady);
                        data.sigBytes -= nBytesReady;
                    }
    
                    // Return processed words
                    return new WordArray.init(processedWords, nBytesReady);
                },
    
                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = bufferedBlockAlgorithm.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone._data = this._data.clone();
    
                    return clone;
                },
    
                _minBufferSize: 0
            });
    
            /**
             * Abstract hasher template.
             *
             * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
             */
            var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 */
                cfg: Base.extend(),
    
                /**
                 * Initializes a newly created hasher.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                 *
                 * @example
                 *
                 *     var hasher = CryptoJS.algo.SHA256.create();
                 */
                init: function (cfg) {
                    // Apply config defaults
                    this.cfg = this.cfg.extend(cfg);
    
                    // Set initial values
                    this.reset();
                },
    
                /**
                 * Resets this hasher to its initial state.
                 *
                 * @example
                 *
                 *     hasher.reset();
                 */
                reset: function () {
                    // Reset data buffer
                    BufferedBlockAlgorithm.reset.call(this);
    
                    // Perform concrete-hasher logic
                    this._doReset();
                },
    
                /**
                 * Updates this hasher with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {Hasher} This hasher.
                 *
                 * @example
                 *
                 *     hasher.update('message');
                 *     hasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    // Append
                    this._append(messageUpdate);
    
                    // Update the hash
                    this._process();
    
                    // Chainable
                    return this;
                },
    
                /**
                 * Finalizes the hash computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The hash.
                 *
                 * @example
                 *
                 *     var hash = hasher.finalize();
                 *     var hash = hasher.finalize('message');
                 *     var hash = hasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Final message update
                    if (messageUpdate) {
                        this._append(messageUpdate);
                    }
    
                    // Perform concrete-hasher logic
                    var hash = this._doFinalize();
    
                    return hash;
                },
    
                blockSize: 512/32,
    
                /**
                 * Creates a shortcut function to a hasher's object interface.
                 *
                 * @param {Hasher} hasher The hasher to create a helper for.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                 */
                _createHelper: function (hasher) {
                    return function (message, cfg) {
                        return new hasher.init(cfg).finalize(message);
                    };
                },
    
                /**
                 * Creates a shortcut function to the HMAC's object interface.
                 *
                 * @param {Hasher} hasher The hasher to use in this HMAC helper.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                 */
                _createHmacHelper: function (hasher) {
                    return function (message, key) {
                        return new C_algo.HMAC.init(hasher, key).finalize(message);
                    };
                }
            });
    
            /**
             * Algorithm namespace.
             */
            var C_algo = C.algo = {};
    
            return C;
        }(Math));
    
    
        return CryptoJS;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/enc-base64.js":
    /*!**********************************************!*\
      !*** ./node_modules/crypto-js/enc-base64.js ***!
      \**********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;
    
            /**
             * Base64 encoding strategy.
             */
            var Base64 = C_enc.Base64 = {
                /**
                 * Converts a word array to a Base64 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Base64 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var map = this._map;
    
                    // Clamp excess bits
                    wordArray.clamp();
    
                    // Convert
                    var base64Chars = [];
                    for (var i = 0; i < sigBytes; i += 3) {
                        var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                        var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                        var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
    
                        var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
    
                        for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                            base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                        }
                    }
    
                    // Add padding
                    var paddingChar = map.charAt(64);
                    if (paddingChar) {
                        while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                        }
                    }
    
                    return base64Chars.join('');
                },
    
                /**
                 * Converts a Base64 string to a word array.
                 *
                 * @param {string} base64Str The Base64 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                 */
                parse: function (base64Str) {
                    // Shortcuts
                    var base64StrLength = base64Str.length;
                    var map = this._map;
                    var reverseMap = this._reverseMap;
    
                    if (!reverseMap) {
                            reverseMap = this._reverseMap = [];
                            for (var j = 0; j < map.length; j++) {
                                reverseMap[map.charCodeAt(j)] = j;
                            }
                    }
    
                    // Ignore padding
                    var paddingChar = map.charAt(64);
                    if (paddingChar) {
                        var paddingIndex = base64Str.indexOf(paddingChar);
                        if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                        }
                    }
    
                    // Convert
                    return parseLoop(base64Str, base64StrLength, reverseMap);
    
                },
    
                _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
            };
    
            function parseLoop(base64Str, base64StrLength, reverseMap) {
              var words = [];
              var nBytes = 0;
              for (var i = 0; i < base64StrLength; i++) {
                  if (i % 4) {
                      var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
                      var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
                      var bitsCombined = bits1 | bits2;
                      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
                      nBytes++;
                  }
              }
              return WordArray.create(words, nBytes);
            }
        }());
    
    
        return CryptoJS.enc.Base64;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/enc-base64url.js":
    /*!*************************************************!*\
      !*** ./node_modules/crypto-js/enc-base64url.js ***!
      \*************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;
    
            /**
             * Base64url encoding strategy.
             */
            var Base64url = C_enc.Base64url = {
                /**
                 * Converts a word array to a Base64url string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @param {boolean} urlSafe Whether to use url safe
                 *
                 * @return {string} The Base64url string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
                 */
                stringify: function (wordArray, urlSafe) {
                    if (urlSafe === undefined) {
                        urlSafe = true
                    }
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
                    var map = urlSafe ? this._safe_map : this._map;
    
                    // Clamp excess bits
                    wordArray.clamp();
    
                    // Convert
                    var base64Chars = [];
                    for (var i = 0; i < sigBytes; i += 3) {
                        var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                        var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                        var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
    
                        var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
    
                        for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                            base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                        }
                    }
    
                    // Add padding
                    var paddingChar = map.charAt(64);
                    if (paddingChar) {
                        while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                        }
                    }
    
                    return base64Chars.join('');
                },
    
                /**
                 * Converts a Base64url string to a word array.
                 *
                 * @param {string} base64Str The Base64url string.
                 *
                 * @param {boolean} urlSafe Whether to use url safe
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
                 */
                parse: function (base64Str, urlSafe) {
                    if (urlSafe === undefined) {
                        urlSafe = true
                    }
    
                    // Shortcuts
                    var base64StrLength = base64Str.length;
                    var map = urlSafe ? this._safe_map : this._map;
                    var reverseMap = this._reverseMap;
    
                    if (!reverseMap) {
                        reverseMap = this._reverseMap = [];
                        for (var j = 0; j < map.length; j++) {
                            reverseMap[map.charCodeAt(j)] = j;
                        }
                    }
    
                    // Ignore padding
                    var paddingChar = map.charAt(64);
                    if (paddingChar) {
                        var paddingIndex = base64Str.indexOf(paddingChar);
                        if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                        }
                    }
    
                    // Convert
                    return parseLoop(base64Str, base64StrLength, reverseMap);
    
                },
    
                _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
                _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
            };
    
            function parseLoop(base64Str, base64StrLength, reverseMap) {
                var words = [];
                var nBytes = 0;
                for (var i = 0; i < base64StrLength; i++) {
                    if (i % 4) {
                        var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
                        var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
                        var bitsCombined = bits1 | bits2;
                        words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
                        nBytes++;
                    }
                }
                return WordArray.create(words, nBytes);
            }
        }());
    
    
        return CryptoJS.enc.Base64url;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/enc-utf16.js":
    /*!*********************************************!*\
      !*** ./node_modules/crypto-js/enc-utf16.js ***!
      \*********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;
    
            /**
             * UTF-16 BE encoding strategy.
             */
            var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
                /**
                 * Converts a word array to a UTF-16 BE string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-16 BE string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
    
                    // Convert
                    var utf16Chars = [];
                    for (var i = 0; i < sigBytes; i += 2) {
                        var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
                        utf16Chars.push(String.fromCharCode(codePoint));
                    }
    
                    return utf16Chars.join('');
                },
    
                /**
                 * Converts a UTF-16 BE string to a word array.
                 *
                 * @param {string} utf16Str The UTF-16 BE string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
                 */
                parse: function (utf16Str) {
                    // Shortcut
                    var utf16StrLength = utf16Str.length;
    
                    // Convert
                    var words = [];
                    for (var i = 0; i < utf16StrLength; i++) {
                        words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
                    }
    
                    return WordArray.create(words, utf16StrLength * 2);
                }
            };
    
            /**
             * UTF-16 LE encoding strategy.
             */
            C_enc.Utf16LE = {
                /**
                 * Converts a word array to a UTF-16 LE string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-16 LE string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
    
                    // Convert
                    var utf16Chars = [];
                    for (var i = 0; i < sigBytes; i += 2) {
                        var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
                        utf16Chars.push(String.fromCharCode(codePoint));
                    }
    
                    return utf16Chars.join('');
                },
    
                /**
                 * Converts a UTF-16 LE string to a word array.
                 *
                 * @param {string} utf16Str The UTF-16 LE string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
                 */
                parse: function (utf16Str) {
                    // Shortcut
                    var utf16StrLength = utf16Str.length;
    
                    // Convert
                    var words = [];
                    for (var i = 0; i < utf16StrLength; i++) {
                        words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
                    }
    
                    return WordArray.create(words, utf16StrLength * 2);
                }
            };
    
            function swapEndian(word) {
                return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
            }
        }());
    
    
        return CryptoJS.enc.Utf16;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/evpkdf.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/evpkdf.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var MD5 = C_algo.MD5;
    
            /**
             * This key derivation function is meant to conform with EVP_BytesToKey.
             * www.openssl.org/docs/crypto/EVP_BytesToKey.html
             */
            var EvpKDF = C_algo.EvpKDF = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                 * @property {number} iterations The number of iterations to perform. Default: 1
                 */
                cfg: Base.extend({
                    keySize: 128/32,
                    hasher: MD5,
                    iterations: 1
                }),
    
                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.EvpKDF.create();
                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                 */
                init: function (cfg) {
                    this.cfg = this.cfg.extend(cfg);
                },
    
                /**
                 * Derives a key from a password.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function (password, salt) {
                    var block;
    
                    // Shortcut
                    var cfg = this.cfg;
    
                    // Init hasher
                    var hasher = cfg.hasher.create();
    
                    // Initial values
                    var derivedKey = WordArray.create();
    
                    // Shortcuts
                    var derivedKeyWords = derivedKey.words;
                    var keySize = cfg.keySize;
                    var iterations = cfg.iterations;
    
                    // Generate key
                    while (derivedKeyWords.length < keySize) {
                        if (block) {
                            hasher.update(block);
                        }
                        block = hasher.update(password).finalize(salt);
                        hasher.reset();
    
                        // Iterations
                        for (var i = 1; i < iterations; i++) {
                            block = hasher.finalize(block);
                            hasher.reset();
                        }
    
                        derivedKey.concat(block);
                    }
                    derivedKey.sigBytes = keySize * 4;
    
                    return derivedKey;
                }
            });
    
            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             * @param {Object} cfg (Optional) The configuration options to use for this computation.
             *
             * @return {WordArray} The derived key.
             *
             * @static
             *
             * @example
             *
             *     var key = CryptoJS.EvpKDF(password, salt);
             *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
             *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
             */
            C.EvpKDF = function (password, salt, cfg) {
                return EvpKDF.create(cfg).compute(password, salt);
            };
        }());
    
    
        return CryptoJS.EvpKDF;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/format-hex.js":
    /*!**********************************************!*\
      !*** ./node_modules/crypto-js/format-hex.js ***!
      \**********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function (undefined) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var CipherParams = C_lib.CipherParams;
            var C_enc = C.enc;
            var Hex = C_enc.Hex;
            var C_format = C.format;
    
            var HexFormatter = C_format.Hex = {
                /**
                 * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
                 *
                 * @param {CipherParams} cipherParams The cipher params object.
                 *
                 * @return {string} The hexadecimally encoded string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
                 */
                stringify: function (cipherParams) {
                    return cipherParams.ciphertext.toString(Hex);
                },
    
                /**
                 * Converts a hexadecimally encoded ciphertext string to a cipher params object.
                 *
                 * @param {string} input The hexadecimally encoded string.
                 *
                 * @return {CipherParams} The cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
                 */
                parse: function (input) {
                    var ciphertext = Hex.parse(input);
                    return CipherParams.create({ ciphertext: ciphertext });
                }
            };
        }());
    
    
        return CryptoJS.format.Hex;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/hmac.js":
    /*!****************************************!*\
      !*** ./node_modules/crypto-js/hmac.js ***!
      \****************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var C_algo = C.algo;
    
            /**
             * HMAC algorithm.
             */
            var HMAC = C_algo.HMAC = Base.extend({
                /**
                 * Initializes a newly created HMAC.
                 *
                 * @param {Hasher} hasher The hash algorithm to use.
                 * @param {WordArray|string} key The secret key.
                 *
                 * @example
                 *
                 *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                 */
                init: function (hasher, key) {
                    // Init hasher
                    hasher = this._hasher = new hasher.init();
    
                    // Convert string to WordArray, else assume WordArray already
                    if (typeof key == 'string') {
                        key = Utf8.parse(key);
                    }
    
                    // Shortcuts
                    var hasherBlockSize = hasher.blockSize;
                    var hasherBlockSizeBytes = hasherBlockSize * 4;
    
                    // Allow arbitrary length keys
                    if (key.sigBytes > hasherBlockSizeBytes) {
                        key = hasher.finalize(key);
                    }
    
                    // Clamp excess bits
                    key.clamp();
    
                    // Clone key for inner and outer pads
                    var oKey = this._oKey = key.clone();
                    var iKey = this._iKey = key.clone();
    
                    // Shortcuts
                    var oKeyWords = oKey.words;
                    var iKeyWords = iKey.words;
    
                    // XOR keys with pad constants
                    for (var i = 0; i < hasherBlockSize; i++) {
                        oKeyWords[i] ^= 0x5c5c5c5c;
                        iKeyWords[i] ^= 0x36363636;
                    }
                    oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
    
                    // Set initial values
                    this.reset();
                },
    
                /**
                 * Resets this HMAC to its initial state.
                 *
                 * @example
                 *
                 *     hmacHasher.reset();
                 */
                reset: function () {
                    // Shortcut
                    var hasher = this._hasher;
    
                    // Reset
                    hasher.reset();
                    hasher.update(this._iKey);
                },
    
                /**
                 * Updates this HMAC with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {HMAC} This HMAC instance.
                 *
                 * @example
                 *
                 *     hmacHasher.update('message');
                 *     hmacHasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    this._hasher.update(messageUpdate);
    
                    // Chainable
                    return this;
                },
    
                /**
                 * Finalizes the HMAC computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The HMAC.
                 *
                 * @example
                 *
                 *     var hmac = hmacHasher.finalize();
                 *     var hmac = hmacHasher.finalize('message');
                 *     var hmac = hmacHasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Shortcut
                    var hasher = this._hasher;
    
                    // Compute HMAC
                    var innerHash = hasher.finalize(messageUpdate);
                    hasher.reset();
                    var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
    
                    return hmac;
                }
            });
        }());
    
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/index.js":
    /*!*****************************************!*\
      !*** ./node_modules/crypto-js/index.js ***!
      \*****************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./lib-typedarrays */ "./node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__(/*! ./enc-utf16 */ "./node_modules/crypto-js/enc-utf16.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./enc-base64url */ "./node_modules/crypto-js/enc-base64url.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"), __webpack_require__(/*! ./sha224 */ "./node_modules/crypto-js/sha224.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"), __webpack_require__(/*! ./sha384 */ "./node_modules/crypto-js/sha384.js"), __webpack_require__(/*! ./sha3 */ "./node_modules/crypto-js/sha3.js"), __webpack_require__(/*! ./ripemd160 */ "./node_modules/crypto-js/ripemd160.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"), __webpack_require__(/*! ./pbkdf2 */ "./node_modules/crypto-js/pbkdf2.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"), __webpack_require__(/*! ./mode-cfb */ "./node_modules/crypto-js/mode-cfb.js"), __webpack_require__(/*! ./mode-ctr */ "./node_modules/crypto-js/mode-ctr.js"), __webpack_require__(/*! ./mode-ctr-gladman */ "./node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__(/*! ./mode-ofb */ "./node_modules/crypto-js/mode-ofb.js"), __webpack_require__(/*! ./mode-ecb */ "./node_modules/crypto-js/mode-ecb.js"), __webpack_require__(/*! ./pad-ansix923 */ "./node_modules/crypto-js/pad-ansix923.js"), __webpack_require__(/*! ./pad-iso10126 */ "./node_modules/crypto-js/pad-iso10126.js"), __webpack_require__(/*! ./pad-iso97971 */ "./node_modules/crypto-js/pad-iso97971.js"), __webpack_require__(/*! ./pad-zeropadding */ "./node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__(/*! ./pad-nopadding */ "./node_modules/crypto-js/pad-nopadding.js"), __webpack_require__(/*! ./format-hex */ "./node_modules/crypto-js/format-hex.js"), __webpack_require__(/*! ./aes */ "./node_modules/crypto-js/aes.js"), __webpack_require__(/*! ./tripledes */ "./node_modules/crypto-js/tripledes.js"), __webpack_require__(/*! ./rc4 */ "./node_modules/crypto-js/rc4.js"), __webpack_require__(/*! ./rabbit */ "./node_modules/crypto-js/rabbit.js"), __webpack_require__(/*! ./rabbit-legacy */ "./node_modules/crypto-js/rabbit-legacy.js"), __webpack_require__(/*! ./blowfish */ "./node_modules/crypto-js/blowfish.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        return CryptoJS;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/lib-typedarrays.js":
    /*!***************************************************!*\
      !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
      \***************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Check if typed arrays are supported
            if (typeof ArrayBuffer != 'function') {
                return;
            }
    
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
    
            // Reference original init
            var superInit = WordArray.init;
    
            // Augment WordArray.init to handle typed arrays
            var subInit = WordArray.init = function (typedArray) {
                // Convert buffers to uint8
                if (typedArray instanceof ArrayBuffer) {
                    typedArray = new Uint8Array(typedArray);
                }
    
                // Convert other array views to uint8
                if (
                    typedArray instanceof Int8Array ||
                    (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
                    typedArray instanceof Int16Array ||
                    typedArray instanceof Uint16Array ||
                    typedArray instanceof Int32Array ||
                    typedArray instanceof Uint32Array ||
                    typedArray instanceof Float32Array ||
                    typedArray instanceof Float64Array
                ) {
                    typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                }
    
                // Handle Uint8Array
                if (typedArray instanceof Uint8Array) {
                    // Shortcut
                    var typedArrayByteLength = typedArray.byteLength;
    
                    // Extract bytes
                    var words = [];
                    for (var i = 0; i < typedArrayByteLength; i++) {
                        words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
                    }
    
                    // Initialize this word array
                    superInit.call(this, words, typedArrayByteLength);
                } else {
                    // Else call normal init
                    superInit.apply(this, arguments);
                }
            };
    
            subInit.prototype = WordArray;
        }());
    
    
        return CryptoJS.lib.WordArray;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/md5.js":
    /*!***************************************!*\
      !*** ./node_modules/crypto-js/md5.js ***!
      \***************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
    
            // Constants table
            var T = [];
    
            // Compute constants
            (function () {
                for (var i = 0; i < 64; i++) {
                    T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
                }
            }());
    
            /**
             * MD5 hash algorithm.
             */
            var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([
                        0x67452301, 0xefcdab89,
                        0x98badcfe, 0x10325476
                    ]);
                },
    
                _doProcessBlock: function (M, offset) {
                    // Swap endian
                    for (var i = 0; i < 16; i++) {
                        // Shortcuts
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
    
                        M[offset_i] = (
                            (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                            (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                        );
                    }
    
                    // Shortcuts
                    var H = this._hash.words;
    
                    var M_offset_0  = M[offset + 0];
                    var M_offset_1  = M[offset + 1];
                    var M_offset_2  = M[offset + 2];
                    var M_offset_3  = M[offset + 3];
                    var M_offset_4  = M[offset + 4];
                    var M_offset_5  = M[offset + 5];
                    var M_offset_6  = M[offset + 6];
                    var M_offset_7  = M[offset + 7];
                    var M_offset_8  = M[offset + 8];
                    var M_offset_9  = M[offset + 9];
                    var M_offset_10 = M[offset + 10];
                    var M_offset_11 = M[offset + 11];
                    var M_offset_12 = M[offset + 12];
                    var M_offset_13 = M[offset + 13];
                    var M_offset_14 = M[offset + 14];
                    var M_offset_15 = M[offset + 15];
    
                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
    
                    // Computation
                    a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
                    d = FF(d, a, b, c, M_offset_1,  12, T[1]);
                    c = FF(c, d, a, b, M_offset_2,  17, T[2]);
                    b = FF(b, c, d, a, M_offset_3,  22, T[3]);
                    a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
                    d = FF(d, a, b, c, M_offset_5,  12, T[5]);
                    c = FF(c, d, a, b, M_offset_6,  17, T[6]);
                    b = FF(b, c, d, a, M_offset_7,  22, T[7]);
                    a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
                    d = FF(d, a, b, c, M_offset_9,  12, T[9]);
                    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                    a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
                    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                    b = FF(b, c, d, a, M_offset_15, 22, T[15]);
    
                    a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
                    d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
                    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                    b = GG(b, c, d, a, M_offset_0,  20, T[19]);
                    a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
                    d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
                    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                    b = GG(b, c, d, a, M_offset_4,  20, T[23]);
                    a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
                    d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
                    c = GG(c, d, a, b, M_offset_3,  14, T[26]);
                    b = GG(b, c, d, a, M_offset_8,  20, T[27]);
                    a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
                    d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
                    c = GG(c, d, a, b, M_offset_7,  14, T[30]);
                    b = GG(b, c, d, a, M_offset_12, 20, T[31]);
    
                    a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
                    d = HH(d, a, b, c, M_offset_8,  11, T[33]);
                    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                    a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
                    d = HH(d, a, b, c, M_offset_4,  11, T[37]);
                    c = HH(c, d, a, b, M_offset_7,  16, T[38]);
                    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                    a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
                    d = HH(d, a, b, c, M_offset_0,  11, T[41]);
                    c = HH(c, d, a, b, M_offset_3,  16, T[42]);
                    b = HH(b, c, d, a, M_offset_6,  23, T[43]);
                    a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
                    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                    b = HH(b, c, d, a, M_offset_2,  23, T[47]);
    
                    a = II(a, b, c, d, M_offset_0,  6,  T[48]);
                    d = II(d, a, b, c, M_offset_7,  10, T[49]);
                    c = II(c, d, a, b, M_offset_14, 15, T[50]);
                    b = II(b, c, d, a, M_offset_5,  21, T[51]);
                    a = II(a, b, c, d, M_offset_12, 6,  T[52]);
                    d = II(d, a, b, c, M_offset_3,  10, T[53]);
                    c = II(c, d, a, b, M_offset_10, 15, T[54]);
                    b = II(b, c, d, a, M_offset_1,  21, T[55]);
                    a = II(a, b, c, d, M_offset_8,  6,  T[56]);
                    d = II(d, a, b, c, M_offset_15, 10, T[57]);
                    c = II(c, d, a, b, M_offset_6,  15, T[58]);
                    b = II(b, c, d, a, M_offset_13, 21, T[59]);
                    a = II(a, b, c, d, M_offset_4,  6,  T[60]);
                    d = II(d, a, b, c, M_offset_11, 10, T[61]);
                    c = II(c, d, a, b, M_offset_2,  15, T[62]);
                    b = II(b, c, d, a, M_offset_9,  21, T[63]);
    
                    // Intermediate hash value
                    H[0] = (H[0] + a) | 0;
                    H[1] = (H[1] + b) | 0;
                    H[2] = (H[2] + c) | 0;
                    H[3] = (H[3] + d) | 0;
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
    
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
    
                    var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                    var nBitsTotalL = nBitsTotal;
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                        (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                        (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
                    );
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                        (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                        (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
                    );
    
                    data.sigBytes = (dataWords.length + 1) * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Shortcuts
                    var hash = this._hash;
                    var H = hash.words;
    
                    // Swap endian
                    for (var i = 0; i < 4; i++) {
                        // Shortcut
                        var H_i = H[i];
    
                        H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                               (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
                    }
    
                    // Return final computed hash
                    return hash;
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
    
                    return clone;
                }
            });
    
            function FF(a, b, c, d, x, s, t) {
                var n = a + ((b & c) | (~b & d)) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            function GG(a, b, c, d, x, s, t) {
                var n = a + ((b & d) | (c & ~d)) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            function HH(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            function II(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.MD5('message');
             *     var hash = CryptoJS.MD5(wordArray);
             */
            C.MD5 = Hasher._createHelper(MD5);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacMD5(message, key);
             */
            C.HmacMD5 = Hasher._createHmacHelper(MD5);
        }(Math));
    
    
        return CryptoJS.MD5;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/mode-cfb.js":
    /*!********************************************!*\
      !*** ./node_modules/crypto-js/mode-cfb.js ***!
      \********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * Cipher Feedback block mode.
         */
        CryptoJS.mode.CFB = (function () {
            var CFB = CryptoJS.lib.BlockCipherMode.extend();
    
            CFB.Encryptor = CFB.extend({
                processBlock: function (words, offset) {
                    // Shortcuts
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
    
                    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
    
                    // Remember this block to use with next block
                    this._prevBlock = words.slice(offset, offset + blockSize);
                }
            });
    
            CFB.Decryptor = CFB.extend({
                processBlock: function (words, offset) {
                    // Shortcuts
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
    
                    // Remember this block to use with next block
                    var thisBlock = words.slice(offset, offset + blockSize);
    
                    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
    
                    // This block becomes the previous block
                    this._prevBlock = thisBlock;
                }
            });
    
            function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                var keystream;
    
                // Shortcut
                var iv = this._iv;
    
                // Generate keystream
                if (iv) {
                    keystream = iv.slice(0);
    
                    // Remove IV for subsequent blocks
                    this._iv = undefined;
                } else {
                    keystream = this._prevBlock;
                }
                cipher.encryptBlock(keystream, 0);
    
                // Encrypt
                for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= keystream[i];
                }
            }
    
            return CFB;
        }());
    
    
        return CryptoJS.mode.CFB;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/mode-ctr-gladman.js":
    /*!****************************************************!*\
      !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
      \****************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /** @preserve
         * Counter block mode compatible with  Dr Brian Gladman fileenc.c
         * derived from CryptoJS.mode.CTR
         * Jan Hruby jhruby.web@gmail.com
         */
        CryptoJS.mode.CTRGladman = (function () {
            var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
    
            function incWord(word)
            {
                if (((word >> 24) & 0xff) === 0xff) { //overflow
                var b1 = (word >> 16)&0xff;
                var b2 = (word >> 8)&0xff;
                var b3 = word & 0xff;
    
                if (b1 === 0xff) // overflow b1
                {
                b1 = 0;
                if (b2 === 0xff)
                {
                    b2 = 0;
                    if (b3 === 0xff)
                    {
                        b3 = 0;
                    }
                    else
                    {
                        ++b3;
                    }
                }
                else
                {
                    ++b2;
                }
                }
                else
                {
                ++b1;
                }
    
                word = 0;
                word += (b1 << 16);
                word += (b2 << 8);
                word += b3;
                }
                else
                {
                word += (0x01 << 24);
                }
                return word;
            }
    
            function incCounter(counter)
            {
                if ((counter[0] = incWord(counter[0])) === 0)
                {
                    // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
                    counter[1] = incWord(counter[1]);
                }
                return counter;
            }
    
            var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                processBlock: function (words, offset) {
                    // Shortcuts
                    var cipher = this._cipher
                    var blockSize = cipher.blockSize;
                    var iv = this._iv;
                    var counter = this._counter;
    
                    // Generate keystream
                    if (iv) {
                        counter = this._counter = iv.slice(0);
    
                        // Remove IV for subsequent blocks
                        this._iv = undefined;
                    }
    
                    incCounter(counter);
    
                    var keystream = counter.slice(0);
                    cipher.encryptBlock(keystream, 0);
    
                    // Encrypt
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }
            });
    
            CTRGladman.Decryptor = Encryptor;
    
            return CTRGladman;
        }());
    
    
    
    
        return CryptoJS.mode.CTRGladman;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/mode-ctr.js":
    /*!********************************************!*\
      !*** ./node_modules/crypto-js/mode-ctr.js ***!
      \********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * Counter block mode.
         */
        CryptoJS.mode.CTR = (function () {
            var CTR = CryptoJS.lib.BlockCipherMode.extend();
    
            var Encryptor = CTR.Encryptor = CTR.extend({
                processBlock: function (words, offset) {
                    // Shortcuts
                    var cipher = this._cipher
                    var blockSize = cipher.blockSize;
                    var iv = this._iv;
                    var counter = this._counter;
    
                    // Generate keystream
                    if (iv) {
                        counter = this._counter = iv.slice(0);
    
                        // Remove IV for subsequent blocks
                        this._iv = undefined;
                    }
                    var keystream = counter.slice(0);
                    cipher.encryptBlock(keystream, 0);
    
                    // Increment counter
                    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0
    
                    // Encrypt
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }
            });
    
            CTR.Decryptor = Encryptor;
    
            return CTR;
        }());
    
    
        return CryptoJS.mode.CTR;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/mode-ecb.js":
    /*!********************************************!*\
      !*** ./node_modules/crypto-js/mode-ecb.js ***!
      \********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * Electronic Codebook block mode.
         */
        CryptoJS.mode.ECB = (function () {
            var ECB = CryptoJS.lib.BlockCipherMode.extend();
    
            ECB.Encryptor = ECB.extend({
                processBlock: function (words, offset) {
                    this._cipher.encryptBlock(words, offset);
                }
            });
    
            ECB.Decryptor = ECB.extend({
                processBlock: function (words, offset) {
                    this._cipher.decryptBlock(words, offset);
                }
            });
    
            return ECB;
        }());
    
    
        return CryptoJS.mode.ECB;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/mode-ofb.js":
    /*!********************************************!*\
      !*** ./node_modules/crypto-js/mode-ofb.js ***!
      \********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * Output Feedback block mode.
         */
        CryptoJS.mode.OFB = (function () {
            var OFB = CryptoJS.lib.BlockCipherMode.extend();
    
            var Encryptor = OFB.Encryptor = OFB.extend({
                processBlock: function (words, offset) {
                    // Shortcuts
                    var cipher = this._cipher
                    var blockSize = cipher.blockSize;
                    var iv = this._iv;
                    var keystream = this._keystream;
    
                    // Generate keystream
                    if (iv) {
                        keystream = this._keystream = iv.slice(0);
    
                        // Remove IV for subsequent blocks
                        this._iv = undefined;
                    }
                    cipher.encryptBlock(keystream, 0);
    
                    // Encrypt
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }
            });
    
            OFB.Decryptor = Encryptor;
    
            return OFB;
        }());
    
    
        return CryptoJS.mode.OFB;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/pad-ansix923.js":
    /*!************************************************!*\
      !*** ./node_modules/crypto-js/pad-ansix923.js ***!
      \************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * ANSI X.923 padding strategy.
         */
        CryptoJS.pad.AnsiX923 = {
            pad: function (data, blockSize) {
                // Shortcuts
                var dataSigBytes = data.sigBytes;
                var blockSizeBytes = blockSize * 4;
    
                // Count padding bytes
                var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
    
                // Compute last byte position
                var lastBytePos = dataSigBytes + nPaddingBytes - 1;
    
                // Pad
                data.clamp();
                data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
                data.sigBytes += nPaddingBytes;
            },
    
            unpad: function (data) {
                // Get number of padding bytes from last byte
                var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
    
                // Remove padding
                data.sigBytes -= nPaddingBytes;
            }
        };
    
    
        return CryptoJS.pad.Ansix923;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/pad-iso10126.js":
    /*!************************************************!*\
      !*** ./node_modules/crypto-js/pad-iso10126.js ***!
      \************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * ISO 10126 padding strategy.
         */
        CryptoJS.pad.Iso10126 = {
            pad: function (data, blockSize) {
                // Shortcut
                var blockSizeBytes = blockSize * 4;
    
                // Count padding bytes
                var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
    
                // Pad
                data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
                     concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
            },
    
            unpad: function (data) {
                // Get number of padding bytes from last byte
                var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
    
                // Remove padding
                data.sigBytes -= nPaddingBytes;
            }
        };
    
    
        return CryptoJS.pad.Iso10126;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/pad-iso97971.js":
    /*!************************************************!*\
      !*** ./node_modules/crypto-js/pad-iso97971.js ***!
      \************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * ISO/IEC 9797-1 Padding Method 2.
         */
        CryptoJS.pad.Iso97971 = {
            pad: function (data, blockSize) {
                // Add 0x80 byte
                data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));
    
                // Zero pad the rest
                CryptoJS.pad.ZeroPadding.pad(data, blockSize);
            },
    
            unpad: function (data) {
                // Remove zero padding
                CryptoJS.pad.ZeroPadding.unpad(data);
    
                // Remove one more byte -- the 0x80 byte
                data.sigBytes--;
            }
        };
    
    
        return CryptoJS.pad.Iso97971;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/pad-nopadding.js":
    /*!*************************************************!*\
      !*** ./node_modules/crypto-js/pad-nopadding.js ***!
      \*************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * A noop padding strategy.
         */
        CryptoJS.pad.NoPadding = {
            pad: function () {
            },
    
            unpad: function () {
            }
        };
    
    
        return CryptoJS.pad.NoPadding;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/pad-zeropadding.js":
    /*!***************************************************!*\
      !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
      \***************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /**
         * Zero padding strategy.
         */
        CryptoJS.pad.ZeroPadding = {
            pad: function (data, blockSize) {
                // Shortcut
                var blockSizeBytes = blockSize * 4;
    
                // Pad
                data.clamp();
                data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
            },
    
            unpad: function (data) {
                // Shortcut
                var dataWords = data.words;
    
                // Unpad
                var i = data.sigBytes - 1;
                for (var i = data.sigBytes - 1; i >= 0; i--) {
                    if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
                        data.sigBytes = i + 1;
                        break;
                    }
                }
            }
        };
    
    
        return CryptoJS.pad.ZeroPadding;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/pbkdf2.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/pbkdf2.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA256 = C_algo.SHA256;
            var HMAC = C_algo.HMAC;
    
            /**
             * Password-Based Key Derivation Function 2 algorithm.
             */
            var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hasher to use. Default: SHA256
                 * @property {number} iterations The number of iterations to perform. Default: 250000
                 */
                cfg: Base.extend({
                    keySize: 128/32,
                    hasher: SHA256,
                    iterations: 250000
                }),
    
                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.PBKDF2.create();
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                 */
                init: function (cfg) {
                    this.cfg = this.cfg.extend(cfg);
                },
    
                /**
                 * Computes the Password-Based Key Derivation Function 2.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function (password, salt) {
                    // Shortcut
                    var cfg = this.cfg;
    
                    // Init HMAC
                    var hmac = HMAC.create(cfg.hasher, password);
    
                    // Initial values
                    var derivedKey = WordArray.create();
                    var blockIndex = WordArray.create([0x00000001]);
    
                    // Shortcuts
                    var derivedKeyWords = derivedKey.words;
                    var blockIndexWords = blockIndex.words;
                    var keySize = cfg.keySize;
                    var iterations = cfg.iterations;
    
                    // Generate key
                    while (derivedKeyWords.length < keySize) {
                        var block = hmac.update(salt).finalize(blockIndex);
                        hmac.reset();
    
                        // Shortcuts
                        var blockWords = block.words;
                        var blockWordsLength = blockWords.length;
    
                        // Iterations
                        var intermediate = block;
                        for (var i = 1; i < iterations; i++) {
                            intermediate = hmac.finalize(intermediate);
                            hmac.reset();
    
                            // Shortcut
                            var intermediateWords = intermediate.words;
    
                            // XOR intermediate with block
                            for (var j = 0; j < blockWordsLength; j++) {
                                blockWords[j] ^= intermediateWords[j];
                            }
                        }
    
                        derivedKey.concat(block);
                        blockIndexWords[0]++;
                    }
                    derivedKey.sigBytes = keySize * 4;
    
                    return derivedKey;
                }
            });
    
            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             * @param {Object} cfg (Optional) The configuration options to use for this computation.
             *
             * @return {WordArray} The derived key.
             *
             * @static
             *
             * @example
             *
             *     var key = CryptoJS.PBKDF2(password, salt);
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
             */
            C.PBKDF2 = function (password, salt, cfg) {
                return PBKDF2.create(cfg).compute(password, salt);
            };
        }());
    
    
        return CryptoJS.PBKDF2;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/rabbit-legacy.js":
    /*!*************************************************!*\
      !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
      \*************************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;
    
            // Reusable objects
            var S  = [];
            var C_ = [];
            var G  = [];
    
            /**
             * Rabbit stream cipher algorithm.
             *
             * This is a legacy version that neglected to convert the key to little-endian.
             * This error doesn't affect the cipher's security,
             * but it does affect its compatibility with other implementations.
             */
            var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                _doReset: function () {
                    // Shortcuts
                    var K = this._key.words;
                    var iv = this.cfg.iv;
    
                    // Generate initial state values
                    var X = this._X = [
                        K[0], (K[3] << 16) | (K[2] >>> 16),
                        K[1], (K[0] << 16) | (K[3] >>> 16),
                        K[2], (K[1] << 16) | (K[0] >>> 16),
                        K[3], (K[2] << 16) | (K[1] >>> 16)
                    ];
    
                    // Generate initial counter values
                    var C = this._C = [
                        (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
                        (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
                        (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
                        (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
                    ];
    
                    // Carry bit
                    this._b = 0;
    
                    // Iterate the system four times
                    for (var i = 0; i < 4; i++) {
                        nextState.call(this);
                    }
    
                    // Modify the counters
                    for (var i = 0; i < 8; i++) {
                        C[i] ^= X[(i + 4) & 7];
                    }
    
                    // IV setup
                    if (iv) {
                        // Shortcuts
                        var IV = iv.words;
                        var IV_0 = IV[0];
                        var IV_1 = IV[1];
    
                        // Generate four subvectors
                        var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
                        var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
                        var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
                        var i3 = (i2 << 16)  | (i0 & 0x0000ffff);
    
                        // Modify counter values
                        C[0] ^= i0;
                        C[1] ^= i1;
                        C[2] ^= i2;
                        C[3] ^= i3;
                        C[4] ^= i0;
                        C[5] ^= i1;
                        C[6] ^= i2;
                        C[7] ^= i3;
    
                        // Iterate the system four times
                        for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                        }
                    }
                },
    
                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var X = this._X;
    
                    // Iterate the system
                    nextState.call(this);
    
                    // Generate four keystream words
                    S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
                    S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
                    S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
                    S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);
    
                    for (var i = 0; i < 4; i++) {
                        // Swap endian
                        S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
                               (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);
    
                        // Encrypt
                        M[offset + i] ^= S[i];
                    }
                },
    
                blockSize: 128/32,
    
                ivSize: 64/32
            });
    
            function nextState() {
                // Shortcuts
                var X = this._X;
                var C = this._C;
    
                // Save old counter values
                for (var i = 0; i < 8; i++) {
                    C_[i] = C[i];
                }
    
                // Calculate new counter values
                C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
                C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
                C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
                C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
                C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
                C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
                C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
                C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
                this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;
    
                // Calculate the g-values
                for (var i = 0; i < 8; i++) {
                    var gx = X[i] + C[i];
    
                    // Construct high and low argument for squaring
                    var ga = gx & 0xffff;
                    var gb = gx >>> 16;
    
                    // Calculate high and low result of squaring
                    var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
                    var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);
    
                    // High XOR low
                    G[i] = gh ^ gl;
                }
    
                // Calculate new state values
                X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
                X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
                X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
                X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
                X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
                X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
                X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
                X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
            }
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
             */
            C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        }());
    
    
        return CryptoJS.RabbitLegacy;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/rabbit.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/rabbit.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;
    
            // Reusable objects
            var S  = [];
            var C_ = [];
            var G  = [];
    
            /**
             * Rabbit stream cipher algorithm
             */
            var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                _doReset: function () {
                    // Shortcuts
                    var K = this._key.words;
                    var iv = this.cfg.iv;
    
                    // Swap endian
                    for (var i = 0; i < 4; i++) {
                        K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
                               (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
                    }
    
                    // Generate initial state values
                    var X = this._X = [
                        K[0], (K[3] << 16) | (K[2] >>> 16),
                        K[1], (K[0] << 16) | (K[3] >>> 16),
                        K[2], (K[1] << 16) | (K[0] >>> 16),
                        K[3], (K[2] << 16) | (K[1] >>> 16)
                    ];
    
                    // Generate initial counter values
                    var C = this._C = [
                        (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
                        (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
                        (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
                        (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
                    ];
    
                    // Carry bit
                    this._b = 0;
    
                    // Iterate the system four times
                    for (var i = 0; i < 4; i++) {
                        nextState.call(this);
                    }
    
                    // Modify the counters
                    for (var i = 0; i < 8; i++) {
                        C[i] ^= X[(i + 4) & 7];
                    }
    
                    // IV setup
                    if (iv) {
                        // Shortcuts
                        var IV = iv.words;
                        var IV_0 = IV[0];
                        var IV_1 = IV[1];
    
                        // Generate four subvectors
                        var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
                        var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
                        var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
                        var i3 = (i2 << 16)  | (i0 & 0x0000ffff);
    
                        // Modify counter values
                        C[0] ^= i0;
                        C[1] ^= i1;
                        C[2] ^= i2;
                        C[3] ^= i3;
                        C[4] ^= i0;
                        C[5] ^= i1;
                        C[6] ^= i2;
                        C[7] ^= i3;
    
                        // Iterate the system four times
                        for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                        }
                    }
                },
    
                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var X = this._X;
    
                    // Iterate the system
                    nextState.call(this);
    
                    // Generate four keystream words
                    S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
                    S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
                    S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
                    S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);
    
                    for (var i = 0; i < 4; i++) {
                        // Swap endian
                        S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
                               (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);
    
                        // Encrypt
                        M[offset + i] ^= S[i];
                    }
                },
    
                blockSize: 128/32,
    
                ivSize: 64/32
            });
    
            function nextState() {
                // Shortcuts
                var X = this._X;
                var C = this._C;
    
                // Save old counter values
                for (var i = 0; i < 8; i++) {
                    C_[i] = C[i];
                }
    
                // Calculate new counter values
                C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
                C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
                C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
                C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
                C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
                C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
                C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
                C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
                this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;
    
                // Calculate the g-values
                for (var i = 0; i < 8; i++) {
                    var gx = X[i] + C[i];
    
                    // Construct high and low argument for squaring
                    var ga = gx & 0xffff;
                    var gb = gx >>> 16;
    
                    // Calculate high and low result of squaring
                    var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
                    var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);
    
                    // High XOR low
                    G[i] = gh ^ gl;
                }
    
                // Calculate new state values
                X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
                X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
                X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
                X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
                X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
                X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
                X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
                X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
            }
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
             */
            C.Rabbit = StreamCipher._createHelper(Rabbit);
        }());
    
    
        return CryptoJS.Rabbit;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/rc4.js":
    /*!***************************************!*\
      !*** ./node_modules/crypto-js/rc4.js ***!
      \***************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;
    
            /**
             * RC4 stream cipher algorithm.
             */
            var RC4 = C_algo.RC4 = StreamCipher.extend({
                _doReset: function () {
                    // Shortcuts
                    var key = this._key;
                    var keyWords = key.words;
                    var keySigBytes = key.sigBytes;
    
                    // Init sbox
                    var S = this._S = [];
                    for (var i = 0; i < 256; i++) {
                        S[i] = i;
                    }
    
                    // Key setup
                    for (var i = 0, j = 0; i < 256; i++) {
                        var keyByteIndex = i % keySigBytes;
                        var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;
    
                        j = (j + S[i] + keyByte) % 256;
    
                        // Swap
                        var t = S[i];
                        S[i] = S[j];
                        S[j] = t;
                    }
    
                    // Counters
                    this._i = this._j = 0;
                },
    
                _doProcessBlock: function (M, offset) {
                    M[offset] ^= generateKeystreamWord.call(this);
                },
    
                keySize: 256/32,
    
                ivSize: 0
            });
    
            function generateKeystreamWord() {
                // Shortcuts
                var S = this._S;
                var i = this._i;
                var j = this._j;
    
                // Generate keystream word
                var keystreamWord = 0;
                for (var n = 0; n < 4; n++) {
                    i = (i + 1) % 256;
                    j = (j + S[i]) % 256;
    
                    // Swap
                    var t = S[i];
                    S[i] = S[j];
                    S[j] = t;
    
                    keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
                }
    
                // Update counters
                this._i = i;
                this._j = j;
    
                return keystreamWord;
            }
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
             */
            C.RC4 = StreamCipher._createHelper(RC4);
    
            /**
             * Modified RC4 stream cipher algorithm.
             */
            var RC4Drop = C_algo.RC4Drop = RC4.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} drop The number of keystream words to drop. Default 192
                 */
                cfg: RC4.cfg.extend({
                    drop: 192
                }),
    
                _doReset: function () {
                    RC4._doReset.call(this);
    
                    // Drop
                    for (var i = this.cfg.drop; i > 0; i--) {
                        generateKeystreamWord.call(this);
                    }
                }
            });
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
             */
            C.RC4Drop = StreamCipher._createHelper(RC4Drop);
        }());
    
    
        return CryptoJS.RC4;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/ripemd160.js":
    /*!*********************************************!*\
      !*** ./node_modules/crypto-js/ripemd160.js ***!
      \*********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        /** @preserve
        (c) 2012 by Cdric Mesnil. All rights reserved.
    
        Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    
            - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
            - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        */
    
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
    
            // Constants table
            var _zl = WordArray.create([
                0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
                7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
                3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
                1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
                4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
            var _zr = WordArray.create([
                5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
                6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
                15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
                8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
                12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
            var _sl = WordArray.create([
                 11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
                7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
                11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
                  11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
                9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
            var _sr = WordArray.create([
                8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
                9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
                9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
                15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
                8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);
    
            var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
            var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);
    
            /**
             * RIPEMD160 hash algorithm.
             */
            var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                _doReset: function () {
                    this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
                },
    
                _doProcessBlock: function (M, offset) {
    
                    // Swap endian
                    for (var i = 0; i < 16; i++) {
                        // Shortcuts
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
    
                        // Swap
                        M[offset_i] = (
                            (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                            (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                        );
                    }
                    // Shortcut
                    var H  = this._hash.words;
                    var hl = _hl.words;
                    var hr = _hr.words;
                    var zl = _zl.words;
                    var zr = _zr.words;
                    var sl = _sl.words;
                    var sr = _sr.words;
    
                    // Working variables
                    var al, bl, cl, dl, el;
                    var ar, br, cr, dr, er;
    
                    ar = al = H[0];
                    br = bl = H[1];
                    cr = cl = H[2];
                    dr = dl = H[3];
                    er = el = H[4];
                    // Computation
                    var t;
                    for (var i = 0; i < 80; i += 1) {
                        t = (al +  M[offset+zl[i]])|0;
                        if (i<16){
                        t +=  f1(bl,cl,dl) + hl[0];
                        } else if (i<32) {
                        t +=  f2(bl,cl,dl) + hl[1];
                        } else if (i<48) {
                        t +=  f3(bl,cl,dl) + hl[2];
                        } else if (i<64) {
                        t +=  f4(bl,cl,dl) + hl[3];
                        } else {// if (i<80) {
                        t +=  f5(bl,cl,dl) + hl[4];
                        }
                        t = t|0;
                        t =  rotl(t,sl[i]);
                        t = (t+el)|0;
                        al = el;
                        el = dl;
                        dl = rotl(cl, 10);
                        cl = bl;
                        bl = t;
    
                        t = (ar + M[offset+zr[i]])|0;
                        if (i<16){
                        t +=  f5(br,cr,dr) + hr[0];
                        } else if (i<32) {
                        t +=  f4(br,cr,dr) + hr[1];
                        } else if (i<48) {
                        t +=  f3(br,cr,dr) + hr[2];
                        } else if (i<64) {
                        t +=  f2(br,cr,dr) + hr[3];
                        } else {// if (i<80) {
                        t +=  f1(br,cr,dr) + hr[4];
                        }
                        t = t|0;
                        t =  rotl(t,sr[i]) ;
                        t = (t+er)|0;
                        ar = er;
                        er = dr;
                        dr = rotl(cr, 10);
                        cr = br;
                        br = t;
                    }
                    // Intermediate hash value
                    t    = (H[1] + cl + dr)|0;
                    H[1] = (H[2] + dl + er)|0;
                    H[2] = (H[3] + el + ar)|0;
                    H[3] = (H[4] + al + br)|0;
                    H[4] = (H[0] + bl + cr)|0;
                    H[0] =  t;
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
    
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                        (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                        (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
                    );
                    data.sigBytes = (dataWords.length + 1) * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Shortcuts
                    var hash = this._hash;
                    var H = hash.words;
    
                    // Swap endian
                    for (var i = 0; i < 5; i++) {
                        // Shortcut
                        var H_i = H[i];
    
                        // Swap
                        H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                               (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
                    }
    
                    // Return final computed hash
                    return hash;
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
    
                    return clone;
                }
            });
    
    
            function f1(x, y, z) {
                return ((x) ^ (y) ^ (z));
    
            }
    
            function f2(x, y, z) {
                return (((x)&(y)) | ((~x)&(z)));
            }
    
            function f3(x, y, z) {
                return (((x) | (~(y))) ^ (z));
            }
    
            function f4(x, y, z) {
                return (((x) & (z)) | ((y)&(~(z))));
            }
    
            function f5(x, y, z) {
                return ((x) ^ ((y) |(~(z))));
    
            }
    
            function rotl(x,n) {
                return (x<<n) | (x>>>(32-n));
            }
    
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.RIPEMD160('message');
             *     var hash = CryptoJS.RIPEMD160(wordArray);
             */
            C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
             */
            C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
        }(Math));
    
    
        return CryptoJS.RIPEMD160;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/sha1.js":
    /*!****************************************!*\
      !*** ./node_modules/crypto-js/sha1.js ***!
      \****************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
    
            // Reusable object
            var W = [];
    
            /**
             * SHA-1 hash algorithm.
             */
            var SHA1 = C_algo.SHA1 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([
                        0x67452301, 0xefcdab89,
                        0x98badcfe, 0x10325476,
                        0xc3d2e1f0
                    ]);
                },
    
                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var H = this._hash.words;
    
                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];
    
                    // Computation
                    for (var i = 0; i < 80; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            W[i] = (n << 1) | (n >>> 31);
                        }
    
                        var t = ((a << 5) | (a >>> 27)) + e + W[i];
                        if (i < 20) {
                            t += ((b & c) | (~b & d)) + 0x5a827999;
                        } else if (i < 40) {
                            t += (b ^ c ^ d) + 0x6ed9eba1;
                        } else if (i < 60) {
                            t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                        } else /* if (i < 80) */ {
                            t += (b ^ c ^ d) - 0x359d3e2a;
                        }
    
                        e = d;
                        d = c;
                        c = (b << 30) | (b >>> 2);
                        b = a;
                        a = t;
                    }
    
                    // Intermediate hash value
                    H[0] = (H[0] + a) | 0;
                    H[1] = (H[1] + b) | 0;
                    H[2] = (H[2] + c) | 0;
                    H[3] = (H[3] + d) | 0;
                    H[4] = (H[4] + e) | 0;
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
    
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Return final computed hash
                    return this._hash;
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
    
                    return clone;
                }
            });
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA1('message');
             *     var hash = CryptoJS.SHA1(wordArray);
             */
            C.SHA1 = Hasher._createHelper(SHA1);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA1(message, key);
             */
            C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        }());
    
    
        return CryptoJS.SHA1;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/sha224.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/sha224.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA256 = C_algo.SHA256;
    
            /**
             * SHA-224 hash algorithm.
             */
            var SHA224 = C_algo.SHA224 = SHA256.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([
                        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                        0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
                    ]);
                },
    
                _doFinalize: function () {
                    var hash = SHA256._doFinalize.call(this);
    
                    hash.sigBytes -= 4;
    
                    return hash;
                }
            });
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA224('message');
             *     var hash = CryptoJS.SHA224(wordArray);
             */
            C.SHA224 = SHA256._createHelper(SHA224);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA224(message, key);
             */
            C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
        }());
    
    
        return CryptoJS.SHA224;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/sha256.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/sha256.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
    
            // Initialization and round constants tables
            var H = [];
            var K = [];
    
            // Compute constants
            (function () {
                function isPrime(n) {
                    var sqrtN = Math.sqrt(n);
                    for (var factor = 2; factor <= sqrtN; factor++) {
                        if (!(n % factor)) {
                            return false;
                        }
                    }
    
                    return true;
                }
    
                function getFractionalBits(n) {
                    return ((n - (n | 0)) * 0x100000000) | 0;
                }
    
                var n = 2;
                var nPrime = 0;
                while (nPrime < 64) {
                    if (isPrime(n)) {
                        if (nPrime < 8) {
                            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                        }
                        K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
    
                        nPrime++;
                    }
    
                    n++;
                }
            }());
    
            // Reusable object
            var W = [];
    
            /**
             * SHA-256 hash algorithm.
             */
            var SHA256 = C_algo.SHA256 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init(H.slice(0));
                },
    
                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var H = this._hash.words;
    
                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];
                    var f = H[5];
                    var g = H[6];
                    var h = H[7];
    
                    // Computation
                    for (var i = 0; i < 64; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var gamma0x = W[i - 15];
                            var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                          ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                           (gamma0x >>> 3);
    
                            var gamma1x = W[i - 2];
                            var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                          ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                           (gamma1x >>> 10);
    
                            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                        }
    
                        var ch  = (e & f) ^ (~e & g);
                        var maj = (a & b) ^ (a & c) ^ (b & c);
    
                        var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                        var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));
    
                        var t1 = h + sigma1 + ch + K[i] + W[i];
                        var t2 = sigma0 + maj;
    
                        h = g;
                        g = f;
                        f = e;
                        e = (d + t1) | 0;
                        d = c;
                        c = b;
                        b = a;
                        a = (t1 + t2) | 0;
                    }
    
                    // Intermediate hash value
                    H[0] = (H[0] + a) | 0;
                    H[1] = (H[1] + b) | 0;
                    H[2] = (H[2] + c) | 0;
                    H[3] = (H[3] + d) | 0;
                    H[4] = (H[4] + e) | 0;
                    H[5] = (H[5] + f) | 0;
                    H[6] = (H[6] + g) | 0;
                    H[7] = (H[7] + h) | 0;
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
    
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Return final computed hash
                    return this._hash;
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
    
                    return clone;
                }
            });
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA256('message');
             *     var hash = CryptoJS.SHA256(wordArray);
             */
            C.SHA256 = Hasher._createHelper(SHA256);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA256(message, key);
             */
            C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        }(Math));
    
    
        return CryptoJS.SHA256;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/sha3.js":
    /*!****************************************!*\
      !*** ./node_modules/crypto-js/sha3.js ***!
      \****************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var C_algo = C.algo;
    
            // Constants tables
            var RHO_OFFSETS = [];
            var PI_INDEXES  = [];
            var ROUND_CONSTANTS = [];
    
            // Compute Constants
            (function () {
                // Compute rho offset constants
                var x = 1, y = 0;
                for (var t = 0; t < 24; t++) {
                    RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;
    
                    var newX = y % 5;
                    var newY = (2 * x + 3 * y) % 5;
                    x = newX;
                    y = newY;
                }
    
                // Compute pi index constants
                for (var x = 0; x < 5; x++) {
                    for (var y = 0; y < 5; y++) {
                        PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
                    }
                }
    
                // Compute round constants
                var LFSR = 0x01;
                for (var i = 0; i < 24; i++) {
                    var roundConstantMsw = 0;
                    var roundConstantLsw = 0;
    
                    for (var j = 0; j < 7; j++) {
                        if (LFSR & 0x01) {
                            var bitPosition = (1 << j) - 1;
                            if (bitPosition < 32) {
                                roundConstantLsw ^= 1 << bitPosition;
                            } else /* if (bitPosition >= 32) */ {
                                roundConstantMsw ^= 1 << (bitPosition - 32);
                            }
                        }
    
                        // Compute next LFSR
                        if (LFSR & 0x80) {
                            // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
                            LFSR = (LFSR << 1) ^ 0x71;
                        } else {
                            LFSR <<= 1;
                        }
                    }
    
                    ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                }
            }());
    
            // Reusable objects for temporary values
            var T = [];
            (function () {
                for (var i = 0; i < 25; i++) {
                    T[i] = X64Word.create();
                }
            }());
    
            /**
             * SHA-3 hash algorithm.
             */
            var SHA3 = C_algo.SHA3 = Hasher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} outputLength
                 *   The desired number of bits in the output hash.
                 *   Only values permitted are: 224, 256, 384, 512.
                 *   Default: 512
                 */
                cfg: Hasher.cfg.extend({
                    outputLength: 512
                }),
    
                _doReset: function () {
                    var state = this._state = []
                    for (var i = 0; i < 25; i++) {
                        state[i] = new X64Word.init();
                    }
    
                    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
    
                _doProcessBlock: function (M, offset) {
                    // Shortcuts
                    var state = this._state;
                    var nBlockSizeLanes = this.blockSize / 2;
    
                    // Absorb
                    for (var i = 0; i < nBlockSizeLanes; i++) {
                        // Shortcuts
                        var M2i  = M[offset + 2 * i];
                        var M2i1 = M[offset + 2 * i + 1];
    
                        // Swap endian
                        M2i = (
                            (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
                            (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
                        );
                        M2i1 = (
                            (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
                            (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
                        );
    
                        // Absorb message into state
                        var lane = state[i];
                        lane.high ^= M2i1;
                        lane.low  ^= M2i;
                    }
    
                    // Rounds
                    for (var round = 0; round < 24; round++) {
                        // Theta
                        for (var x = 0; x < 5; x++) {
                            // Mix column lanes
                            var tMsw = 0, tLsw = 0;
                            for (var y = 0; y < 5; y++) {
                                var lane = state[x + 5 * y];
                                tMsw ^= lane.high;
                                tLsw ^= lane.low;
                            }
    
                            // Temporary values
                            var Tx = T[x];
                            Tx.high = tMsw;
                            Tx.low  = tLsw;
                        }
                        for (var x = 0; x < 5; x++) {
                            // Shortcuts
                            var Tx4 = T[(x + 4) % 5];
                            var Tx1 = T[(x + 1) % 5];
                            var Tx1Msw = Tx1.high;
                            var Tx1Lsw = Tx1.low;
    
                            // Mix surrounding columns
                            var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
                            var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
                            for (var y = 0; y < 5; y++) {
                                var lane = state[x + 5 * y];
                                lane.high ^= tMsw;
                                lane.low  ^= tLsw;
                            }
                        }
    
                        // Rho Pi
                        for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                            var tMsw;
                            var tLsw;
    
                            // Shortcuts
                            var lane = state[laneIndex];
                            var laneMsw = lane.high;
                            var laneLsw = lane.low;
                            var rhoOffset = RHO_OFFSETS[laneIndex];
    
                            // Rotate lanes
                            if (rhoOffset < 32) {
                                tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
                                tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
                            } else /* if (rhoOffset >= 32) */ {
                                tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
                                tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
                            }
    
                            // Transpose lanes
                            var TPiLane = T[PI_INDEXES[laneIndex]];
                            TPiLane.high = tMsw;
                            TPiLane.low  = tLsw;
                        }
    
                        // Rho pi at x = y = 0
                        var T0 = T[0];
                        var state0 = state[0];
                        T0.high = state0.high;
                        T0.low  = state0.low;
    
                        // Chi
                        for (var x = 0; x < 5; x++) {
                            for (var y = 0; y < 5; y++) {
                                // Shortcuts
                                var laneIndex = x + 5 * y;
                                var lane = state[laneIndex];
                                var TLane = T[laneIndex];
                                var Tx1Lane = T[((x + 1) % 5) + 5 * y];
                                var Tx2Lane = T[((x + 2) % 5) + 5 * y];
    
                                // Mix rows
                                lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
                                lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
                            }
                        }
    
                        // Iota
                        var lane = state[0];
                        var roundConstant = ROUND_CONSTANTS[round];
                        lane.high ^= roundConstant.high;
                        lane.low  ^= roundConstant.low;
                    }
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
                    var blockSizeBits = this.blockSize * 32;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
                    dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
                    data.sigBytes = dataWords.length * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Shortcuts
                    var state = this._state;
                    var outputLengthBytes = this.cfg.outputLength / 8;
                    var outputLengthLanes = outputLengthBytes / 8;
    
                    // Squeeze
                    var hashWords = [];
                    for (var i = 0; i < outputLengthLanes; i++) {
                        // Shortcuts
                        var lane = state[i];
                        var laneMsw = lane.high;
                        var laneLsw = lane.low;
    
                        // Swap endian
                        laneMsw = (
                            (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
                            (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
                        );
                        laneLsw = (
                            (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
                            (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
                        );
    
                        // Squeeze state to retrieve hash
                        hashWords.push(laneLsw);
                        hashWords.push(laneMsw);
                    }
    
                    // Return final computed hash
                    return new WordArray.init(hashWords, outputLengthBytes);
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
    
                    var state = clone._state = this._state.slice(0);
                    for (var i = 0; i < 25; i++) {
                        state[i] = state[i].clone();
                    }
    
                    return clone;
                }
            });
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA3('message');
             *     var hash = CryptoJS.SHA3(wordArray);
             */
            C.SHA3 = Hasher._createHelper(SHA3);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA3(message, key);
             */
            C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        }(Math));
    
    
        return CryptoJS.SHA3;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/sha384.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/sha384.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C.algo;
            var SHA512 = C_algo.SHA512;
    
            /**
             * SHA-384 hash algorithm.
             */
            var SHA384 = C_algo.SHA384 = SHA512.extend({
                _doReset: function () {
                    this._hash = new X64WordArray.init([
                        new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
                        new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
                        new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
                        new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
                    ]);
                },
    
                _doFinalize: function () {
                    var hash = SHA512._doFinalize.call(this);
    
                    hash.sigBytes -= 16;
    
                    return hash;
                }
            });
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA384('message');
             *     var hash = CryptoJS.SHA384(wordArray);
             */
            C.SHA384 = SHA512._createHelper(SHA384);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA384(message, key);
             */
            C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
        }());
    
    
        return CryptoJS.SHA384;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/sha512.js":
    /*!******************************************!*\
      !*** ./node_modules/crypto-js/sha512.js ***!
      \******************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Hasher = C_lib.Hasher;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C.algo;
    
            function X64Word_create() {
                return X64Word.create.apply(X64Word, arguments);
            }
    
            // Constants
            var K = [
                X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
                X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
                X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
                X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
                X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
                X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
                X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
                X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
                X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
                X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
                X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
                X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
                X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
                X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
                X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
                X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
                X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
                X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
                X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
                X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
                X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
                X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
                X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
                X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
                X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
                X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
                X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
                X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
                X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
                X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
                X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
                X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
                X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
                X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
                X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
                X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
                X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
                X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
                X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
                X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
            ];
    
            // Reusable objects
            var W = [];
            (function () {
                for (var i = 0; i < 80; i++) {
                    W[i] = X64Word_create();
                }
            }());
    
            /**
             * SHA-512 hash algorithm.
             */
            var SHA512 = C_algo.SHA512 = Hasher.extend({
                _doReset: function () {
                    this._hash = new X64WordArray.init([
                        new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                        new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                        new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                        new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
                    ]);
                },
    
                _doProcessBlock: function (M, offset) {
                    // Shortcuts
                    var H = this._hash.words;
    
                    var H0 = H[0];
                    var H1 = H[1];
                    var H2 = H[2];
                    var H3 = H[3];
                    var H4 = H[4];
                    var H5 = H[5];
                    var H6 = H[6];
                    var H7 = H[7];
    
                    var H0h = H0.high;
                    var H0l = H0.low;
                    var H1h = H1.high;
                    var H1l = H1.low;
                    var H2h = H2.high;
                    var H2l = H2.low;
                    var H3h = H3.high;
                    var H3l = H3.low;
                    var H4h = H4.high;
                    var H4l = H4.low;
                    var H5h = H5.high;
                    var H5l = H5.low;
                    var H6h = H6.high;
                    var H6l = H6.low;
                    var H7h = H7.high;
                    var H7l = H7.low;
    
                    // Working variables
                    var ah = H0h;
                    var al = H0l;
                    var bh = H1h;
                    var bl = H1l;
                    var ch = H2h;
                    var cl = H2l;
                    var dh = H3h;
                    var dl = H3l;
                    var eh = H4h;
                    var el = H4l;
                    var fh = H5h;
                    var fl = H5l;
                    var gh = H6h;
                    var gl = H6l;
                    var hh = H7h;
                    var hl = H7l;
    
                    // Rounds
                    for (var i = 0; i < 80; i++) {
                        var Wil;
                        var Wih;
    
                        // Shortcut
                        var Wi = W[i];
    
                        // Extend message
                        if (i < 16) {
                            Wih = Wi.high = M[offset + i * 2]     | 0;
                            Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
                        } else {
                            // Gamma0
                            var gamma0x  = W[i - 15];
                            var gamma0xh = gamma0x.high;
                            var gamma0xl = gamma0x.low;
                            var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                            var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));
    
                            // Gamma1
                            var gamma1x  = W[i - 2];
                            var gamma1xh = gamma1x.high;
                            var gamma1xl = gamma1x.low;
                            var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                            var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));
    
                            // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                            var Wi7  = W[i - 7];
                            var Wi7h = Wi7.high;
                            var Wi7l = Wi7.low;
    
                            var Wi16  = W[i - 16];
                            var Wi16h = Wi16.high;
                            var Wi16l = Wi16.low;
    
                            Wil = gamma0l + Wi7l;
                            Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                            Wil = Wil + gamma1l;
                            Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                            Wil = Wil + Wi16l;
                            Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
    
                            Wi.high = Wih;
                            Wi.low  = Wil;
                        }
    
                        var chh  = (eh & fh) ^ (~eh & gh);
                        var chl  = (el & fl) ^ (~el & gl);
                        var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                        var majl = (al & bl) ^ (al & cl) ^ (bl & cl);
    
                        var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                        var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                        var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                        var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));
    
                        // t1 = h + sigma1 + ch + K[i] + W[i]
                        var Ki  = K[i];
                        var Kih = Ki.high;
                        var Kil = Ki.low;
    
                        var t1l = hl + sigma1l;
                        var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                        var t1l = t1l + chl;
                        var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                        var t1l = t1l + Kil;
                        var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                        var t1l = t1l + Wil;
                        var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
    
                        // t2 = sigma0 + maj
                        var t2l = sigma0l + majl;
                        var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
    
                        // Update working variables
                        hh = gh;
                        hl = gl;
                        gh = fh;
                        gl = fl;
                        fh = eh;
                        fl = el;
                        el = (dl + t1l) | 0;
                        eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                        dh = ch;
                        dl = cl;
                        ch = bh;
                        cl = bl;
                        bh = ah;
                        bl = al;
                        al = (t1l + t2l) | 0;
                        ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
                    }
    
                    // Intermediate hash value
                    H0l = H0.low  = (H0l + al);
                    H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
                    H1l = H1.low  = (H1l + bl);
                    H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
                    H2l = H2.low  = (H2l + cl);
                    H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
                    H3l = H3.low  = (H3l + dl);
                    H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
                    H4l = H4.low  = (H4l + el);
                    H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
                    H5l = H5.low  = (H5l + fl);
                    H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
                    H6l = H6.low  = (H6l + gl);
                    H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
                    H7l = H7.low  = (H7l + hl);
                    H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
    
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Convert hash to 32-bit word array before returning
                    var hash = this._hash.toX32();
    
                    // Return final computed hash
                    return hash;
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
    
                    return clone;
                },
    
                blockSize: 1024/32
            });
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA512('message');
             *     var hash = CryptoJS.SHA512(wordArray);
             */
            C.SHA512 = Hasher._createHelper(SHA512);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA512(message, key);
             */
            C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
        }());
    
    
        return CryptoJS.SHA512;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/tripledes.js":
    /*!*********************************************!*\
      !*** ./node_modules/crypto-js/tripledes.js ***!
      \*********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory, undef) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;
    
            // Permuted Choice 1 constants
            var PC1 = [
                57, 49, 41, 33, 25, 17, 9,  1,
                58, 50, 42, 34, 26, 18, 10, 2,
                59, 51, 43, 35, 27, 19, 11, 3,
                60, 52, 44, 36, 63, 55, 47, 39,
                31, 23, 15, 7,  62, 54, 46, 38,
                30, 22, 14, 6,  61, 53, 45, 37,
                29, 21, 13, 5,  28, 20, 12, 4
            ];
    
            // Permuted Choice 2 constants
            var PC2 = [
                14, 17, 11, 24, 1,  5,
                3,  28, 15, 6,  21, 10,
                23, 19, 12, 4,  26, 8,
                16, 7,  27, 20, 13, 2,
                41, 52, 31, 37, 47, 55,
                30, 40, 51, 45, 33, 48,
                44, 49, 39, 56, 34, 53,
                46, 42, 50, 36, 29, 32
            ];
    
            // Cumulative bit shift constants
            var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
    
            // SBOXes and round permutation constants
            var SBOX_P = [
                {
                    0x0: 0x808200,
                    0x10000000: 0x8000,
                    0x20000000: 0x808002,
                    0x30000000: 0x2,
                    0x40000000: 0x200,
                    0x50000000: 0x808202,
                    0x60000000: 0x800202,
                    0x70000000: 0x800000,
                    0x80000000: 0x202,
                    0x90000000: 0x800200,
                    0xa0000000: 0x8200,
                    0xb0000000: 0x808000,
                    0xc0000000: 0x8002,
                    0xd0000000: 0x800002,
                    0xe0000000: 0x0,
                    0xf0000000: 0x8202,
                    0x8000000: 0x0,
                    0x18000000: 0x808202,
                    0x28000000: 0x8202,
                    0x38000000: 0x8000,
                    0x48000000: 0x808200,
                    0x58000000: 0x200,
                    0x68000000: 0x808002,
                    0x78000000: 0x2,
                    0x88000000: 0x800200,
                    0x98000000: 0x8200,
                    0xa8000000: 0x808000,
                    0xb8000000: 0x800202,
                    0xc8000000: 0x800002,
                    0xd8000000: 0x8002,
                    0xe8000000: 0x202,
                    0xf8000000: 0x800000,
                    0x1: 0x8000,
                    0x10000001: 0x2,
                    0x20000001: 0x808200,
                    0x30000001: 0x800000,
                    0x40000001: 0x808002,
                    0x50000001: 0x8200,
                    0x60000001: 0x200,
                    0x70000001: 0x800202,
                    0x80000001: 0x808202,
                    0x90000001: 0x808000,
                    0xa0000001: 0x800002,
                    0xb0000001: 0x8202,
                    0xc0000001: 0x202,
                    0xd0000001: 0x800200,
                    0xe0000001: 0x8002,
                    0xf0000001: 0x0,
                    0x8000001: 0x808202,
                    0x18000001: 0x808000,
                    0x28000001: 0x800000,
                    0x38000001: 0x200,
                    0x48000001: 0x8000,
                    0x58000001: 0x800002,
                    0x68000001: 0x2,
                    0x78000001: 0x8202,
                    0x88000001: 0x8002,
                    0x98000001: 0x800202,
                    0xa8000001: 0x202,
                    0xb8000001: 0x808200,
                    0xc8000001: 0x800200,
                    0xd8000001: 0x0,
                    0xe8000001: 0x8200,
                    0xf8000001: 0x808002
                },
                {
                    0x0: 0x40084010,
                    0x1000000: 0x4000,
                    0x2000000: 0x80000,
                    0x3000000: 0x40080010,
                    0x4000000: 0x40000010,
                    0x5000000: 0x40084000,
                    0x6000000: 0x40004000,
                    0x7000000: 0x10,
                    0x8000000: 0x84000,
                    0x9000000: 0x40004010,
                    0xa000000: 0x40000000,
                    0xb000000: 0x84010,
                    0xc000000: 0x80010,
                    0xd000000: 0x0,
                    0xe000000: 0x4010,
                    0xf000000: 0x40080000,
                    0x800000: 0x40004000,
                    0x1800000: 0x84010,
                    0x2800000: 0x10,
                    0x3800000: 0x40004010,
                    0x4800000: 0x40084010,
                    0x5800000: 0x40000000,
                    0x6800000: 0x80000,
                    0x7800000: 0x40080010,
                    0x8800000: 0x80010,
                    0x9800000: 0x0,
                    0xa800000: 0x4000,
                    0xb800000: 0x40080000,
                    0xc800000: 0x40000010,
                    0xd800000: 0x84000,
                    0xe800000: 0x40084000,
                    0xf800000: 0x4010,
                    0x10000000: 0x0,
                    0x11000000: 0x40080010,
                    0x12000000: 0x40004010,
                    0x13000000: 0x40084000,
                    0x14000000: 0x40080000,
                    0x15000000: 0x10,
                    0x16000000: 0x84010,
                    0x17000000: 0x4000,
                    0x18000000: 0x4010,
                    0x19000000: 0x80000,
                    0x1a000000: 0x80010,
                    0x1b000000: 0x40000010,
                    0x1c000000: 0x84000,
                    0x1d000000: 0x40004000,
                    0x1e000000: 0x40000000,
                    0x1f000000: 0x40084010,
                    0x10800000: 0x84010,
                    0x11800000: 0x80000,
                    0x12800000: 0x40080000,
                    0x13800000: 0x4000,
                    0x14800000: 0x40004000,
                    0x15800000: 0x40084010,
                    0x16800000: 0x10,
                    0x17800000: 0x40000000,
                    0x18800000: 0x40084000,
                    0x19800000: 0x40000010,
                    0x1a800000: 0x40004010,
                    0x1b800000: 0x80010,
                    0x1c800000: 0x0,
                    0x1d800000: 0x4010,
                    0x1e800000: 0x40080010,
                    0x1f800000: 0x84000
                },
                {
                    0x0: 0x104,
                    0x100000: 0x0,
                    0x200000: 0x4000100,
                    0x300000: 0x10104,
                    0x400000: 0x10004,
                    0x500000: 0x4000004,
                    0x600000: 0x4010104,
                    0x700000: 0x4010000,
                    0x800000: 0x4000000,
                    0x900000: 0x4010100,
                    0xa00000: 0x10100,
                    0xb00000: 0x4010004,
                    0xc00000: 0x4000104,
                    0xd00000: 0x10000,
                    0xe00000: 0x4,
                    0xf00000: 0x100,
                    0x80000: 0x4010100,
                    0x180000: 0x4010004,
                    0x280000: 0x0,
                    0x380000: 0x4000100,
                    0x480000: 0x4000004,
                    0x580000: 0x10000,
                    0x680000: 0x10004,
                    0x780000: 0x104,
                    0x880000: 0x4,
                    0x980000: 0x100,
                    0xa80000: 0x4010000,
                    0xb80000: 0x10104,
                    0xc80000: 0x10100,
                    0xd80000: 0x4000104,
                    0xe80000: 0x4010104,
                    0xf80000: 0x4000000,
                    0x1000000: 0x4010100,
                    0x1100000: 0x10004,
                    0x1200000: 0x10000,
                    0x1300000: 0x4000100,
                    0x1400000: 0x100,
                    0x1500000: 0x4010104,
                    0x1600000: 0x4000004,
                    0x1700000: 0x0,
                    0x1800000: 0x4000104,
                    0x1900000: 0x4000000,
                    0x1a00000: 0x4,
                    0x1b00000: 0x10100,
                    0x1c00000: 0x4010000,
                    0x1d00000: 0x104,
                    0x1e00000: 0x10104,
                    0x1f00000: 0x4010004,
                    0x1080000: 0x4000000,
                    0x1180000: 0x104,
                    0x1280000: 0x4010100,
                    0x1380000: 0x0,
                    0x1480000: 0x10004,
                    0x1580000: 0x4000100,
                    0x1680000: 0x100,
                    0x1780000: 0x4010004,
                    0x1880000: 0x10000,
                    0x1980000: 0x4010104,
                    0x1a80000: 0x10104,
                    0x1b80000: 0x4000004,
                    0x1c80000: 0x4000104,
                    0x1d80000: 0x4010000,
                    0x1e80000: 0x4,
                    0x1f80000: 0x10100
                },
                {
                    0x0: 0x80401000,
                    0x10000: 0x80001040,
                    0x20000: 0x401040,
                    0x30000: 0x80400000,
                    0x40000: 0x0,
                    0x50000: 0x401000,
                    0x60000: 0x80000040,
                    0x70000: 0x400040,
                    0x80000: 0x80000000,
                    0x90000: 0x400000,
                    0xa0000: 0x40,
                    0xb0000: 0x80001000,
                    0xc0000: 0x80400040,
                    0xd0000: 0x1040,
                    0xe0000: 0x1000,
                    0xf0000: 0x80401040,
                    0x8000: 0x80001040,
                    0x18000: 0x40,
                    0x28000: 0x80400040,
                    0x38000: 0x80001000,
                    0x48000: 0x401000,
                    0x58000: 0x80401040,
                    0x68000: 0x0,
                    0x78000: 0x80400000,
                    0x88000: 0x1000,
                    0x98000: 0x80401000,
                    0xa8000: 0x400000,
                    0xb8000: 0x1040,
                    0xc8000: 0x80000000,
                    0xd8000: 0x400040,
                    0xe8000: 0x401040,
                    0xf8000: 0x80000040,
                    0x100000: 0x400040,
                    0x110000: 0x401000,
                    0x120000: 0x80000040,
                    0x130000: 0x0,
                    0x140000: 0x1040,
                    0x150000: 0x80400040,
                    0x160000: 0x80401000,
                    0x170000: 0x80001040,
                    0x180000: 0x80401040,
                    0x190000: 0x80000000,
                    0x1a0000: 0x80400000,
                    0x1b0000: 0x401040,
                    0x1c0000: 0x80001000,
                    0x1d0000: 0x400000,
                    0x1e0000: 0x40,
                    0x1f0000: 0x1000,
                    0x108000: 0x80400000,
                    0x118000: 0x80401040,
                    0x128000: 0x0,
                    0x138000: 0x401000,
                    0x148000: 0x400040,
                    0x158000: 0x80000000,
                    0x168000: 0x80001040,
                    0x178000: 0x40,
                    0x188000: 0x80000040,
                    0x198000: 0x1000,
                    0x1a8000: 0x80001000,
                    0x1b8000: 0x80400040,
                    0x1c8000: 0x1040,
                    0x1d8000: 0x80401000,
                    0x1e8000: 0x400000,
                    0x1f8000: 0x401040
                },
                {
                    0x0: 0x80,
                    0x1000: 0x1040000,
                    0x2000: 0x40000,
                    0x3000: 0x20000000,
                    0x4000: 0x20040080,
                    0x5000: 0x1000080,
                    0x6000: 0x21000080,
                    0x7000: 0x40080,
                    0x8000: 0x1000000,
                    0x9000: 0x20040000,
                    0xa000: 0x20000080,
                    0xb000: 0x21040080,
                    0xc000: 0x21040000,
                    0xd000: 0x0,
                    0xe000: 0x1040080,
                    0xf000: 0x21000000,
                    0x800: 0x1040080,
                    0x1800: 0x21000080,
                    0x2800: 0x80,
                    0x3800: 0x1040000,
                    0x4800: 0x40000,
                    0x5800: 0x20040080,
                    0x6800: 0x21040000,
                    0x7800: 0x20000000,
                    0x8800: 0x20040000,
                    0x9800: 0x0,
                    0xa800: 0x21040080,
                    0xb800: 0x1000080,
                    0xc800: 0x20000080,
                    0xd800: 0x21000000,
                    0xe800: 0x1000000,
                    0xf800: 0x40080,
                    0x10000: 0x40000,
                    0x11000: 0x80,
                    0x12000: 0x20000000,
                    0x13000: 0x21000080,
                    0x14000: 0x1000080,
                    0x15000: 0x21040000,
                    0x16000: 0x20040080,
                    0x17000: 0x1000000,
                    0x18000: 0x21040080,
                    0x19000: 0x21000000,
                    0x1a000: 0x1040000,
                    0x1b000: 0x20040000,
                    0x1c000: 0x40080,
                    0x1d000: 0x20000080,
                    0x1e000: 0x0,
                    0x1f000: 0x1040080,
                    0x10800: 0x21000080,
                    0x11800: 0x1000000,
                    0x12800: 0x1040000,
                    0x13800: 0x20040080,
                    0x14800: 0x20000000,
                    0x15800: 0x1040080,
                    0x16800: 0x80,
                    0x17800: 0x21040000,
                    0x18800: 0x40080,
                    0x19800: 0x21040080,
                    0x1a800: 0x0,
                    0x1b800: 0x21000000,
                    0x1c800: 0x1000080,
                    0x1d800: 0x40000,
                    0x1e800: 0x20040000,
                    0x1f800: 0x20000080
                },
                {
                    0x0: 0x10000008,
                    0x100: 0x2000,
                    0x200: 0x10200000,
                    0x300: 0x10202008,
                    0x400: 0x10002000,
                    0x500: 0x200000,
                    0x600: 0x200008,
                    0x700: 0x10000000,
                    0x800: 0x0,
                    0x900: 0x10002008,
                    0xa00: 0x202000,
                    0xb00: 0x8,
                    0xc00: 0x10200008,
                    0xd00: 0x202008,
                    0xe00: 0x2008,
                    0xf00: 0x10202000,
                    0x80: 0x10200000,
                    0x180: 0x10202008,
                    0x280: 0x8,
                    0x380: 0x200000,
                    0x480: 0x202008,
                    0x580: 0x10000008,
                    0x680: 0x10002000,
                    0x780: 0x2008,
                    0x880: 0x200008,
                    0x980: 0x2000,
                    0xa80: 0x10002008,
                    0xb80: 0x10200008,
                    0xc80: 0x0,
                    0xd80: 0x10202000,
                    0xe80: 0x202000,
                    0xf80: 0x10000000,
                    0x1000: 0x10002000,
                    0x1100: 0x10200008,
                    0x1200: 0x10202008,
                    0x1300: 0x2008,
                    0x1400: 0x200000,
                    0x1500: 0x10000000,
                    0x1600: 0x10000008,
                    0x1700: 0x202000,
                    0x1800: 0x202008,
                    0x1900: 0x0,
                    0x1a00: 0x8,
                    0x1b00: 0x10200000,
                    0x1c00: 0x2000,
                    0x1d00: 0x10002008,
                    0x1e00: 0x10202000,
                    0x1f00: 0x200008,
                    0x1080: 0x8,
                    0x1180: 0x202000,
                    0x1280: 0x200000,
                    0x1380: 0x10000008,
                    0x1480: 0x10002000,
                    0x1580: 0x2008,
                    0x1680: 0x10202008,
                    0x1780: 0x10200000,
                    0x1880: 0x10202000,
                    0x1980: 0x10200008,
                    0x1a80: 0x2000,
                    0x1b80: 0x202008,
                    0x1c80: 0x200008,
                    0x1d80: 0x0,
                    0x1e80: 0x10000000,
                    0x1f80: 0x10002008
                },
                {
                    0x0: 0x100000,
                    0x10: 0x2000401,
                    0x20: 0x400,
                    0x30: 0x100401,
                    0x40: 0x2100401,
                    0x50: 0x0,
                    0x60: 0x1,
                    0x70: 0x2100001,
                    0x80: 0x2000400,
                    0x90: 0x100001,
                    0xa0: 0x2000001,
                    0xb0: 0x2100400,
                    0xc0: 0x2100000,
                    0xd0: 0x401,
                    0xe0: 0x100400,
                    0xf0: 0x2000000,
                    0x8: 0x2100001,
                    0x18: 0x0,
                    0x28: 0x2000401,
                    0x38: 0x2100400,
                    0x48: 0x100000,
                    0x58: 0x2000001,
                    0x68: 0x2000000,
                    0x78: 0x401,
                    0x88: 0x100401,
                    0x98: 0x2000400,
                    0xa8: 0x2100000,
                    0xb8: 0x100001,
                    0xc8: 0x400,
                    0xd8: 0x2100401,
                    0xe8: 0x1,
                    0xf8: 0x100400,
                    0x100: 0x2000000,
                    0x110: 0x100000,
                    0x120: 0x2000401,
                    0x130: 0x2100001,
                    0x140: 0x100001,
                    0x150: 0x2000400,
                    0x160: 0x2100400,
                    0x170: 0x100401,
                    0x180: 0x401,
                    0x190: 0x2100401,
                    0x1a0: 0x100400,
                    0x1b0: 0x1,
                    0x1c0: 0x0,
                    0x1d0: 0x2100000,
                    0x1e0: 0x2000001,
                    0x1f0: 0x400,
                    0x108: 0x100400,
                    0x118: 0x2000401,
                    0x128: 0x2100001,
                    0x138: 0x1,
                    0x148: 0x2000000,
                    0x158: 0x100000,
                    0x168: 0x401,
                    0x178: 0x2100400,
                    0x188: 0x2000001,
                    0x198: 0x2100000,
                    0x1a8: 0x0,
                    0x1b8: 0x2100401,
                    0x1c8: 0x100401,
                    0x1d8: 0x400,
                    0x1e8: 0x2000400,
                    0x1f8: 0x100001
                },
                {
                    0x0: 0x8000820,
                    0x1: 0x20000,
                    0x2: 0x8000000,
                    0x3: 0x20,
                    0x4: 0x20020,
                    0x5: 0x8020820,
                    0x6: 0x8020800,
                    0x7: 0x800,
                    0x8: 0x8020000,
                    0x9: 0x8000800,
                    0xa: 0x20800,
                    0xb: 0x8020020,
                    0xc: 0x820,
                    0xd: 0x0,
                    0xe: 0x8000020,
                    0xf: 0x20820,
                    0x80000000: 0x800,
                    0x80000001: 0x8020820,
                    0x80000002: 0x8000820,
                    0x80000003: 0x8000000,
                    0x80000004: 0x8020000,
                    0x80000005: 0x20800,
                    0x80000006: 0x20820,
                    0x80000007: 0x20,
                    0x80000008: 0x8000020,
                    0x80000009: 0x820,
                    0x8000000a: 0x20020,
                    0x8000000b: 0x8020800,
                    0x8000000c: 0x0,
                    0x8000000d: 0x8020020,
                    0x8000000e: 0x8000800,
                    0x8000000f: 0x20000,
                    0x10: 0x20820,
                    0x11: 0x8020800,
                    0x12: 0x20,
                    0x13: 0x800,
                    0x14: 0x8000800,
                    0x15: 0x8000020,
                    0x16: 0x8020020,
                    0x17: 0x20000,
                    0x18: 0x0,
                    0x19: 0x20020,
                    0x1a: 0x8020000,
                    0x1b: 0x8000820,
                    0x1c: 0x8020820,
                    0x1d: 0x20800,
                    0x1e: 0x820,
                    0x1f: 0x8000000,
                    0x80000010: 0x20000,
                    0x80000011: 0x800,
                    0x80000012: 0x8020020,
                    0x80000013: 0x20820,
                    0x80000014: 0x20,
                    0x80000015: 0x8020000,
                    0x80000016: 0x8000000,
                    0x80000017: 0x8000820,
                    0x80000018: 0x8020820,
                    0x80000019: 0x8000020,
                    0x8000001a: 0x8000800,
                    0x8000001b: 0x0,
                    0x8000001c: 0x20800,
                    0x8000001d: 0x820,
                    0x8000001e: 0x20020,
                    0x8000001f: 0x8020800
                }
            ];
    
            // Masks that select the SBOX input
            var SBOX_MASK = [
                0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
                0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
            ];
    
            /**
             * DES block cipher algorithm.
             */
            var DES = C_algo.DES = BlockCipher.extend({
                _doReset: function () {
                    // Shortcuts
                    var key = this._key;
                    var keyWords = key.words;
    
                    // Select 56 bits according to PC1
                    var keyBits = [];
                    for (var i = 0; i < 56; i++) {
                        var keyBitPos = PC1[i] - 1;
                        keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
                    }
    
                    // Assemble 16 subkeys
                    var subKeys = this._subKeys = [];
                    for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                        // Create subkey
                        var subKey = subKeys[nSubKey] = [];
    
                        // Shortcut
                        var bitShift = BIT_SHIFTS[nSubKey];
    
                        // Select 48 bits according to PC2
                        for (var i = 0; i < 24; i++) {
                            // Select from the left 28 key bits
                            subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);
    
                            // Select from the right 28 key bits
                            subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
                        }
    
                        // Since each subkey is applied to an expanded 32-bit input,
                        // the subkey can be broken into 8 values scaled to 32-bits,
                        // which allows the key to be used without expansion
                        subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
                        for (var i = 1; i < 7; i++) {
                            subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
                        }
                        subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
                    }
    
                    // Compute inverse subkeys
                    var invSubKeys = this._invSubKeys = [];
                    for (var i = 0; i < 16; i++) {
                        invSubKeys[i] = subKeys[15 - i];
                    }
                },
    
                encryptBlock: function (M, offset) {
                    this._doCryptBlock(M, offset, this._subKeys);
                },
    
                decryptBlock: function (M, offset) {
                    this._doCryptBlock(M, offset, this._invSubKeys);
                },
    
                _doCryptBlock: function (M, offset, subKeys) {
                    // Get input
                    this._lBlock = M[offset];
                    this._rBlock = M[offset + 1];
    
                    // Initial permutation
                    exchangeLR.call(this, 4,  0x0f0f0f0f);
                    exchangeLR.call(this, 16, 0x0000ffff);
                    exchangeRL.call(this, 2,  0x33333333);
                    exchangeRL.call(this, 8,  0x00ff00ff);
                    exchangeLR.call(this, 1,  0x55555555);
    
                    // Rounds
                    for (var round = 0; round < 16; round++) {
                        // Shortcuts
                        var subKey = subKeys[round];
                        var lBlock = this._lBlock;
                        var rBlock = this._rBlock;
    
                        // Feistel function
                        var f = 0;
                        for (var i = 0; i < 8; i++) {
                            f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                        }
                        this._lBlock = rBlock;
                        this._rBlock = lBlock ^ f;
                    }
    
                    // Undo swap from last round
                    var t = this._lBlock;
                    this._lBlock = this._rBlock;
                    this._rBlock = t;
    
                    // Final permutation
                    exchangeLR.call(this, 1,  0x55555555);
                    exchangeRL.call(this, 8,  0x00ff00ff);
                    exchangeRL.call(this, 2,  0x33333333);
                    exchangeLR.call(this, 16, 0x0000ffff);
                    exchangeLR.call(this, 4,  0x0f0f0f0f);
    
                    // Set output
                    M[offset] = this._lBlock;
                    M[offset + 1] = this._rBlock;
                },
    
                keySize: 64/32,
    
                ivSize: 64/32,
    
                blockSize: 64/32
            });
    
            // Swap bits across the left and right words
            function exchangeLR(offset, mask) {
                var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
                this._rBlock ^= t;
                this._lBlock ^= t << offset;
            }
    
            function exchangeRL(offset, mask) {
                var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
                this._lBlock ^= t;
                this._rBlock ^= t << offset;
            }
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
             */
            C.DES = BlockCipher._createHelper(DES);
    
            /**
             * Triple-DES block cipher algorithm.
             */
            var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                _doReset: function () {
                    // Shortcuts
                    var key = this._key;
                    var keyWords = key.words;
                    // Make sure the key length is valid (64, 128 or >= 192 bit)
                    if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                        throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
                    }
    
                    // Extend the key according to the keying options defined in 3DES standard
                    var key1 = keyWords.slice(0, 2);
                    var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
                    var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
    
                    // Create DES instances
                    this._des1 = DES.createEncryptor(WordArray.create(key1));
                    this._des2 = DES.createEncryptor(WordArray.create(key2));
                    this._des3 = DES.createEncryptor(WordArray.create(key3));
                },
    
                encryptBlock: function (M, offset) {
                    this._des1.encryptBlock(M, offset);
                    this._des2.decryptBlock(M, offset);
                    this._des3.encryptBlock(M, offset);
                },
    
                decryptBlock: function (M, offset) {
                    this._des3.decryptBlock(M, offset);
                    this._des2.encryptBlock(M, offset);
                    this._des1.decryptBlock(M, offset);
                },
    
                keySize: 192/32,
    
                ivSize: 64/32,
    
                blockSize: 64/32
            });
    
            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
             */
            C.TripleDES = BlockCipher._createHelper(TripleDES);
        }());
    
    
        return CryptoJS.TripleDES;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/x64-core.js":
    /*!********************************************!*\
      !*** ./node_modules/crypto-js/x64-core.js ***!
      \********************************************/
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function (undefined) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var X32WordArray = C_lib.WordArray;
    
            /**
             * x64 namespace.
             */
            var C_x64 = C.x64 = {};
    
            /**
             * A 64-bit word.
             */
            var X64Word = C_x64.Word = Base.extend({
                /**
                 * Initializes a newly created 64-bit word.
                 *
                 * @param {number} high The high 32 bits.
                 * @param {number} low The low 32 bits.
                 *
                 * @example
                 *
                 *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
                 */
                init: function (high, low) {
                    this.high = high;
                    this.low = low;
                }
    
                /**
                 * Bitwise NOTs this word.
                 *
                 * @return {X64Word} A new x64-Word object after negating.
                 *
                 * @example
                 *
                 *     var negated = x64Word.not();
                 */
                // not: function () {
                    // var high = ~this.high;
                    // var low = ~this.low;
    
                    // return X64Word.create(high, low);
                // },
    
                /**
                 * Bitwise ANDs this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to AND with this word.
                 *
                 * @return {X64Word} A new x64-Word object after ANDing.
                 *
                 * @example
                 *
                 *     var anded = x64Word.and(anotherX64Word);
                 */
                // and: function (word) {
                    // var high = this.high & word.high;
                    // var low = this.low & word.low;
    
                    // return X64Word.create(high, low);
                // },
    
                /**
                 * Bitwise ORs this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to OR with this word.
                 *
                 * @return {X64Word} A new x64-Word object after ORing.
                 *
                 * @example
                 *
                 *     var ored = x64Word.or(anotherX64Word);
                 */
                // or: function (word) {
                    // var high = this.high | word.high;
                    // var low = this.low | word.low;
    
                    // return X64Word.create(high, low);
                // },
    
                /**
                 * Bitwise XORs this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to XOR with this word.
                 *
                 * @return {X64Word} A new x64-Word object after XORing.
                 *
                 * @example
                 *
                 *     var xored = x64Word.xor(anotherX64Word);
                 */
                // xor: function (word) {
                    // var high = this.high ^ word.high;
                    // var low = this.low ^ word.low;
    
                    // return X64Word.create(high, low);
                // },
    
                /**
                 * Shifts this word n bits to the left.
                 *
                 * @param {number} n The number of bits to shift.
                 *
                 * @return {X64Word} A new x64-Word object after shifting.
                 *
                 * @example
                 *
                 *     var shifted = x64Word.shiftL(25);
                 */
                // shiftL: function (n) {
                    // if (n < 32) {
                        // var high = (this.high << n) | (this.low >>> (32 - n));
                        // var low = this.low << n;
                    // } else {
                        // var high = this.low << (n - 32);
                        // var low = 0;
                    // }
    
                    // return X64Word.create(high, low);
                // },
    
                /**
                 * Shifts this word n bits to the right.
                 *
                 * @param {number} n The number of bits to shift.
                 *
                 * @return {X64Word} A new x64-Word object after shifting.
                 *
                 * @example
                 *
                 *     var shifted = x64Word.shiftR(7);
                 */
                // shiftR: function (n) {
                    // if (n < 32) {
                        // var low = (this.low >>> n) | (this.high << (32 - n));
                        // var high = this.high >>> n;
                    // } else {
                        // var low = this.high >>> (n - 32);
                        // var high = 0;
                    // }
    
                    // return X64Word.create(high, low);
                // },
    
                /**
                 * Rotates this word n bits to the left.
                 *
                 * @param {number} n The number of bits to rotate.
                 *
                 * @return {X64Word} A new x64-Word object after rotating.
                 *
                 * @example
                 *
                 *     var rotated = x64Word.rotL(25);
                 */
                // rotL: function (n) {
                    // return this.shiftL(n).or(this.shiftR(64 - n));
                // },
    
                /**
                 * Rotates this word n bits to the right.
                 *
                 * @param {number} n The number of bits to rotate.
                 *
                 * @return {X64Word} A new x64-Word object after rotating.
                 *
                 * @example
                 *
                 *     var rotated = x64Word.rotR(7);
                 */
                // rotR: function (n) {
                    // return this.shiftR(n).or(this.shiftL(64 - n));
                // },
    
                /**
                 * Adds this word with the passed word.
                 *
                 * @param {X64Word} word The x64-Word to add with this word.
                 *
                 * @return {X64Word} A new x64-Word object after adding.
                 *
                 * @example
                 *
                 *     var added = x64Word.add(anotherX64Word);
                 */
                // add: function (word) {
                    // var low = (this.low + word.low) | 0;
                    // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
                    // var high = (this.high + word.high + carry) | 0;
    
                    // return X64Word.create(high, low);
                // }
            });
    
            /**
             * An array of 64-bit words.
             *
             * @property {Array} words The array of CryptoJS.x64.Word objects.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var X64WordArray = C_x64.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.x64.WordArray.create();
                 *
                 *     var wordArray = CryptoJS.x64.WordArray.create([
                 *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                 *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                 *     ]);
                 *
                 *     var wordArray = CryptoJS.x64.WordArray.create([
                 *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                 *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                 *     ], 10);
                 */
                init: function (words, sigBytes) {
                    words = this.words = words || [];
    
                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 8;
                    }
                },
    
                /**
                 * Converts this 64-bit word array to a 32-bit word array.
                 *
                 * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
                 *
                 * @example
                 *
                 *     var x32WordArray = x64WordArray.toX32();
                 */
                toX32: function () {
                    // Shortcuts
                    var x64Words = this.words;
                    var x64WordsLength = x64Words.length;
    
                    // Convert
                    var x32Words = [];
                    for (var i = 0; i < x64WordsLength; i++) {
                        var x64Word = x64Words[i];
                        x32Words.push(x64Word.high);
                        x32Words.push(x64Word.low);
                    }
    
                    return X32WordArray.create(x32Words, this.sigBytes);
                },
    
                /**
                 * Creates a copy of this word array.
                 *
                 * @return {X64WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = x64WordArray.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
    
                    // Clone "words" array
                    var words = clone.words = this.words.slice(0);
    
                    // Clone each X64Word object
                    var wordsLength = words.length;
                    for (var i = 0; i < wordsLength; i++) {
                        words[i] = words[i].clone();
                    }
    
                    return clone;
                }
            });
        }());
    
    
        return CryptoJS;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/ieee754/index.js":
    /*!***************************************!*\
      !*** ./node_modules/ieee754/index.js ***!
      \***************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]
    
      i += d
    
      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
    
      value = Math.abs(value)
    
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
    
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }
    
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    
      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    
      buffer[offset + i - d] |= s * 128
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/iso-url/index.js":
    /*!***************************************!*\
      !*** ./node_modules/iso-url/index.js ***!
      \***************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    const {
        URLWithLegacySupport,
        format,
        URLSearchParams,
        defaultBase
    } = __webpack_require__(/*! ./src/url */ "./node_modules/iso-url/src/url-browser.js");
    const relative = __webpack_require__(/*! ./src/relative */ "./node_modules/iso-url/src/relative.js");
    
    module.exports = {
        URL: URLWithLegacySupport,
        URLSearchParams,
        format,
        relative,
        defaultBase
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/iso-url/src/relative.js":
    /*!**********************************************!*\
      !*** ./node_modules/iso-url/src/relative.js ***!
      \**********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    const { URLWithLegacySupport, format } = __webpack_require__(/*! ./url */ "./node_modules/iso-url/src/url-browser.js");
    
    module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
        let protocol = location.protocol ?
            location.protocol.replace(':', '') :
            'http';
    
        // Check protocol map
        protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';
        let urlParsed;
    
        try {
            urlParsed = new URLWithLegacySupport(url);
        } catch (err) {
            urlParsed = {};
        }
    
        const base = Object.assign({}, location, {
            protocol: protocol || urlParsed.protocol,
            host: location.host || urlParsed.host
        });
    
        return new URLWithLegacySupport(url, format(base)).toString();
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/iso-url/src/url-browser.js":
    /*!*************************************************!*\
      !*** ./node_modules/iso-url/src/url-browser.js ***!
      \*************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    const defaultBase = self.location ?
        self.location.protocol + '//' + self.location.host :
        '';
    const URL = self.URL;
    
    class URLWithLegacySupport {
        constructor(url = '', base = defaultBase) {
            this.super = new URL(url, base);
            this.path = this.pathname + this.search;
            this.auth =
                this.username && this.password ?
                    this.username + ':' + this.password :
                    null;
    
            this.query =
                this.search && this.search.startsWith('?') ?
                    this.search.slice(1) :
                    null;
        }
    
        get hash() {
            return this.super.hash;
        }
        get host() {
            return this.super.host;
        }
        get hostname() {
            return this.super.hostname;
        }
        get href() {
            return this.super.href;
        }
        get origin() {
            return this.super.origin;
        }
        get password() {
            return this.super.password;
        }
        get pathname() {
            return this.super.pathname;
        }
        get port() {
            return this.super.port;
        }
        get protocol() {
            return this.super.protocol;
        }
        get search() {
            return this.super.search;
        }
        get searchParams() {
            return this.super.searchParams;
        }
        get username() {
            return this.super.username;
        }
    
        set hash(hash) {
            this.super.hash = hash;
        }
        set host(host) {
            this.super.host = host;
        }
        set hostname(hostname) {
            this.super.hostname = hostname;
        }
        set href(href) {
            this.super.href = href;
        }
        set origin(origin) {
            this.super.origin = origin;
        }
        set password(password) {
            this.super.password = password;
        }
        set pathname(pathname) {
            this.super.pathname = pathname;
        }
        set port(port) {
            this.super.port = port;
        }
        set protocol(protocol) {
            this.super.protocol = protocol;
        }
        set search(search) {
            this.super.search = search;
        }
        set searchParams(searchParams) {
            this.super.searchParams = searchParams;
        }
        set username(username) {
            this.super.username = username;
        }
    
        createObjectURL(o) {
            return this.super.createObjectURL(o);
        }
        revokeObjectURL(o) {
            this.super.revokeObjectURL(o);
        }
        toJSON() {
            return this.super.toJSON();
        }
        toString() {
            return this.super.toString();
        }
        format() {
            return this.toString();
        }
    }
    
    function format(obj) {
        if (typeof obj === 'string') {
            const url = new URL(obj);
    
            return url.toString();
        }
    
        if (!(obj instanceof URL)) {
            const userPass =
                obj.username && obj.password ?
                    `${obj.username}:${obj.password}@` :
                    '';
            const auth = obj.auth ? obj.auth + '@' : '';
            const port = obj.port ? ':' + obj.port : '';
            const protocol = obj.protocol ? obj.protocol + '//' : '';
            const host = obj.host || '';
            const hostname = obj.hostname || '';
            const search = obj.search || (obj.query ? '?' + obj.query : '');
            const hash = obj.hash || '';
            const pathname = obj.pathname || '';
            const path = obj.path || pathname + search;
    
            return `${protocol}${userPass || auth}${host ||
                hostname + port}${path}${hash}`;
        }
    }
    
    module.exports = {
        URLWithLegacySupport,
        URLSearchParams: self.URLSearchParams,
        defaultBase,
        format
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/js-sha256/src/sha256.js":
    /*!**********************************************!*\
      !*** ./node_modules/js-sha256/src/sha256.js ***!
      \**********************************************/
    /***/ ((module, exports, __webpack_require__) => {
    
    /* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
    var __WEBPACK_AMD_DEFINE_RESULT__;/**
     * [js-sha256]{@link https://github.com/emn178/js-sha256}
     *
     * @version 0.9.0
     * @author Chen, Yi-Cyuan [emn178@gmail.com]
     * @copyright Chen, Yi-Cyuan 2014-2017
     * @license MIT
     */
    /*jslint bitwise: true */
    (function () {
      'use strict';
    
      var ERROR = 'input is invalid type';
      var WINDOW = typeof window === 'object';
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === 'object';
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
      if (NODE_JS) {
        root = __webpack_require__.g;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && "object" === 'object' && module.exports;
      var AMD =  true && __webpack_require__.amdO;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
      var HEX_CHARS = '0123456789abcdef'.split('');
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
      ];
      var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];
    
      var blocks = [];
    
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function (obj) {
          return Object.prototype.toString.call(obj) === '[object Array]';
        };
      }
    
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function (obj) {
          return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
    
      var createOutputMethod = function (outputType, is224) {
        return function (message) {
          return new Sha256(is224, true).update(message)[outputType]();
        };
      };
    
      var createMethod = function (is224) {
        var method = createOutputMethod('hex', is224);
        if (NODE_JS) {
          method = nodeWrap(method, is224);
        }
        method.create = function () {
          return new Sha256(is224);
        };
        method.update = function (message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type, is224);
        }
        return method;
      };
    
      var nodeWrap = function (method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? 'sha224' : 'sha256';
        var nodeMethod = function (message) {
          if (typeof message === 'string') {
            return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
          } else {
            if (message === null || message === undefined) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) ||
            message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
    
      var createHmacOutputMethod = function (outputType, is224) {
        return function (key, message) {
          return new HmacSha256(key, is224, true).update(message)[outputType]();
        };
      };
    
      var createHmacMethod = function (is224) {
        var method = createHmacOutputMethod('hex', is224);
        method.create = function (key) {
          return new HmacSha256(key, is224);
        };
        method.update = function (key, message) {
          return method.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type, is224);
        }
        return method;
      };
    
      function Sha256(is224, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
            blocks[4] = blocks[5] = blocks[6] = blocks[7] =
            blocks[8] = blocks[9] = blocks[10] = blocks[11] =
            blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
    
        if (is224) {
          this.h0 = 0xc1059ed8;
          this.h1 = 0x367cd507;
          this.h2 = 0x3070dd17;
          this.h3 = 0xf70e5939;
          this.h4 = 0xffc00b31;
          this.h5 = 0x68581511;
          this.h6 = 0x64f98fa7;
          this.h7 = 0xbefa4fa4;
        } else { // 256
          this.h0 = 0x6a09e667;
          this.h1 = 0xbb67ae85;
          this.h2 = 0x3c6ef372;
          this.h3 = 0xa54ff53a;
          this.h4 = 0x510e527f;
          this.h5 = 0x9b05688c;
          this.h6 = 0x1f83d9ab;
          this.h7 = 0x5be0cd19;
        }
    
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is224;
      }
    
      Sha256.prototype.update = function (message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== 'string') {
          if (type === 'object') {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks = this.blocks;
    
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks[0] = this.block;
            blocks[16] = blocks[1] = blocks[2] = blocks[3] =
              blocks[4] = blocks[5] = blocks[6] = blocks[7] =
              blocks[8] = blocks[9] = blocks[10] = blocks[11] =
              blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          }
    
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 0x80) {
                blocks[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 0x800) {
                blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
              } else if (code < 0xd800 || code >= 0xe000) {
                blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
              } else {
                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
              }
            }
          }
    
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
    
      Sha256.prototype.finalize = function () {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i = this.lastByteIndex;
        blocks[16] = this.block;
        blocks[i >> 2] |= EXTRA[i & 3];
        this.block = blocks[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks[0] = this.block;
          blocks[16] = blocks[1] = blocks[2] = blocks[3] =
            blocks[4] = blocks[5] = blocks[6] = blocks[7] =
            blocks[8] = blocks[9] = blocks[10] = blocks[11] =
            blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }
        blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks[15] = this.bytes << 3;
        this.hash();
      };
    
      Sha256.prototype.hash = function () {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
          h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
    
        for (j = 16; j < 64; ++j) {
          // rightrotate
          t1 = blocks[j - 15];
          s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
          t1 = blocks[j - 2];
          s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
          blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
        }
    
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
            s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
            ab = a & b;
            maj = ab ^ (a & c) ^ bc;
            ch = (e & f) ^ (~e & g);
            t1 = h + s1 + ch + K[j] + blocks[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
          s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
          da = d & a;
          maj = da ^ (d & b) ^ ab;
          ch = (h & e) ^ (~h & f);
          t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
          s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
          cd = c & d;
          maj = cd ^ (c & a) ^ da;
          ch = (g & h) ^ (~g & e);
          t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
          t2 = s0 + maj;
          f = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
          s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
          bc = b & c;
          maj = bc ^ (b & d) ^ cd;
          ch = (f & g) ^ (~f & h);
          t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
    
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
    
      Sha256.prototype.hex = function () {
        this.finalize();
    
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
          h6 = this.h6, h7 = this.h7;
    
        var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
          HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
          HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
          HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
          HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
          HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
          HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
          HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
          HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
          HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
          HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
          HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
          HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
          HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
          HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
          HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
          HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
          HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
          HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
          HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
          HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
          HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
          HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
          HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
          HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
          HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
          HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
          HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
        if (!this.is224) {
          hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
            HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
            HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
            HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
        }
        return hex;
      };
    
      Sha256.prototype.toString = Sha256.prototype.hex;
    
      Sha256.prototype.digest = function () {
        this.finalize();
    
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
          h6 = this.h6, h7 = this.h7;
    
        var arr = [
          (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
          (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
          (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
          (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
          (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
          (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
          (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
        ];
        if (!this.is224) {
          arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
        }
        return arr;
      };
    
      Sha256.prototype.array = Sha256.prototype.digest;
    
      Sha256.prototype.arrayBuffer = function () {
        this.finalize();
    
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
    
      function HmacSha256(key, is224, sharedMemory) {
        var i, type = typeof key;
        if (type === 'string') {
          var bytes = [], length = key.length, index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 0x80) {
              bytes[index++] = code;
            } else if (code < 0x800) {
              bytes[index++] = (0xc0 | (code >> 6));
              bytes[index++] = (0x80 | (code & 0x3f));
            } else if (code < 0xd800 || code >= 0xe000) {
              bytes[index++] = (0xe0 | (code >> 12));
              bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
              bytes[index++] = (0x80 | (code & 0x3f));
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
              bytes[index++] = (0xf0 | (code >> 18));
              bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
              bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
              bytes[index++] = (0x80 | (code & 0x3f));
            }
          }
          key = bytes;
        } else {
          if (type === 'object') {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
    
        if (key.length > 64) {
          key = (new Sha256(is224, true)).update(key).array();
        }
    
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 0x5c ^ b;
          iKeyPad[i] = 0x36 ^ b;
        }
    
        Sha256.call(this, is224, sharedMemory);
    
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
    
      HmacSha256.prototype.finalize = function () {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
    
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
    
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return exports;
          }).call(exports, __webpack_require__, exports, module),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
      }
    })();
    
    
    /***/ }),
    
    /***/ "./node_modules/process/browser.js":
    /*!*****************************************!*\
      !*** ./node_modules/process/browser.js ***!
      \*****************************************/
    /***/ ((module) => {
    
    // shim for using process in browser
    var process = module.exports = {};
    
    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.
    
    var cachedSetTimeout;
    var cachedClearTimeout;
    
    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    
    
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    
    
    
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
    
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    
    process.listeners = function (name) { return [] }
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
    
    /***/ }),
    
    /***/ "./node_modules/safe-buffer/index.js":
    /*!*******************************************!*\
      !*** ./node_modules/safe-buffer/index.js ***!
      \*******************************************/
    /***/ ((module, exports, __webpack_require__) => {
    
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    /* eslint-disable node/no-deprecated-api */
    var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
    var Buffer = buffer.Buffer
    
    // alternative to using Object.keys for old browsers
    function copyProps (src, dst) {
      for (var key in src) {
        dst[key] = src[key]
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports)
      exports.Buffer = SafeBuffer
    }
    
    function SafeBuffer (arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length)
    }
    
    SafeBuffer.prototype = Object.create(Buffer.prototype)
    
    // Copy static methods from Buffer
    copyProps(Buffer, SafeBuffer)
    
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number')
      }
      return Buffer(arg, encodingOrOffset, length)
    }
    
    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      var buf = Buffer(size)
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding)
        } else {
          buf.fill(fill)
        }
      } else {
        buf.fill(0)
      }
      return buf
    }
    
    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return Buffer(size)
    }
    
    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return buffer.SlowBuffer(size)
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/simple-cbor/src/index.js":
    /*!***********************************************!*\
      !*** ./node_modules/simple-cbor/src/index.js ***!
      \***********************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    __export(__webpack_require__(/*! ./serializer */ "./node_modules/simple-cbor/src/serializer.js"));
    const value = __importStar(__webpack_require__(/*! ./value */ "./node_modules/simple-cbor/src/value.js"));
    exports.value = value;
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    
    /***/ "./node_modules/simple-cbor/src/serializer.js":
    /*!****************************************************!*\
      !*** ./node_modules/simple-cbor/src/serializer.js ***!
      \****************************************************/
    /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    
    "use strict";
    
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const cbor = __importStar(__webpack_require__(/*! ./value */ "./node_modules/simple-cbor/src/value.js"));
    const BufferClasses = [
        ArrayBuffer,
        Uint8Array,
        Uint16Array,
        Uint32Array,
        Int8Array,
        Int16Array,
        Int32Array,
        Float32Array,
        Float64Array,
    ];
    class JsonDefaultCborEncoder {
        // @param _serializer The CBOR Serializer to use.
        // @param _stable Whether or not keys from objects should be sorted (stable). This is
        //     particularly useful when testing encodings between JSON objects.
        constructor(_serializer, _stable = false) {
            this._serializer = _serializer;
            this._stable = _stable;
            this.name = "jsonDefault";
            this.priority = -100;
        }
        match(value) {
            return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof value) != -1;
        }
        encode(value) {
            switch (typeof value) {
                case "undefined":
                    return cbor.undefined_();
                case "boolean":
                    return cbor.bool(value);
                case "number":
                    if (Math.floor(value) === value) {
                        return cbor.number(value);
                    }
                    else {
                        return cbor.doubleFloat(value);
                    }
                case "string":
                    return cbor.string(value);
                case "object":
                    if (value === null) {
                        return cbor.null_();
                    }
                    else if (Array.isArray(value)) {
                        return cbor.array(value.map((x) => this._serializer.serializeValue(x)));
                    }
                    else if (BufferClasses.find((x) => value instanceof x)) {
                        return cbor.bytes(value.buffer);
                    }
                    else if (Object.getOwnPropertyNames(value).indexOf("toJSON") !== -1) {
                        return this.encode(value.toJSON());
                    }
                    else if (value instanceof Map) {
                        const m = new Map();
                        for (const [key, item] of value.entries()) {
                            m.set(key, this._serializer.serializeValue(item));
                        }
                        return cbor.map(m, this._stable);
                    }
                    else {
                        const m = new Map();
                        for (const [key, item] of Object.entries(value)) {
                            m.set(key, this._serializer.serializeValue(item));
                        }
                        return cbor.map(m, this._stable);
                    }
                default:
                    throw new Error("Invalid value.");
            }
        }
    }
    exports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;
    class ToCborEncoder {
        constructor() {
            this.name = "cborEncoder";
            this.priority = -90;
        }
        match(value) {
            return typeof value == "object" && typeof value["toCBOR"] == "function";
        }
        encode(value) {
            return value.toCBOR();
        }
    }
    exports.ToCborEncoder = ToCborEncoder;
    class CborSerializer {
        constructor() {
            this._encoders = new Set();
        }
        static withDefaultEncoders(stable = false) {
            const s = new this();
            s.addEncoder(new JsonDefaultCborEncoder(s, stable));
            s.addEncoder(new ToCborEncoder());
            return s;
        }
        removeEncoder(name) {
            // Has to make an extra call to values() to ensure it doesn't break on iteration.
            for (const encoder of this._encoders.values()) {
                if (encoder.name == name) {
                    this._encoders.delete(encoder);
                }
            }
        }
        addEncoder(encoder) {
            this._encoders.add(encoder);
        }
        getEncoderFor(value) {
            let chosenEncoder = null;
            for (const encoder of this._encoders) {
                if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {
                    if (encoder.match(value)) {
                        chosenEncoder = encoder;
                    }
                }
            }
            if (chosenEncoder === null) {
                throw new Error("Could not find an encoder for value.");
            }
            return chosenEncoder;
        }
        serializeValue(value) {
            return this.getEncoderFor(value).encode(value);
        }
        serialize(value) {
            return this.serializeValue(value);
        }
    }
    exports.CborSerializer = CborSerializer;
    class SelfDescribeCborSerializer extends CborSerializer {
        serialize(value) {
            return cbor.raw(new Uint8Array([
                // Self describe CBOR.
                ...new Uint8Array([0xd9, 0xd9, 0xf7]),
                ...new Uint8Array(super.serializeValue(value)),
            ]));
        }
    }
    exports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;
    //# sourceMappingURL=serializer.js.map
    
    /***/ }),
    
    /***/ "./node_modules/simple-cbor/src/value.js":
    /*!***********************************************!*\
      !*** ./node_modules/simple-cbor/src/value.js ***!
      \***********************************************/
    /***/ ((__unused_webpack_module, exports) => {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const MAX_U64_NUMBER = 0x20000000000000;
    function _concat(a, ...args) {
        const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));
        newBuffer.set(new Uint8Array(a), 0);
        let i = a.byteLength;
        for (const b of args) {
            newBuffer.set(new Uint8Array(b), i);
            i += b.byteLength;
        }
        return newBuffer.buffer;
    }
    function _serializeValue(major, minor, value) {
        // Remove everything that's not an hexadecimal character. These are not
        // considered errors since the value was already validated and they might
        // be number decimals or sign.
        value = value.replace(/[^0-9a-fA-F]/g, "");
        // Create the buffer from the value with left padding with 0.
        const length = 2 ** (minor - 24 /* Int8 */);
        value = value.slice(-length * 2).padStart(length * 2, "0");
        const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));
        return new Uint8Array(bytes).buffer;
    }
    function _serializeNumber(major, value) {
        if (value < 24) {
            return new Uint8Array([(major << 5) + value]).buffer;
        }
        else {
            const minor = value <= 0xff
                ? 24 /* Int8 */
                : value <= 0xffff
                    ? 25 /* Int16 */
                    : value <= 0xffffffff
                        ? 26 /* Int32 */
                        : 27 /* Int64 */;
            return _serializeValue(major, minor, value.toString(16));
        }
    }
    function _serializeString(str) {
        const utf8 = [];
        for (let i = 0; i < str.length; i++) {
            let charcode = str.charCodeAt(i);
            if (charcode < 0x80) {
                utf8.push(charcode);
            }
            else if (charcode < 0x800) {
                utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
                utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
            }
            else {
                // Surrogate pair
                i++;
                charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);
                utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
            }
        }
        return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));
    }
    /**
     * Tag a value.
     */
    function tagged(tag, value) {
        if (tag == 0xd9d9f7) {
            return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);
        }
        if (tag < 24) {
            return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);
        }
        else {
            const minor = tag <= 0xff
                ? 24 /* Int8 */
                : tag <= 0xffff
                    ? 25 /* Int16 */
                    : tag <= 0xffffffff
                        ? 26 /* Int32 */
                        : 27 /* Int64 */;
            const length = 2 ** (minor - 24 /* Int8 */);
            const value = tag
                .toString(16)
                .slice(-length * 2)
                .padStart(length * 2, "0");
            const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));
            return new Uint8Array(bytes).buffer;
        }
    }
    exports.tagged = tagged;
    /**
     * Set the raw bytes contained by this value. This should only be used with another
     * CborValue, or if you are implementing extensions to CBOR.
     * @param bytes A buffer containing the value.
     */
    function raw(bytes) {
        return new Uint8Array(bytes).buffer;
    }
    exports.raw = raw;
    /**
     * Encode a number that is between [0, 23].
     * @param n
     */
    function uSmall(n) {
        if (isNaN(n)) {
            throw new RangeError("Invalid number.");
        }
        n = Math.min(Math.max(0, n), 23); // Clamp it.
        const bytes = [(0 /* UnsignedInteger */ << 5) + n];
        return new Uint8Array(bytes).buffer;
    }
    exports.uSmall = uSmall;
    function u8(u8, radix) {
        // Force u8 into a number, and validate it.
        u8 = parseInt("" + u8, radix);
        if (isNaN(u8)) {
            throw new RangeError("Invalid number.");
        }
        u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.
        u8 = u8.toString(16);
        return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);
    }
    exports.u8 = u8;
    function u16(u16, radix) {
        // Force u16 into a number, and validate it.
        u16 = parseInt("" + u16, radix);
        if (isNaN(u16)) {
            throw new RangeError("Invalid number.");
        }
        u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.
        u16 = u16.toString(16);
        return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);
    }
    exports.u16 = u16;
    function u32(u32, radix) {
        // Force u32 into a number, and validate it.
        u32 = parseInt("" + u32, radix);
        if (isNaN(u32)) {
            throw new RangeError("Invalid number.");
        }
        u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.
        u32 = u32.toString(16);
        return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);
    }
    exports.u32 = u32;
    function u64(u64, radix) {
        // Special consideration for numbers that might be larger than expected.
        if (typeof u64 == "string" && radix == 16) {
            // This is the only case where we guarantee we'll encode the number directly.
            // Validate it's all hexadecimal first.
            if (u64.match(/[^0-9a-fA-F]/)) {
                throw new RangeError("Invalid number.");
            }
            return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);
        }
        // Force u64 into a number, and validate it.
        u64 = parseInt("" + u64, radix);
        if (isNaN(u64)) {
            throw new RangeError("Invalid number.");
        }
        u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.
        u64 = u64.toString(16);
        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);
    }
    exports.u64 = u64;
    /**
     * Encode a negative number that is between [-24, -1].
     */
    function iSmall(n) {
        if (isNaN(n)) {
            throw new RangeError("Invalid number.");
        }
        if (n === 0) {
            return uSmall(0);
        }
        // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).
        n = Math.min(Math.max(0, -n), 24) - 1;
        const bytes = [(1 /* SignedInteger */ << 5) + n];
        return new Uint8Array(bytes).buffer;
    }
    exports.iSmall = iSmall;
    function i8(i8, radix) {
        // Force i8 into a number, and validate it.
        i8 = parseInt("" + i8, radix);
        if (isNaN(i8)) {
            throw new RangeError("Invalid number.");
        }
        // Negative n, clamped, minus 1 (there's no negative 0).
        i8 = Math.min(Math.max(0, -i8 - 1), 0xff);
        i8 = i8.toString(16);
        return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);
    }
    exports.i8 = i8;
    function i16(i16, radix) {
        // Force i16 into a number, and validate it.
        i16 = parseInt("" + i16, radix);
        if (isNaN(i16)) {
            throw new RangeError("Invalid number.");
        }
        // Negative n, clamped, minus 1 (there's no negative 0).
        i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);
        i16 = i16.toString(16);
        return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);
    }
    exports.i16 = i16;
    function i32(i32, radix) {
        // Force i32 into a number, and validate it.
        i32 = parseInt("" + i32, radix);
        if (isNaN(i32)) {
            throw new RangeError("Invalid number.");
        }
        // Negative n, clamped, minus 1 (there's no negative 0).
        i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);
        i32 = i32.toString(16);
        return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);
    }
    exports.i32 = i32;
    function i64(i64, radix) {
        // Special consideration for numbers that might be larger than expected.
        if (typeof i64 == "string" && radix == 16) {
            if (i64.startsWith("-")) {
                i64 = i64.slice(1);
            }
            else {
                // Clamp it.
                i64 = "0";
            }
            // This is the only case where we guarantee we'll encode the number directly.
            // Validate it's all hexadecimal first.
            if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {
                throw new RangeError("Invalid number.");
            }
            // We need to do -1 to the number.
            let done = false;
            let newI64 = i64.split("").reduceRight((acc, x) => {
                if (done) {
                    return x + acc;
                }
                let n = parseInt(x, 16) - 1;
                if (n >= 0) {
                    done = true;
                    return n.toString(16) + acc;
                }
                else {
                    return "f" + acc;
                }
            }, "");
            if (!done) {
                // This number was 0.
                return u64(0);
            }
            return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);
        }
        // Force i64 into a number, and validate it.
        i64 = parseInt("" + i64, radix);
        if (isNaN(i64)) {
            throw new RangeError("Invalid number.");
        }
        i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.
        i64 = i64.toString(16);
        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);
    }
    exports.i64 = i64;
    /**
     * Encode a number using the smallest amount of bytes, by calling the methods
     * above. e.g. If the number fits in a u8, it will use that.
     */
    function number(n) {
        if (n >= 0) {
            if (n < 24) {
                return uSmall(n);
            }
            else if (n <= 0xff) {
                return u8(n);
            }
            else if (n <= 0xffff) {
                return u16(n);
            }
            else if (n <= 0xffffffff) {
                return u32(n);
            }
            else {
                return u64(n);
            }
        }
        else {
            if (n >= -24) {
                return iSmall(n);
            }
            else if (n >= -0xff) {
                return i8(n);
            }
            else if (n >= -0xffff) {
                return i16(n);
            }
            else if (n >= -0xffffffff) {
                return i32(n);
            }
            else {
                return i64(n);
            }
        }
    }
    exports.number = number;
    /**
     * Encode a byte array. This is different than the `raw()` method.
     */
    function bytes(bytes) {
        return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);
    }
    exports.bytes = bytes;
    /**
     * Encode a JavaScript string.
     */
    function string(str) {
        return _serializeString(str);
    }
    exports.string = string;
    /**
     * Encode an array of cbor values.
     */
    function array(items) {
        return _concat(_serializeNumber(4 /* Array */, items.length), ...items);
    }
    exports.array = array;
    /**
     * Encode a map of key-value pairs. The keys are string, and the values are CBOR
     * encoded.
     */
    function map(items, stable = false) {
        if (!(items instanceof Map)) {
            items = new Map(Object.entries(items));
        }
        let entries = Array.from(items.entries());
        if (stable) {
            entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
        }
        return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));
    }
    exports.map = map;
    /**
     * Encode a single (32 bits) precision floating point number.
     */
    function singleFloat(f) {
        const single = new Float32Array([f]);
        return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));
    }
    exports.singleFloat = singleFloat;
    /**
     * Encode a double (64 bits) precision floating point number.
     */
    function doubleFloat(f) {
        const single = new Float64Array([f]);
        return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));
    }
    exports.doubleFloat = doubleFloat;
    function bool(v) {
        return v ? true_() : false_();
    }
    exports.bool = bool;
    /**
     * Encode the boolean true.
     */
    function true_() {
        return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));
    }
    exports.true_ = true_;
    /**
     * Encode the boolean false.
     */
    function false_() {
        return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));
    }
    exports.false_ = false_;
    /**
     * Encode the constant null.
     */
    function null_() {
        return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));
    }
    exports.null_ = null_;
    /**
     * Encode the constant undefined.
     */
    function undefined_() {
        return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));
    }
    exports.undefined_ = undefined_;
    //# sourceMappingURL=value.js.map
    
    /***/ }),
    
    /***/ "?9157":
    /*!************************!*\
      !*** crypto (ignored) ***!
      \************************/
    /***/ (() => {
    
    /* (ignored) */
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/abstract/curve.js":
    /*!**********************************************************!*\
      !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
      \**********************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   validateBasic: () => (/* binding */ validateBasic),
    /* harmony export */   wNAF: () => (/* binding */ wNAF)
    /* harmony export */ });
    /* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/esm/abstract/modular.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/esm/abstract/utils.js");
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Abelian group utilities
    
    
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    // Elliptic curve multiplication of Point by scalar. Fragile.
    // Scalars should always be less than curve order: this should be checked inside of a curve itself.
    // Creates precomputation tables for fast multiplication:
    // - private scalar is split by fixed size windows of W bits
    // - every window point is collected from window's table & added to accumulator
    // - since windows are different, same point inside tables won't be accessed more than once per calc
    // - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
    // - +1 window is neccessary for wNAF
    // - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
    // TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
    // windows to be in different memory locations
    function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
            const neg = item.negate();
            return condition ? neg : item;
        };
        const opts = (W) => {
            const windows = Math.ceil(bits / W) + 1; // +1, because
            const windowSize = 2 ** (W - 1); // -1 because we skip zero
            return { windows, windowSize };
        };
        return {
            constTimeNegate,
            // non-const time multiplication ladder
            unsafeLadder(elm, n) {
                let p = c.ZERO;
                let d = elm;
                while (n > _0n) {
                    if (n & _1n)
                        p = p.add(d);
                    d = d.double();
                    n >>= _1n;
                }
                return p;
            },
            /**
             * Creates a wNAF precomputation window. Used for caching.
             * Default window size is set by `utils.precompute()` and is equal to 8.
             * Number of precomputed points depends on the curve size:
             * 2^(1) * (Math.ceil( / ) + 1), where:
             * -  is the window size
             * -  is the bitlength of the curve order.
             * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
             * @returns precomputed point tables flattened to a single array
             */
            precomputeWindow(elm, W) {
                const { windows, windowSize } = opts(W);
                const points = [];
                let p = elm;
                let base = p;
                for (let window = 0; window < windows; window++) {
                    base = p;
                    points.push(base);
                    // =1, because we skip zero
                    for (let i = 1; i < windowSize; i++) {
                        base = base.add(p);
                        points.push(base);
                    }
                    p = base.double();
                }
                return points;
            },
            /**
             * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
             * @param W window size
             * @param precomputes precomputed tables
             * @param n scalar (we don't check here, but should be less than curve order)
             * @returns real and fake (for const-time) points
             */
            wNAF(W, precomputes, n) {
                // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
                // But need to carefully remove other checks before wNAF. ORDER == bits here
                const { windows, windowSize } = opts(W);
                let p = c.ZERO;
                let f = c.BASE;
                const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
                const maxNumber = 2 ** W;
                const shiftBy = BigInt(W);
                for (let window = 0; window < windows; window++) {
                    const offset = window * windowSize;
                    // Extract W bits.
                    let wbits = Number(n & mask);
                    // Shift number by W bits.
                    n >>= shiftBy;
                    // If the bits are bigger than max size, we'll split those.
                    // +224 => 256 - 32
                    if (wbits > windowSize) {
                        wbits -= maxNumber;
                        n += _1n;
                    }
                    // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                    // there is negate now: it is possible that negated element from low value
                    // would be the same as high element, which will create carry into next window.
                    // It's not obvious how this can fail, but still worth investigating later.
                    // Check if we're onto Zero point.
                    // Add random point inside current window to f.
                    const offset1 = offset;
                    const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                    const cond1 = window % 2 !== 0;
                    const cond2 = wbits < 0;
                    if (wbits === 0) {
                        // The most important part for const-time getPublicKey
                        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                    }
                    else {
                        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                    }
                }
                // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
                // Even if the variable is still unused, there are some checks which will
                // throw an exception, so compiler needs to prove they won't happen, which is hard.
                // At this point there is a way to F be infinity-point even if p is not,
                // which makes it less const-time: around 1 bigint multiply.
                return { p, f };
            },
            wNAFCached(P, precomputesMap, n, transform) {
                // @ts-ignore
                const W = P._WINDOW_SIZE || 1;
                // Calculate precomputes on a first run, reuse them after
                let comp = precomputesMap.get(P);
                if (!comp) {
                    comp = this.precomputeWindow(P, W);
                    if (W !== 1) {
                        precomputesMap.set(P, transform(comp));
                    }
                }
                return this.wNAF(W, comp, n);
            },
        };
    }
    function validateBasic(curve) {
        (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {
            n: 'bigint',
            h: 'bigint',
            Gx: 'field',
            Gy: 'field',
        }, {
            nBitLength: 'isSafeInteger',
            nByteLength: 'isSafeInteger',
        });
        // Set defaults
        return Object.freeze({
            ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),
            ...curve,
            ...{ p: curve.Fp.ORDER },
        });
    }
    //# sourceMappingURL=curve.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/abstract/edwards.js":
    /*!************************************************************!*\
      !*** ./node_modules/@noble/curves/esm/abstract/edwards.js ***!
      \************************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)
    /* harmony export */ });
    /* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/esm/abstract/modular.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/esm/abstract/utils.js");
    /* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ "./node_modules/@noble/curves/esm/abstract/curve.js");
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Twisted Edwards curve. The formula is: ax + y = 1 + dxy
    
    
    
    
    // Be friendly to bad ECMAScript parsers by not using bigint literals
    // prettier-ignore
    const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
    const VERIFY_DEFAULT = { zip215: true };
    function validateOpts(curve) {
        const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {
            hash: 'function',
            a: 'bigint',
            d: 'bigint',
            randomBytes: 'function',
        }, {
            adjustScalarBytes: 'function',
            domain: 'function',
            uvRatio: 'function',
            mapToCurve: 'function',
        });
        // Set defaults
        return Object.freeze({ ...opts });
    }
    // It is not generic twisted curve for now, but ed25519/ed448 generic implementation
    function twistedEdwards(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;
        const MASK = _2n << (BigInt(nByteLength * 8) - _1n);
        const modP = Fp.create; // Function overrides
        // sqrt(u/v)
        const uvRatio = CURVE.uvRatio ||
            ((u, v) => {
                try {
                    return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
                }
                catch (e) {
                    return { isValid: false, value: _0n };
                }
            });
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP
        const domain = CURVE.domain ||
            ((data, ctx, phflag) => {
                if (ctx.length || phflag)
                    throw new Error('Contexts/pre-hash are not supported');
                return data;
            }); // NOOP
        const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]
        const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]
        const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]
        function assertInRange(n, max) {
            // n in [1..max-1]
            if (inRange(n, max))
                return n;
            throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
            // n in [0..CURVE_ORDER-1]
            return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group
        }
        const pointPrecomputes = new Map();
        function isPoint(other) {
            if (!(other instanceof Point))
                throw new Error('ExtendedPoint expected');
        }
        // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).
        // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
        class Point {
            constructor(ex, ey, ez, et) {
                this.ex = ex;
                this.ey = ey;
                this.ez = ez;
                this.et = et;
                if (!in0MaskRange(ex))
                    throw new Error('x required');
                if (!in0MaskRange(ey))
                    throw new Error('y required');
                if (!in0MaskRange(ez))
                    throw new Error('z required');
                if (!in0MaskRange(et))
                    throw new Error('t required');
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            static fromAffine(p) {
                if (p instanceof Point)
                    throw new Error('extended point not allowed');
                const { x, y } = p || {};
                if (!in0MaskRange(x) || !in0MaskRange(y))
                    throw new Error('invalid affine point');
                return new Point(x, y, _1n, modP(x * y));
            }
            static normalizeZ(points) {
                const toInv = Fp.invertBatch(points.map((p) => p.ez));
                return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            }
            // "Private method", don't use it directly
            _setWindowSize(windowSize) {
                this._WINDOW_SIZE = windowSize;
                pointPrecomputes.delete(this);
            }
            // Not required for fromHex(), which always creates valid points.
            // Could be useful for fromAffine().
            assertValidity() {
                const { a, d } = CURVE;
                if (this.is0())
                    throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
                // Equation in affine coordinates: ax + y = 1 + dxy
                // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY
                const { ex: X, ey: Y, ez: Z, et: T } = this;
                const X2 = modP(X * X); // X
                const Y2 = modP(Y * Y); // Y
                const Z2 = modP(Z * Z); // Z
                const Z4 = modP(Z2 * Z2); // Z
                const aX2 = modP(X2 * a); // aX
                const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z
                const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY
                if (left !== right)
                    throw new Error('bad point: equation left != right (1)');
                // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
                const XY = modP(X * Y);
                const ZT = modP(Z * T);
                if (XY !== ZT)
                    throw new Error('bad point: equation left != right (2)');
            }
            // Compare one point to another.
            equals(other) {
                isPoint(other);
                const { ex: X1, ey: Y1, ez: Z1 } = this;
                const { ex: X2, ey: Y2, ez: Z2 } = other;
                const X1Z2 = modP(X1 * Z2);
                const X2Z1 = modP(X2 * Z1);
                const Y1Z2 = modP(Y1 * Z2);
                const Y2Z1 = modP(Y2 * Z1);
                return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
            }
            is0() {
                return this.equals(Point.ZERO);
            }
            negate() {
                // Flips point sign to a negative one (-x, y in affine coords)
                return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
            }
            // Fast algo for doubling Extended Point.
            // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
            // Cost: 4M + 4S + 1*a + 6add + 1*2.
            double() {
                const { a } = CURVE;
                const { ex: X1, ey: Y1, ez: Z1 } = this;
                const A = modP(X1 * X1); // A = X12
                const B = modP(Y1 * Y1); // B = Y12
                const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
                const D = modP(a * A); // D = a*A
                const x1y1 = X1 + Y1;
                const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
                const G = D + B; // G = D+B
                const F = G - C; // F = G-C
                const H = D - B; // H = D-B
                const X3 = modP(E * F); // X3 = E*F
                const Y3 = modP(G * H); // Y3 = G*H
                const T3 = modP(E * H); // T3 = E*H
                const Z3 = modP(F * G); // Z3 = F*G
                return new Point(X3, Y3, Z3, T3);
            }
            // Fast algo for adding 2 Extended Points.
            // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
            // Cost: 9M + 1*a + 1*d + 7add.
            add(other) {
                isPoint(other);
                const { a, d } = CURVE;
                const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
                const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
                // Faster algo for adding 2 Extended Points when curve's a=-1.
                // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4
                // Cost: 8M + 8add + 2*2.
                // Note: It does not check whether the `other` point is valid.
                if (a === BigInt(-1)) {
                    const A = modP((Y1 - X1) * (Y2 + X2));
                    const B = modP((Y1 + X1) * (Y2 - X2));
                    const F = modP(B - A);
                    if (F === _0n)
                        return this.double(); // Same point. Tests say it doesn't affect timing
                    const C = modP(Z1 * _2n * T2);
                    const D = modP(T1 * _2n * Z2);
                    const E = D + C;
                    const G = B + A;
                    const H = D - C;
                    const X3 = modP(E * F);
                    const Y3 = modP(G * H);
                    const T3 = modP(E * H);
                    const Z3 = modP(F * G);
                    return new Point(X3, Y3, Z3, T3);
                }
                const A = modP(X1 * X2); // A = X1*X2
                const B = modP(Y1 * Y2); // B = Y1*Y2
                const C = modP(T1 * d * T2); // C = T1*d*T2
                const D = modP(Z1 * Z2); // D = Z1*Z2
                const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
                const F = D - C; // F = D-C
                const G = D + C; // G = D+C
                const H = modP(B - a * A); // H = B-a*A
                const X3 = modP(E * F); // X3 = E*F
                const Y3 = modP(G * H); // Y3 = G*H
                const T3 = modP(E * H); // T3 = E*H
                const Z3 = modP(F * G); // Z3 = F*G
                return new Point(X3, Y3, Z3, T3);
            }
            subtract(other) {
                return this.add(other.negate());
            }
            wNAF(n) {
                return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
            }
            // Constant-time multiplication.
            multiply(scalar) {
                const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
                return Point.normalizeZ([p, f])[0];
            }
            // Non-constant-time multiplication. Uses double-and-add algorithm.
            // It's faster, but should only be used when you don't care about
            // an exposed private key e.g. sig verification.
            // Does NOT allow scalars higher than CURVE.n.
            multiplyUnsafe(scalar) {
                let n = assertGE0(scalar); // 0 <= scalar < CURVE.n
                if (n === _0n)
                    return I;
                if (this.equals(I) || n === _1n)
                    return this;
                if (this.equals(G))
                    return this.wNAF(n).p;
                return wnaf.unsafeLadder(this, n);
            }
            // Checks if point is of small order.
            // If you add something to small order point, you will have "dirty"
            // point with torsion component.
            // Multiplies point by cofactor and checks if the result is 0.
            isSmallOrder() {
                return this.multiplyUnsafe(cofactor).is0();
            }
            // Multiplies point by curve order and checks if the result is 0.
            // Returns `false` is the point is dirty.
            isTorsionFree() {
                return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
            }
            // Converts Extended point to default (x, y) coordinates.
            // Can accept precomputed Z^-1 - for example, from invertBatch.
            toAffine(iz) {
                const { ex: x, ey: y, ez: z } = this;
                const is0 = this.is0();
                if (iz == null)
                    iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily
                const ax = modP(x * iz);
                const ay = modP(y * iz);
                const zz = modP(z * iz);
                if (is0)
                    return { x: _0n, y: _1n };
                if (zz !== _1n)
                    throw new Error('invZ was invalid');
                return { x: ax, y: ay };
            }
            clearCofactor() {
                const { h: cofactor } = CURVE;
                if (cofactor === _1n)
                    return this;
                return this.multiplyUnsafe(cofactor);
            }
            // Converts hash string or Uint8Array to Point.
            // Uses algo from RFC8032 5.1.3.
            static fromHex(hex, zip215 = false) {
                const { d, a } = CURVE;
                const len = Fp.BYTES;
                hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array
                const normed = hex.slice(); // copy again, we'll manipulate it
                const lastByte = hex[len - 1]; // select last byte
                normed[len - 1] = lastByte & ~0x80; // clear last bit
                const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);
                if (y === _0n) {
                    // y=0 is allowed
                }
                else {
                    // RFC8032 prohibits >= p, but ZIP215 doesn't
                    if (zip215)
                        assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)
                    else
                        assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)
                }
                // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:
                // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)
                const y2 = modP(y * y); // denominator is always non-0 mod p.
                const u = modP(y2 - _1n); // u = y - 1
                const v = modP(d * y2 - a); // v = d y + 1.
                let { isValid, value: x } = uvRatio(u, v); // (u/v)
                if (!isValid)
                    throw new Error('Point.fromHex: invalid y coordinate');
                const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
                const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
                if (!zip215 && x === _0n && isLastByteOdd)
                    // if x=0 and x_0 = 1, fail
                    throw new Error('Point.fromHex: x=0 and x_0=1');
                if (isLastByteOdd !== isXOdd)
                    x = modP(-x); // if x_0 != x mod 2, set x = p-x
                return Point.fromAffine({ x, y });
            }
            static fromPrivateKey(privKey) {
                return getExtendedPublicKey(privKey).point;
            }
            toRawBytes() {
                const { x, y } = this.toAffine();
                const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)
                bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y
                return bytes; // and use the last byte to encode sign of x
            }
            toHex() {
                return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.
            }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);
        function modN(a) {
            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);
        }
        // Little-endian SHA512 with modulo n
        function modN_LE(hash) {
            return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));
        }
        /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */
        function getExtendedPublicKey(key) {
            const len = nByteLength;
            key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);
            // Hash private key with curve's hash function to produce uniformingly random input
            // Check byte lengths: ensure(64, h(ensure(32, key)))
            const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);
            const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
            const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
            const scalar = modN_LE(head); // The actual private scalar
            const point = G.multiply(scalar); // Point on Edwards curve aka public key
            const pointBytes = point.toRawBytes(); // Uint8Array representation
            return { head, prefix, scalar, point, pointBytes };
        }
        // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared
        function getPublicKey(privKey) {
            return getExtendedPublicKey(privKey).pointBytes;
        }
        // int('LE', SHA512(dom2(F, C) || msgs)) mod N
        function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
            const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);
            return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));
        }
        /** Signs message with privateKey. RFC8032 5.1.6 */
        function sign(msg, privKey, options = {}) {
            msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);
            if (prehash)
                msg = prehash(msg); // for ed25519ph etc.
            const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
            const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
            const R = G.multiply(r).toRawBytes(); // R = rG
            const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
            const s = modN(r + k * scalar); // S = (r + k * s) mod L
            assertGE0(s); // 0 <= s < l
            const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature
        }
        const verifyOpts = VERIFY_DEFAULT;
        function verify(sig, msg, publicKey, options = verifyOpts) {
            const { context, zip215 } = options;
            const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
            sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.
            msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);
            if (prehash)
                msg = prehash(msg); // for ed25519ph, etc
            const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));
            // zip215: true is good for consensus-critical apps and allows points < 2^256
            // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p
            let A, R, SB;
            try {
                A = Point.fromHex(publicKey, zip215);
                R = Point.fromHex(sig.slice(0, len), zip215);
                SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside
            }
            catch (error) {
                return false;
            }
            if (!zip215 && A.isSmallOrder())
                return false;
            const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
            const RkA = R.add(A.multiplyUnsafe(k));
            // [8][S]B = [8]R + [8][k]A'
            return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
        const utils = {
            getExtendedPublicKey,
            // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
            randomPrivateKey: () => randomBytes(Fp.BYTES),
            /**
             * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
             * values. This slows down first getPublicKey() by milliseconds (see Speed section),
             * but allows to speed-up subsequent getPublicKey() calls up to 20x.
             * @param windowSize 2, 4, 8, 16
             */
            precompute(windowSize = 8, point = Point.BASE) {
                point._setWindowSize(windowSize);
                point.multiply(BigInt(3));
                return point;
            },
        };
        return {
            CURVE,
            getPublicKey,
            sign,
            verify,
            ExtendedPoint: Point,
            utils,
        };
    }
    //# sourceMappingURL=edwards.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
    /*!******************************************************************!*\
      !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
      \******************************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   createHasher: () => (/* binding */ createHasher),
    /* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),
    /* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),
    /* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),
    /* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)
    /* harmony export */ });
    /* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/esm/abstract/modular.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/esm/abstract/utils.js");
    
    
    function validateDST(dst) {
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(dst))
            return dst;
        if (typeof dst === 'string')
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);
        throw new Error('DST must be Uint8Array or string');
    }
    // Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
    const os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;
    // Integer to Octet Stream (numberToBytesBE)
    function i2osp(value, length) {
        if (value < 0 || value >= 1 << (8 * length)) {
            throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
            res[i] = value & 0xff;
            value >>>= 8;
        }
        return new Uint8Array(res);
    }
    function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
            arr[i] = a[i] ^ b[i];
        }
        return arr;
    }
    function abytes(item) {
        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(item))
            throw new Error('Uint8Array expected');
    }
    function isNum(item) {
        if (!Number.isSafeInteger(item))
            throw new Error('number expected');
    }
    // Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
    function expand_message_xmd(msg, DST, lenInBytes, H) {
        abytes(msg);
        abytes(DST);
        isNum(lenInBytes);
        // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
        if (DST.length > 255)
            DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
            throw new Error('Invalid xmd length');
        const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
        const b = new Array(ell);
        const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
            const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
            b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
    }
    // Produces a uniformly random byte string using an extendable-output function (XOF) H.
    // 1. The collision resistance of H MUST be at least k bits.
    // 2. H MUST be an XOF that has been proved indifferentiable from
    //    a random oracle under a reasonable cryptographic assumption.
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
        abytes(msg);
        abytes(DST);
        isNum(lenInBytes);
        // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
        // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
        if (DST.length > 255) {
            const dkLen = Math.ceil((2 * k) / 8);
            DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
            throw new Error('expand_message_xof: invalid lenInBytes');
        return (H.create({ dkLen: lenInBytes })
            .update(msg)
            .update(i2osp(lenInBytes, 2))
            // 2. DST_prime = DST || I2OSP(len(DST), 1)
            .update(DST)
            .update(i2osp(DST.length, 1))
            .digest());
    }
    /**
     * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
     * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
     * @param msg a byte string containing the message to hash
     * @param count the number of elements of F to output
     * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
     * @returns [u_0, ..., u_(count - 1)], a list of field elements.
     */
    function hash_to_field(msg, count, options) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {
            DST: 'stringOrUint8Array',
            p: 'bigint',
            m: 'isSafeInteger',
            k: 'isSafeInteger',
            hash: 'hash',
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        abytes(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
        const len_in_bytes = count * m * L;
        let prb; // pseudo_random_bytes
        if (expand === 'xmd') {
            prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        }
        else if (expand === 'xof') {
            prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        }
        else if (expand === '_internal_pass') {
            // for internal tests only
            prb = msg;
        }
        else {
            throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
            const e = new Array(m);
            for (let j = 0; j < m; j++) {
                const elm_offset = L * (j + i * m);
                const tv = prb.subarray(elm_offset, elm_offset + L);
                e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);
            }
            u[i] = e;
        }
        return u;
    }
    function isogenyMap(field, map) {
        // Make same order as in spec
        const COEFF = map.map((i) => Array.from(i).reverse());
        return (x, y) => {
            const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
            x = field.div(xNum, xDen); // xNum / xDen
            y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
            return { x, y };
        };
    }
    function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== 'function')
            throw new Error('mapToCurve() must be defined');
        return {
            // Encodes byte string to elliptic curve.
            // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
            hashToCurve(msg, options) {
                const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
                const u0 = Point.fromAffine(mapToCurve(u[0]));
                const u1 = Point.fromAffine(mapToCurve(u[1]));
                const P = u0.add(u1).clearCofactor();
                P.assertValidity();
                return P;
            },
            // Encodes byte string to elliptic curve.
            // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
            encodeToCurve(msg, options) {
                const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
                const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
                P.assertValidity();
                return P;
            },
        };
    }
    //# sourceMappingURL=hash-to-curve.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/abstract/modular.js":
    /*!************************************************************!*\
      !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
      \************************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Field: () => (/* binding */ Field),
    /* harmony export */   FpDiv: () => (/* binding */ FpDiv),
    /* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),
    /* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),
    /* harmony export */   FpPow: () => (/* binding */ FpPow),
    /* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),
    /* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),
    /* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),
    /* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),
    /* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),
    /* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),
    /* harmony export */   invert: () => (/* binding */ invert),
    /* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),
    /* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),
    /* harmony export */   mod: () => (/* binding */ mod),
    /* harmony export */   nLength: () => (/* binding */ nLength),
    /* harmony export */   pow: () => (/* binding */ pow),
    /* harmony export */   pow2: () => (/* binding */ pow2),
    /* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),
    /* harmony export */   validateField: () => (/* binding */ validateField)
    /* harmony export */ });
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/esm/abstract/utils.js");
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Utilities for modular arithmetics and finite fields
    
    // prettier-ignore
    const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
    // prettier-ignore
    const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
    // prettier-ignore
    const _9n = BigInt(9), _16n = BigInt(16);
    // Calculates a modulo b
    function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
    }
    /**
     * Efficiently raise num to power and do modular division.
     * Unsafe in some contexts: uses ladder, so can expose bigint bits.
     * @example
     * pow(2n, 6n, 11n) // 64n % 11n == 9n
     */
    // TODO: use field version && remove
    function pow(num, power, modulo) {
        if (modulo <= _0n || power < _0n)
            throw new Error('Expected power/modulo > 0');
        if (modulo === _1n)
            return _0n;
        let res = _1n;
        while (power > _0n) {
            if (power & _1n)
                res = (res * num) % modulo;
            num = (num * num) % modulo;
            power >>= _1n;
        }
        return res;
    }
    // Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
    function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
            res *= res;
            res %= modulo;
        }
        return res;
    }
    // Inverses number over modulo
    function invert(number, modulo) {
        if (number === _0n || modulo <= _0n) {
            throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
        // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
        let a = mod(number, modulo);
        let b = modulo;
        // prettier-ignore
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
            // JIT applies optimization if those two lines follow each other
            const q = b / a;
            const r = b % a;
            const m = x - u * q;
            const n = y - v * q;
            // prettier-ignore
            b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
            throw new Error('invert: does not exist');
        return mod(x, modulo);
    }
    /**
     * Tonelli-Shanks square root search algorithm.
     * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
     * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
     * Will start an infinite loop if field order P is not prime.
     * @param P field order
     * @returns function that takes field Fp (created from P) and number n
     */
    function tonelliShanks(P) {
        // Legendre constant: used to calculate Legendre symbol (a | p),
        // which denotes the value of a^((p-1)/2) (mod p).
        // (a | p)  1    if a is a square (mod p)
        // (a | p)  -1   if a is not a square (mod p)
        // (a | p)  0    if a  0 (mod p)
        const legendreC = (P - _1n) / _2n;
        let Q, S, Z;
        // Step 1: By factoring out powers of 2 from p - 1,
        // find q and s such that p - 1 = q*(2^s) with q odd
        for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
            ;
        // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
        for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
            ;
        // Fast-path
        if (S === 1) {
            const p1div4 = (P + _1n) / _4n;
            return function tonelliFast(Fp, n) {
                const root = Fp.pow(n, p1div4);
                if (!Fp.eql(Fp.sqr(root), n))
                    throw new Error('Cannot find square root');
                return root;
            };
        }
        // Slow-path
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
            // Step 0: Check that n is indeed a square: (n | p) should not be  -1
            if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
                throw new Error('Cannot find square root');
            let r = S;
            // TODO: will fail at Fp2/etc
            let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
            let x = Fp.pow(n, Q1div2); // first guess at the square root
            let b = Fp.pow(n, Q); // first guess at the fudge factor
            while (!Fp.eql(b, Fp.ONE)) {
                if (Fp.eql(b, Fp.ZERO))
                    return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
                // Find m such b^(2^m)==1
                let m = 1;
                for (let t2 = Fp.sqr(b); m < r; m++) {
                    if (Fp.eql(t2, Fp.ONE))
                        break;
                    t2 = Fp.sqr(t2); // t2 *= t2
                }
                // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
                const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
                g = Fp.sqr(ge); // g = ge * ge
                x = Fp.mul(x, ge); // x *= ge
                b = Fp.mul(b, g); // b *= g
                r = m;
            }
            return x;
        };
    }
    function FpSqrt(P) {
        // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
        // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
        // P  3 (mod 4)
        // n = n^((P+1)/4)
        if (P % _4n === _3n) {
            // Not all roots possible!
            // const ORDER =
            //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
            // const NUM = 72057594037927816n;
            const p1div4 = (P + _1n) / _4n;
            return function sqrt3mod4(Fp, n) {
                const root = Fp.pow(n, p1div4);
                // Throw if root**2 != n
                if (!Fp.eql(Fp.sqr(root), n))
                    throw new Error('Cannot find square root');
                return root;
            };
        }
        // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
        if (P % _8n === _5n) {
            const c1 = (P - _5n) / _8n;
            return function sqrt5mod8(Fp, n) {
                const n2 = Fp.mul(n, _2n);
                const v = Fp.pow(n2, c1);
                const nv = Fp.mul(n, v);
                const i = Fp.mul(Fp.mul(nv, _2n), v);
                const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
                if (!Fp.eql(Fp.sqr(root), n))
                    throw new Error('Cannot find square root');
                return root;
            };
        }
        // P  9 (mod 16)
        if (P % _16n === _9n) {
            // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
            // Means we cannot use sqrt for constants at all!
            //
            // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
            // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
            // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
            // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
            // sqrt = (x) => {
            //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
            //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
            //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
            //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
            //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
            //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
            //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
            //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
            //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
            //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
            // }
        }
        // Other cases: Tonelli-Shanks algorithm
        return tonelliShanks(P);
    }
    // Little-endian check for first LE bit (last BE bit);
    const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    // prettier-ignore
    const FIELD_FIELDS = [
        'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
        'eql', 'add', 'sub', 'mul', 'pow', 'div',
        'addN', 'subN', 'mulN', 'sqrN'
    ];
    function validateField(field) {
        const initial = {
            ORDER: 'bigint',
            MASK: 'bigint',
            BYTES: 'isSafeInteger',
            BITS: 'isSafeInteger',
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
            map[val] = 'function';
            return map;
        }, initial);
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);
    }
    // Generic field functions
    /**
     * Same as `pow` but for Fp: non-constant-time.
     * Unsafe in some contexts: uses ladder, so can expose bigint bits.
     */
    function FpPow(f, num, power) {
        // Should have same speed as pow for bigints
        // TODO: benchmark!
        if (power < _0n)
            throw new Error('Expected power > 0');
        if (power === _0n)
            return f.ONE;
        if (power === _1n)
            return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n) {
            if (power & _1n)
                p = f.mul(p, d);
            d = f.sqr(d);
            power >>= _1n;
        }
        return p;
    }
    /**
     * Efficiently invert an array of Field elements.
     * `inv(0)` will return `undefined` here: make sure to throw an error.
     */
    function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        // Walk from first to last, multiply them by each other MOD p
        const lastMultiplied = nums.reduce((acc, num, i) => {
            if (f.is0(num))
                return acc;
            tmp[i] = acc;
            return f.mul(acc, num);
        }, f.ONE);
        // Invert last element
        const inverted = f.inv(lastMultiplied);
        // Walk from last to first, multiply them by inverted each other MOD p
        nums.reduceRight((acc, num, i) => {
            if (f.is0(num))
                return acc;
            tmp[i] = f.mul(acc, tmp[i]);
            return f.mul(acc, num);
        }, inverted);
        return tmp;
    }
    function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    // This function returns True whenever the value x is a square in the field F.
    function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
        return (x) => {
            const p = f.pow(x, legendreConst);
            return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
    }
    // CURVE.n lengths
    function nLength(n, nBitLength) {
        // Bit size, byte size of CURVE.n
        const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
    }
    /**
     * Initializes a finite field over prime. **Non-primes are not supported.**
     * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
     * Major performance optimizations:
     * * a) denormalized operations like mulN instead of mul
     * * b) same object shape: never add or remove keys
     * * c) Object.freeze
     * @param ORDER prime positive bigint
     * @param bitLen how many bits the field consumes
     * @param isLE (def: false) if encoding / decoding should be in little-endian
     * @param redef optional faster redefinitions of sqrt and other methods
     */
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n)
            throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
            throw new Error('Field lengths over 2048 bytes are not supported');
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
            ORDER,
            BITS,
            BYTES,
            MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),
            ZERO: _0n,
            ONE: _1n,
            create: (num) => mod(num, ORDER),
            isValid: (num) => {
                if (typeof num !== 'bigint')
                    throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
                return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
            },
            is0: (num) => num === _0n,
            isOdd: (num) => (num & _1n) === _1n,
            neg: (num) => mod(-num, ORDER),
            eql: (lhs, rhs) => lhs === rhs,
            sqr: (num) => mod(num * num, ORDER),
            add: (lhs, rhs) => mod(lhs + rhs, ORDER),
            sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
            mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
            pow: (num, power) => FpPow(f, num, power),
            div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
            // Same as above, but doesn't normalize
            sqrN: (num) => num * num,
            addN: (lhs, rhs) => lhs + rhs,
            subN: (lhs, rhs) => lhs - rhs,
            mulN: (lhs, rhs) => lhs * rhs,
            inv: (num) => invert(num, ORDER),
            sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
            invertBatch: (lst) => FpInvertBatch(f, lst),
            // TODO: do we really need constant cmov?
            // We don't have const-time bigints anyway, so probably will be not very useful
            cmov: (a, b, c) => (c ? b : a),
            toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),
            fromBytes: (bytes) => {
                if (bytes.length !== BYTES)
                    throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
                return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);
            },
        });
        return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
            throw new Error(`Field doesn't have isOdd`);
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
            throw new Error(`Field doesn't have isOdd`);
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    /**
     * "Constant-time" private key generation utility.
     * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
     * Which makes it slightly more biased, less secure.
     * @deprecated use mapKeyToField instead
     */
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
        hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);
        const hashLen = hash.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
            throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
    }
    /**
     * Returns total number of bytes consumed by the field element.
     * For example, 32 bytes for usual 256-bit weierstrass curve.
     * @param fieldOrder number of field elements, usually CURVE.n
     * @returns byte length of field
     */
    function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== 'bigint')
            throw new Error('field order must be bigint');
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
    }
    /**
     * Returns minimal amount of bytes that can be safely reduced
     * by field order.
     * Should be 2^-128 for 128-bit curve such as P256.
     * @param fieldOrder number of field elements, usually CURVE.n
     * @returns byte length of target hash
     */
    function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
    }
    /**
     * "Constant-time" private key generation utility.
     * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
     * and convert them into private scalar, with the modulo bias being negligible.
     * Needs at least 48 bytes of input for 32-byte private key.
     * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
     * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
     * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
     * @param hash hash output from SHA3 or a similar function
     * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
     * @param isLE interpret hash bytes as LE num
     * @returns valid private scalar
     */
    function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
        if (len < 16 || len < minLen || len > 1024)
            throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);
        // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);
    }
    //# sourceMappingURL=modular.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/abstract/montgomery.js":
    /*!***************************************************************!*\
      !*** ./node_modules/@noble/curves/esm/abstract/montgomery.js ***!
      \***************************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   montgomery: () => (/* binding */ montgomery)
    /* harmony export */ });
    /* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/esm/abstract/modular.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/esm/abstract/utils.js");
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    
    
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    function validateOpts(curve) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {
            a: 'bigint',
        }, {
            montgomeryBits: 'isSafeInteger',
            nByteLength: 'isSafeInteger',
            adjustScalarBytes: 'function',
            domain: 'function',
            powPminus2: 'function',
            Gu: 'bigint',
        });
        // Set defaults
        return Object.freeze({ ...curve });
    }
    // NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)
    // Uses only one coordinate instead of two
    function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));
        // cswap from RFC7748. But it is not from RFC7748!
        /*
          cswap(swap, x_2, x_3):
               dummy = mask(swap) AND (x_2 XOR x_3)
               x_2 = x_2 XOR dummy
               x_3 = x_3 XOR dummy
               Return (x_2, x_3)
        Where mask(swap) is the all-1 or all-0 word of the same length as x_2
         and x_3, computed, e.g., as mask(swap) = 0 - swap.
        */
        function cswap(swap, x_2, x_3) {
            const dummy = modP(swap * (x_2 - x_3));
            x_2 = modP(x_2 - dummy);
            x_3 = modP(x_3 + dummy);
            return [x_2, x_3];
        }
        // Accepts 0 as well
        function assertFieldElement(n) {
            if (typeof n === 'bigint' && _0n <= n && n < P)
                return n;
            throw new Error('Expected valid scalar 0 < scalar < CURVE.P');
        }
        // x25519 from 4
        // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        /**
         *
         * @param pointU u coordinate (x) on Montgomery Curve 25519
         * @param scalar by which the point would be multiplied
         * @returns new Point on Montgomery curve
         */
        function montgomeryLadder(pointU, scalar) {
            const u = assertFieldElement(pointU);
            // Section 5: Implementations MUST accept non-canonical values and process them as
            // if they had been reduced modulo the field prime.
            const k = assertFieldElement(scalar);
            const x_1 = u;
            let x_2 = _1n;
            let z_2 = _0n;
            let x_3 = u;
            let z_3 = _1n;
            let swap = _0n;
            let sw;
            for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
                const k_t = (k >> t) & _1n;
                swap ^= k_t;
                sw = cswap(swap, x_2, x_3);
                x_2 = sw[0];
                x_3 = sw[1];
                sw = cswap(swap, z_2, z_3);
                z_2 = sw[0];
                z_3 = sw[1];
                swap = k_t;
                const A = x_2 + z_2;
                const AA = modP(A * A);
                const B = x_2 - z_2;
                const BB = modP(B * B);
                const E = AA - BB;
                const C = x_3 + z_3;
                const D = x_3 - z_3;
                const DA = modP(D * A);
                const CB = modP(C * B);
                const dacb = DA + CB;
                const da_cb = DA - CB;
                x_3 = modP(dacb * dacb);
                z_3 = modP(x_1 * modP(da_cb * da_cb));
                x_2 = modP(AA * BB);
                z_2 = modP(E * (AA + modP(a24 * E)));
            }
            // (x_2, x_3) = cswap(swap, x_2, x_3)
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            // (z_2, z_3) = cswap(swap, z_2, z_3)
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            // z_2^(p - 2)
            const z2 = powPminus2(z_2);
            // Return x_2 * (z_2^(p - 2))
            return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
            // Section 5: When receiving such an array, implementations of X25519
            // MUST mask the most significant bit in the final byte.
            const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);
            if (fieldLen === 32)
                u[31] &= 127; // 0b0111_1111
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
            const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('scalar', n);
            const len = bytes.length;
            if (len !== montgomeryBytes && len !== fieldLen)
                throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));
        }
        function scalarMult(scalar, u) {
            const pointU = decodeUCoordinate(u);
            const _scalar = decodeScalar(scalar);
            const pu = montgomeryLadder(pointU, _scalar);
            // The result was not contributory
            // https://cr.yp.to/ecdh.html#validate
            if (pu === _0n)
                throw new Error('Invalid private or public key received');
            return encodeUCoordinate(pu);
        }
        // Computes public key from private. By doing scalar multiplication of base point.
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
            return scalarMult(scalar, GuBytes);
        }
        return {
            scalarMult,
            scalarMultBase,
            getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
            getPublicKey: (privateKey) => scalarMultBase(privateKey),
            utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
            GuBytes: GuBytes,
        };
    }
    //# sourceMappingURL=montgomery.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/abstract/utils.js":
    /*!**********************************************************!*\
      !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
      \**********************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   bitGet: () => (/* binding */ bitGet),
    /* harmony export */   bitLen: () => (/* binding */ bitLen),
    /* harmony export */   bitMask: () => (/* binding */ bitMask),
    /* harmony export */   bitSet: () => (/* binding */ bitSet),
    /* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),
    /* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),
    /* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),
    /* harmony export */   concatBytes: () => (/* binding */ concatBytes),
    /* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),
    /* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),
    /* harmony export */   equalBytes: () => (/* binding */ equalBytes),
    /* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),
    /* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),
    /* harmony export */   isBytes: () => (/* binding */ isBytes),
    /* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),
    /* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),
    /* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),
    /* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),
    /* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),
    /* harmony export */   validateObject: () => (/* binding */ validateObject)
    /* harmony export */ });
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // 100 lines of code in the file are duplicated from noble-hashes (utils).
    // This is OK: `abstract` directory does not use noble-hashes.
    // User may opt-in into using different hashing library. This way, noble-hashes
    // won't be included into their bundle.
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    const _2n = BigInt(2);
    function isBytes(a) {
        return (a instanceof Uint8Array ||
            (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
    }
    // Array where index 0xf0 (240) is mapped to string 'f0'
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
    /**
     * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
     */
    function bytesToHex(bytes) {
        if (!isBytes(bytes))
            throw new Error('Uint8Array expected');
        // pre-caching improves the speed 6x
        let hex = '';
        for (let i = 0; i < bytes.length; i++) {
            hex += hexes[bytes[i]];
        }
        return hex;
    }
    function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        // Big Endian
        return BigInt(hex === '' ? '0' : `0x${hex}`);
    }
    // We use optimized technique to convert hex string to byte array
    const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
            return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
            return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
            return char - (asciis._a - 10);
        return;
    }
    /**
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
            throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
            const n1 = asciiToBase16(hex.charCodeAt(hi));
            const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
            if (n1 === undefined || n2 === undefined) {
                const char = hex[hi] + hex[hi + 1];
                throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
            }
            array[ai] = n1 * 16 + n2;
        }
        return array;
    }
    // BE: Big Endian, LE: Little Endian
    function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
        if (!isBytes(bytes))
            throw new Error('Uint8Array expected');
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, '0'));
    }
    function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
    }
    // Unpadded, rarely used
    function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
    }
    /**
     * Takes hex string or Uint8Array, converts to Uint8Array.
     * Validates output length.
     * Will throw error for other types.
     * @param title descriptive title for an error e.g. 'private key'
     * @param hex hex string or Uint8Array
     * @param expectedLength optional, will compare to result array's length
     * @returns
     */
    function ensureBytes(title, hex, expectedLength) {
        let res;
        if (typeof hex === 'string') {
            try {
                res = hexToBytes(hex);
            }
            catch (e) {
                throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
            }
        }
        else if (isBytes(hex)) {
            // Uint8Array.from() instead of hash.slice() because node.js Buffer
            // is instance of Uint8Array, and its slice() creates **mutable** copy
            res = Uint8Array.from(hex);
        }
        else {
            throw new Error(`${title} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === 'number' && len !== expectedLength)
            throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
        return res;
    }
    /**
     * Copies several Uint8Arrays into one.
     */
    function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
            const a = arrays[i];
            if (!isBytes(a))
                throw new Error('Uint8Array expected');
            sum += a.length;
        }
        let res = new Uint8Array(sum);
        let pad = 0;
        for (let i = 0; i < arrays.length; i++) {
            const a = arrays[i];
            res.set(a, pad);
            pad += a.length;
        }
        return res;
    }
    // Compares 2 u8a-s in kinda constant time
    function equalBytes(a, b) {
        if (a.length !== b.length)
            return false;
        let diff = 0;
        for (let i = 0; i < a.length; i++)
            diff |= a[i] ^ b[i];
        return diff === 0;
    }
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes(str) {
        if (typeof str !== 'string')
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    // Bit operations
    /**
     * Calculates amount of bits in a bigint.
     * Same as `n.toString(2).length`
     */
    function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
            ;
        return len;
    }
    /**
     * Gets single bit at position.
     * NOTE: first bit position is 0 (same as arrays)
     * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
     */
    function bitGet(n, pos) {
        return (n >> BigInt(pos)) & _1n;
    }
    /**
     * Sets single bit at position.
     */
    const bitSet = (n, pos, value) => {
        return n | ((value ? _1n : _0n) << BigInt(pos));
    };
    /**
     * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
     * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
     */
    const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    // DRBG
    const u8n = (data) => new Uint8Array(data); // creates Uint8Array
    const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
    /**
     * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
     * @returns function that will call DRBG until 2nd arg returns something meaningful
     * @example
     *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
     *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
     */
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== 'number' || hashLen < 2)
            throw new Error('hashLen must be a number');
        if (typeof qByteLen !== 'number' || qByteLen < 2)
            throw new Error('qByteLen must be a number');
        if (typeof hmacFn !== 'function')
            throw new Error('hmacFn must be a function');
        // Step B, Step C: set hashLen to 8*ceil(hlen/8)
        let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
        let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
        let i = 0; // Iterations counter, will throw when over 1000
        const reset = () => {
            v.fill(1);
            k.fill(0);
            i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
        const reseed = (seed = u8n()) => {
            // HMAC-DRBG reseed() function. Steps D-G
            k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
            v = h(); // v = hmac(k || v)
            if (seed.length === 0)
                return;
            k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
            v = h(); // v = hmac(k || v)
        };
        const gen = () => {
            // HMAC-DRBG generate() function
            if (i++ >= 1000)
                throw new Error('drbg: tried 1000 values');
            let len = 0;
            const out = [];
            while (len < qByteLen) {
                v = h();
                const sl = v.slice();
                out.push(sl);
                len += v.length;
            }
            return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
            reset();
            reseed(seed); // Steps D-G
            let res = undefined; // Step H: grind until k is in [1..n-1]
            while (!(res = pred(gen())))
                reseed();
            reset();
            return res;
        };
        return genUntil;
    }
    // Validating curves and fields
    const validatorFns = {
        bigint: (val) => typeof val === 'bigint',
        function: (val) => typeof val === 'function',
        boolean: (val) => typeof val === 'boolean',
        string: (val) => typeof val === 'string',
        stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
    };
    // type Record<K extends string | number | symbol, T> = { [P in K]: T; }
    function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
            const checkVal = validatorFns[type];
            if (typeof checkVal !== 'function')
                throw new Error(`Invalid validator "${type}", expected function`);
            const val = object[fieldName];
            if (isOptional && val === undefined)
                return;
            if (!checkVal(val, object)) {
                throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
            }
        };
        for (const [fieldName, type] of Object.entries(validators))
            checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
            checkField(fieldName, type, true);
        return object;
    }
    // validate type tests
    // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
    // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
    // // Should fail type-check
    // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
    // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
    // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
    // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
    //# sourceMappingURL=utils.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/curves/esm/ed25519.js":
    /*!***************************************************!*\
      !*** ./node_modules/@noble/curves/esm/ed25519.js ***!
      \***************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),
    /* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),
    /* harmony export */   ed25519: () => (/* binding */ ed25519),
    /* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),
    /* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),
    /* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),
    /* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),
    /* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),
    /* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),
    /* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),
    /* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),
    /* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),
    /* harmony export */   x25519: () => (/* binding */ x25519)
    /* harmony export */ });
    /* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ "./node_modules/@noble/hashes/esm/sha512.js");
    /* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ "./node_modules/@noble/hashes/esm/utils.js");
    /* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ "./node_modules/@noble/curves/esm/abstract/edwards.js");
    /* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ "./node_modules/@noble/curves/esm/abstract/montgomery.js");
    /* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/@noble/curves/esm/abstract/modular.js");
    /* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ "./node_modules/@noble/curves/esm/abstract/utils.js");
    /* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/@noble/curves/esm/abstract/hash-to-curve.js");
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    
    
    
    
    
    
    
    /**
     * ed25519 Twisted Edwards curve with following addons:
     * - X25519 ECDH
     * - Ristretto cofactor elimination
     * - Elligator hash-to-group / point indistinguishability
     */
    const ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');
    // (-1) aka (a) aka 2^((p-1)/4)
    const ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
    // prettier-ignore
    const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    function ed25519_pow_2_252_3(x) {
        const P = ED25519_P;
        const x2 = (x * x) % P;
        const b2 = (x2 * x) % P; // x^3, 11
        const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111
        const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x) % P; // x^31
        const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5) % P;
        const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10) % P;
        const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20) % P;
        const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40) % P;
        const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80) % P;
        const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80) % P;
        const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10) % P;
        const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x) % P;
        // ^ To pow to (p+3)/8, multiply it by x.
        return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
        // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
        // set the three least significant bits of the first byte
        bytes[0] &= 248; // 0b1111_1000
        // and the most significant bit of the last to zero,
        bytes[31] &= 127; // 0b0111_1111
        // set the second most significant bit of the last byte to 1
        bytes[31] |= 64; // 0b0100_0000
        return bytes;
    }
    // sqrt(u/v)
    function uvRatio(u, v) {
        const P = ED25519_P;
        const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v
        const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v
        // (p+3)/8 and (p-5)/8
        const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8
        const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx
        const root1 = x; // First root candidate
        const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
        const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root
        const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)
        const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)
        if (useRoot1)
            x = root1;
        if (useRoot2 || noRoot)
            x = root2; // We return root2 anyway, for const-time
        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))
            x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
    }
    // Just in case
    const ED25519_TORSION_SUBGROUP = [
        '0100000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
        '0000000000000000000000000000000000000000000000000000000000000080',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
        '0000000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
    ];
    const Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true);
    const ed25519Defaults = {
        // Param: a
        a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
        // Finite field p over which we'll do calculations; 2n**255n - 19n
        Fp,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
        Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
        hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,
        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/v
        uvRatio,
    };
    const ed25519 = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults);
    function ed25519_domain(data, ctx, phflag) {
        if (ctx.length > 255)
            throw new Error('Context is too big');
        return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
    }
    const ed25519ctx = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
    });
    const ed25519ph = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,
    });
    const x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255, // n is 253 bits
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
            const P = ED25519_P;
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,
    }))();
    /**
     * Converts ed25519 public key to x25519 public key. Uses formula:
     * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * @example
     *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());
     *   const aPriv = x25519.utils.randomPrivateKey();
     *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))
     */
    function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n = BigInt(1);
        return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));
    }
    const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated
    /**
     * Converts ed25519 secret key to x25519 secret key.
     * @example
     *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());
     *   const aPriv = ed25519.utils.randomPrivateKey();
     *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)
     */
    function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
    }
    // Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
    // NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
    // SageMath returns different root first and everything falls apart
    const ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic
    const ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1
    const ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)
    const ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    // prettier-ignore
    function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
        tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
        let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
        let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
        let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
        let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
        let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
        gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
        gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
        gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
        let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
        tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
        tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
        tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
        tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
        let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
        y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
        let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
        tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
        tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
        let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
        let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
        let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
        let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
        y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
        let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
        let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
        tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
        tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
        let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
        let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
        tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
        tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
        let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
        let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
        let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
        let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)
    }
    const ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0
    function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
        // map_to_curve_elligator2_curve25519(u)
        let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
        xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
        let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
        let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
        let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
        let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
        let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
        xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
        xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
        yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
        yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
        const inv = Fp.invertBatch([xd, yd]); // batch division
        return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)
    }
    const htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
        encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,
    }))();
    const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();
    const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();
    function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
            throw new Error('RistrettoPoint expected');
    }
    // (-1) aka (a) aka 2^((p-1)/4)
    const SQRT_M1 = ED25519_SQRT_M1;
    // (ad - 1)
    const SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
    // 1 / (a-d)
    const INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
    // 1-d
    const ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
    // (d-1)
    const D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
    // Calculates 1/(number)
    const invertSqrt = (number) => uvRatio(_1n, number);
    const MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
    const bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);
    // Computes Elligator map for Ristretto
    // https://ristretto.group/formulas/elligator.html
    function calcElligatorRistrettoMap(r0) {
        const { d } = ed25519.CURVE;
        const P = ed25519.CURVE.Fp.ORDER;
        const mod = ed25519.CURVE.Fp.create;
        const r = mod(SQRT_M1 * r0 * r0); // 1
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
        let c = BigInt(-1); // 3
        const D = mod((c - d * r) * mod(r + d)); // 4
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
        let s_ = mod(s * r0); // 6
        if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P))
            s_ = mod(-s_);
        if (!Ns_D_is_sq)
            s = s_; // 7
        if (!Ns_D_is_sq)
            c = r; // 8
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
        const s2 = s * s;
        const W0 = mod((s + s) * D); // 10
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
        const W2 = mod(_1n - s2); // 12
        const W3 = mod(_1n + s2); // 13
        return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    /**
     * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
     * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
     * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
     * but it should work in its own namespace: do not combine those two.
     * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448
     */
    class RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
            this.ep = ep;
        }
        static fromAffine(ap) {
            return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
            hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHash', hex, 64);
            const r1 = bytes255ToNumberLE(hex.slice(0, 32));
            const R1 = calcElligatorRistrettoMap(r1);
            const r2 = bytes255ToNumberLE(hex.slice(32, 64));
            const R2 = calcElligatorRistrettoMap(r2);
            return new RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
            hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHex', hex, 32);
            const { a, d } = ed25519.CURVE;
            const P = ed25519.CURVE.Fp.ORDER;
            const mod = ed25519.CURVE.Fp.create;
            const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
            const s = bytes255ToNumberLE(hex);
            // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
            // 3. Check that s is non-negative, or else abort
            if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))
                throw new Error(emsg);
            const s2 = mod(s * s);
            const u1 = mod(_1n + a * s2); // 4 (a is -1)
            const u2 = mod(_1n - a * s2); // 5
            const u1_2 = mod(u1 * u1);
            const u2_2 = mod(u2 * u2);
            const v = mod(a * d * u1_2 - u2_2); // 6
            const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
            const Dx = mod(I * u2); // 8
            const Dy = mod(I * Dx * v); // 9
            let x = mod((s + s) * Dx); // 10
            if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))
                x = mod(-x); // 10
            const y = mod(u1 * Dy); // 11
            const t = mod(x * y); // 12
            if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n)
                throw new Error(emsg);
            return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
            let { ex: x, ey: y, ez: z, et: t } = this.ep;
            const P = ed25519.CURVE.Fp.ORDER;
            const mod = ed25519.CURVE.Fp.create;
            const u1 = mod(mod(z + y) * mod(z - y)); // 1
            const u2 = mod(x * y); // 2
            // Square root always exists
            const u2sq = mod(u2 * u2);
            const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
            const D1 = mod(invsqrt * u1); // 4
            const D2 = mod(invsqrt * u2); // 5
            const zInv = mod(D1 * D2 * t); // 6
            let D; // 7
            if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {
                let _x = mod(y * SQRT_M1);
                let _y = mod(x * SQRT_M1);
                x = _x;
                y = _y;
                D = mod(D1 * INVSQRT_A_MINUS_D);
            }
            else {
                D = D2; // 8
            }
            if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P))
                y = mod(-y); // 9
            let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))
            if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))
                s = mod(-s);
            return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11
        }
        toHex() {
            return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());
        }
        toString() {
            return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
            assertRstPoint(other);
            const { ex: X1, ey: Y1 } = this.ep;
            const { ex: X2, ey: Y2 } = other.ep;
            const mod = ed25519.CURVE.Fp.create;
            // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
            const one = mod(X1 * Y2) === mod(Y1 * X2);
            const two = mod(Y1 * Y2) === mod(X1 * X2);
            return one || two;
        }
        add(other) {
            assertRstPoint(other);
            return new RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
            assertRstPoint(other);
            return new RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
            return new RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
            return new RistPoint(this.ep.multiplyUnsafe(scalar));
        }
        double() {
            return new RistPoint(this.ep.double());
        }
        negate() {
            return new RistPoint(this.ep.negate());
        }
    }
    const RistrettoPoint = /* @__PURE__ */ (() => {
        if (!RistPoint.BASE)
            RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
            RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
        return RistPoint;
    })();
    // Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B
    const hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;
        const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
    };
    const hash_to_ristretto255 = hashToRistretto255; // legacy
    //# sourceMappingURL=ed25519.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/_assert.js":
    /*!***************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
      \***************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   bool: () => (/* binding */ bool),
    /* harmony export */   bytes: () => (/* binding */ bytes),
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
    /* harmony export */   exists: () => (/* binding */ exists),
    /* harmony export */   hash: () => (/* binding */ hash),
    /* harmony export */   number: () => (/* binding */ number),
    /* harmony export */   output: () => (/* binding */ output)
    /* harmony export */ });
    function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
    }
    function bool(b) {
        if (typeof b !== 'boolean')
            throw new Error(`Expected boolean, not ${b}`);
    }
    // copied from utils
    function isBytes(a) {
        return (a instanceof Uint8Array ||
            (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
    }
    function bytes(b, ...lengths) {
        if (!isBytes(b))
            throw new Error('Expected Uint8Array');
        if (lengths.length > 0 && !lengths.includes(b.length))
            throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    function hash(hash) {
        if (typeof hash !== 'function' || typeof hash.create !== 'function')
            throw new Error('Hash should be wrapped by utils.wrapConstructor');
        number(hash.outputLen);
        number(hash.blockLen);
    }
    function exists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished)
            throw new Error('Hash#digest() has already been called');
    }
    function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
    }
    
    const assert = { number, bool, bytes, hash, exists, output };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);
    //# sourceMappingURL=_assert.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/_sha2.js":
    /*!*************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/_sha2.js ***!
      \*************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   SHA2: () => (/* binding */ SHA2)
    /* harmony export */ });
    /* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");
    
    
    // Polyfill for Safari 14
    function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === 'function')
            return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(0xffffffff);
        const wh = Number((value >> _32n) & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
    }
    // Base SHA2 class (RFC 6234)
    class SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
            super();
            this.blockLen = blockLen;
            this.outputLen = outputLen;
            this.padOffset = padOffset;
            this.isLE = isLE;
            this.finished = false;
            this.length = 0;
            this.pos = 0;
            this.destroyed = false;
            this.buffer = new Uint8Array(blockLen);
            this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);
        }
        update(data) {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);
            const { view, buffer, blockLen } = this;
            data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                // Fast path: we have at least one block in input, cast it to view and process
                if (take === blockLen) {
                    const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);
                    for (; blockLen <= len - pos; pos += blockLen)
                        this.process(dataView, pos);
                    continue;
                }
                buffer.set(data.subarray(pos, pos + take), this.pos);
                this.pos += take;
                pos += take;
                if (this.pos === blockLen) {
                    this.process(view, 0);
                    this.pos = 0;
                }
            }
            this.length += data.length;
            this.roundClean();
            return this;
        }
        digestInto(out) {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);
            this.finished = true;
            // Padding
            // We can avoid allocation of buffer for padding completely if it
            // was previously not allocated here. But it won't change performance.
            const { buffer, view, blockLen, isLE } = this;
            let { pos } = this;
            // append the bit '1' to the message
            buffer[pos++] = 0b10000000;
            this.buffer.subarray(pos).fill(0);
            // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
            if (this.padOffset > blockLen - pos) {
                this.process(view, 0);
                pos = 0;
            }
            // Pad until full block byte with zeros
            for (let i = pos; i < blockLen; i++)
                buffer[i] = 0;
            // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
            // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
            // So we just write lowest 64 bits of that value.
            setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
            this.process(view, 0);
            const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);
            const len = this.outputLen;
            // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
            if (len % 4)
                throw new Error('_sha2: outputLen should be aligned to 32bit');
            const outLen = len / 4;
            const state = this.get();
            if (outLen > state.length)
                throw new Error('_sha2: outputLen bigger than state');
            for (let i = 0; i < outLen; i++)
                oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
            const { buffer, outputLen } = this;
            this.digestInto(buffer);
            const res = buffer.slice(0, outputLen);
            this.destroy();
            return res;
        }
        _cloneInto(to) {
            to || (to = new this.constructor());
            to.set(...this.get());
            const { blockLen, buffer, length, finished, destroyed, pos } = this;
            to.length = length;
            to.pos = pos;
            to.finished = finished;
            to.destroyed = destroyed;
            if (length % blockLen)
                to.buffer.set(buffer);
            return to;
        }
    }
    //# sourceMappingURL=_sha2.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/_u64.js":
    /*!************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
      \************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   add: () => (/* binding */ add),
    /* harmony export */   add3H: () => (/* binding */ add3H),
    /* harmony export */   add3L: () => (/* binding */ add3L),
    /* harmony export */   add4H: () => (/* binding */ add4H),
    /* harmony export */   add4L: () => (/* binding */ add4L),
    /* harmony export */   add5H: () => (/* binding */ add5H),
    /* harmony export */   add5L: () => (/* binding */ add5L),
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
    /* harmony export */   fromBig: () => (/* binding */ fromBig),
    /* harmony export */   rotlBH: () => (/* binding */ rotlBH),
    /* harmony export */   rotlBL: () => (/* binding */ rotlBL),
    /* harmony export */   rotlSH: () => (/* binding */ rotlSH),
    /* harmony export */   rotlSL: () => (/* binding */ rotlSL),
    /* harmony export */   rotr32H: () => (/* binding */ rotr32H),
    /* harmony export */   rotr32L: () => (/* binding */ rotr32L),
    /* harmony export */   rotrBH: () => (/* binding */ rotrBH),
    /* harmony export */   rotrBL: () => (/* binding */ rotrBL),
    /* harmony export */   rotrSH: () => (/* binding */ rotrSH),
    /* harmony export */   rotrSL: () => (/* binding */ rotrSL),
    /* harmony export */   shrSH: () => (/* binding */ shrSH),
    /* harmony export */   shrSL: () => (/* binding */ shrSL),
    /* harmony export */   split: () => (/* binding */ split),
    /* harmony export */   toBig: () => (/* binding */ toBig)
    /* harmony export */ });
    const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    const _32n = /* @__PURE__ */ BigInt(32);
    // We are not using BigUint64Array, because they are extremely slow as per 2022
    function fromBig(n, le = false) {
        if (le)
            return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
        return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
    }
    const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
    // for Shift in [0, 32)
    const shrSH = (h, _l, s) => h >>> s;
    const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in [1, 32)
    const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
    const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
    const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
    // Right rotate for shift===32 (just swaps l&h)
    const rotr32H = (_h, l) => l;
    const rotr32L = (h, _l) => h;
    // Left rotate for Shift in [1, 32)
    const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
    // JS uses 32-bit signed integers for bitwise operations which means we cannot
    // simple take carry out of low bit sum by shift, we need to use division.
    function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
    }
    // Addition with more than 2 elements
    const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
    const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
    const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
    // prettier-ignore
    
    // prettier-ignore
    const u64 = {
        fromBig, split, toBig,
        shrSH, shrSL,
        rotrSH, rotrSL, rotrBH, rotrBL,
        rotr32H, rotr32L,
        rotlSH, rotlSL, rotlBH, rotlBL,
        add, add3L, add3H, add4L, add4H, add5H, add5L,
    };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);
    //# sourceMappingURL=_u64.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/crypto.js":
    /*!**************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
      \**************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   crypto: () => (/* binding */ crypto)
    /* harmony export */ });
    const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
    //# sourceMappingURL=crypto.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/sha256.js":
    /*!**************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
      \**************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   sha224: () => (/* binding */ sha224),
    /* harmony export */   sha256: () => (/* binding */ sha256)
    /* harmony export */ });
    /* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ "./node_modules/@noble/hashes/esm/_sha2.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");
    
    
    // SHA2-256 need to try 2^128 hashes to execute birthday attack.
    // BTC network is doing 2^67 hashes/sec as per early 2023.
    // Choice: a ? b : c
    const Chi = (a, b, c) => (a & b) ^ (~a & c);
    // Majority function, true if any two inpust is true
    const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
    // Round constants:
    // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
    // prettier-ignore
    const SHA256_K = /* @__PURE__ */ new Uint32Array([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]);
    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
    // prettier-ignore
    const IV = /* @__PURE__ */ new Uint32Array([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]);
    // Temporary buffer, not used to store anything between runs
    // Named this way because it matches specification.
    const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    class SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {
        constructor() {
            super(64, 32, 8, false);
            // We cannot use array here since array allows indexing by variable
            // which means optimizer/compiler cannot use registers.
            this.A = IV[0] | 0;
            this.B = IV[1] | 0;
            this.C = IV[2] | 0;
            this.D = IV[3] | 0;
            this.E = IV[4] | 0;
            this.F = IV[5] | 0;
            this.G = IV[6] | 0;
            this.H = IV[7] | 0;
        }
        get() {
            const { A, B, C, D, E, F, G, H } = this;
            return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
            this.A = A | 0;
            this.B = B | 0;
            this.C = C | 0;
            this.D = D | 0;
            this.E = E | 0;
            this.F = F | 0;
            this.G = G | 0;
            this.H = H | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4)
                SHA256_W[i] = view.getUint32(offset, false);
            for (let i = 16; i < 64; i++) {
                const W15 = SHA256_W[i - 15];
                const W2 = SHA256_W[i - 2];
                const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);
                const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);
                SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
            }
            // Compression function main loop, 64 rounds
            let { A, B, C, D, E, F, G, H } = this;
            for (let i = 0; i < 64; i++) {
                const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);
                const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);
                const T2 = (sigma0 + Maj(A, B, C)) | 0;
                H = G;
                G = F;
                F = E;
                E = (D + T1) | 0;
                D = C;
                C = B;
                B = A;
                A = (T1 + T2) | 0;
            }
            // Add the compressed chunk to the current hash value
            A = (A + this.A) | 0;
            B = (B + this.B) | 0;
            C = (C + this.C) | 0;
            D = (D + this.D) | 0;
            E = (E + this.E) | 0;
            F = (F + this.F) | 0;
            G = (G + this.G) | 0;
            H = (H + this.H) | 0;
            this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
            SHA256_W.fill(0);
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0);
            this.buffer.fill(0);
        }
    }
    // Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
    class SHA224 extends SHA256 {
        constructor() {
            super();
            this.A = 0xc1059ed8 | 0;
            this.B = 0x367cd507 | 0;
            this.C = 0x3070dd17 | 0;
            this.D = 0xf70e5939 | 0;
            this.E = 0xffc00b31 | 0;
            this.F = 0x68581511 | 0;
            this.G = 0x64f98fa7 | 0;
            this.H = 0xbefa4fa4 | 0;
            this.outputLen = 28;
        }
    }
    /**
     * SHA2-256 hash function
     * @param message - data that would be hashed
     */
    const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());
    const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());
    //# sourceMappingURL=sha256.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/sha512.js":
    /*!**************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
      \**************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   SHA512: () => (/* binding */ SHA512),
    /* harmony export */   sha384: () => (/* binding */ sha384),
    /* harmony export */   sha512: () => (/* binding */ sha512),
    /* harmony export */   sha512_224: () => (/* binding */ sha512_224),
    /* harmony export */   sha512_256: () => (/* binding */ sha512_256)
    /* harmony export */ });
    /* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ "./node_modules/@noble/hashes/esm/_sha2.js");
    /* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/esm/_u64.js");
    /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");
    
    
    
    // Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
    // prettier-ignore
    const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].split([
        '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
        '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
        '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
        '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
        '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
        '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
        '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
        '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
        '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
    ].map(n => BigInt(n))))();
    // Temporary buffer, not used to store anything between runs
    const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    class SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {
        constructor() {
            super(128, 64, 16, false);
            // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
            // Also looks cleaner and easier to verify with spec.
            // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0x6a09e667 | 0;
            this.Al = 0xf3bcc908 | 0;
            this.Bh = 0xbb67ae85 | 0;
            this.Bl = 0x84caa73b | 0;
            this.Ch = 0x3c6ef372 | 0;
            this.Cl = 0xfe94f82b | 0;
            this.Dh = 0xa54ff53a | 0;
            this.Dl = 0x5f1d36f1 | 0;
            this.Eh = 0x510e527f | 0;
            this.El = 0xade682d1 | 0;
            this.Fh = 0x9b05688c | 0;
            this.Fl = 0x2b3e6c1f | 0;
            this.Gh = 0x1f83d9ab | 0;
            this.Gl = 0xfb41bd6b | 0;
            this.Hh = 0x5be0cd19 | 0;
            this.Hl = 0x137e2179 | 0;
        }
        // prettier-ignore
        get() {
            const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
            return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
            this.Ah = Ah | 0;
            this.Al = Al | 0;
            this.Bh = Bh | 0;
            this.Bl = Bl | 0;
            this.Ch = Ch | 0;
            this.Cl = Cl | 0;
            this.Dh = Dh | 0;
            this.Dl = Dl | 0;
            this.Eh = Eh | 0;
            this.El = El | 0;
            this.Fh = Fh | 0;
            this.Fl = Fl | 0;
            this.Gh = Gh | 0;
            this.Gl = Gl | 0;
            this.Hh = Hh | 0;
            this.Hl = Hl | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4) {
                SHA512_W_H[i] = view.getUint32(offset);
                SHA512_W_L[i] = view.getUint32((offset += 4));
            }
            for (let i = 16; i < 80; i++) {
                // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
                const W15h = SHA512_W_H[i - 15] | 0;
                const W15l = SHA512_W_L[i - 15] | 0;
                const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSH(W15h, W15l, 7);
                const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSL(W15h, W15l, 7);
                // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
                const W2h = SHA512_W_H[i - 2] | 0;
                const W2l = SHA512_W_L[i - 2] | 0;
                const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSH(W2h, W2l, 6);
                const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSL(W2h, W2l, 6);
                // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
                const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
                const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
                SHA512_W_H[i] = SUMh | 0;
                SHA512_W_L[i] = SUMl | 0;
            }
            let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
            // Compression function main loop, 80 rounds
            for (let i = 0; i < 80; i++) {
                // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
                const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(Eh, El, 41);
                const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(Eh, El, 41);
                //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const CHIh = (Eh & Fh) ^ (~Eh & Gh);
                const CHIl = (El & Fl) ^ (~El & Gl);
                // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
                // prettier-ignore
                const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
                const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
                const T1l = T1ll | 0;
                // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
                const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(Ah, Al, 39);
                const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(Ah, Al, 39);
                const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
                const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
                Hh = Gh | 0;
                Hl = Gl | 0;
                Gh = Fh | 0;
                Gl = Fl | 0;
                Fh = Eh | 0;
                Fl = El | 0;
                ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
                Dh = Ch | 0;
                Dl = Cl | 0;
                Ch = Bh | 0;
                Cl = Bl | 0;
                Bh = Ah | 0;
                Bl = Al | 0;
                const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add3L(T1l, sigma0l, MAJl);
                Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add3H(All, T1h, sigma0h, MAJh);
                Al = All | 0;
            }
            // Add the compressed chunk to the current hash value
            ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
            ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
            ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
            ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
            ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
            ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
            ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
            this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
            SHA512_W_H.fill(0);
            SHA512_W_L.fill(0);
        }
        destroy() {
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
    }
    class SHA512_224 extends SHA512 {
        constructor() {
            super();
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0x8c3d37c8 | 0;
            this.Al = 0x19544da2 | 0;
            this.Bh = 0x73e19966 | 0;
            this.Bl = 0x89dcd4d6 | 0;
            this.Ch = 0x1dfab7ae | 0;
            this.Cl = 0x32ff9c82 | 0;
            this.Dh = 0x679dd514 | 0;
            this.Dl = 0x582f9fcf | 0;
            this.Eh = 0x0f6d2b69 | 0;
            this.El = 0x7bd44da8 | 0;
            this.Fh = 0x77e36f73 | 0;
            this.Fl = 0x04c48942 | 0;
            this.Gh = 0x3f9d85a8 | 0;
            this.Gl = 0x6a1d36c8 | 0;
            this.Hh = 0x1112e6ad | 0;
            this.Hl = 0x91d692a1 | 0;
            this.outputLen = 28;
        }
    }
    class SHA512_256 extends SHA512 {
        constructor() {
            super();
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0x22312194 | 0;
            this.Al = 0xfc2bf72c | 0;
            this.Bh = 0x9f555fa3 | 0;
            this.Bl = 0xc84c64c2 | 0;
            this.Ch = 0x2393b86b | 0;
            this.Cl = 0x6f53b151 | 0;
            this.Dh = 0x96387719 | 0;
            this.Dl = 0x5940eabd | 0;
            this.Eh = 0x96283ee2 | 0;
            this.El = 0xa88effe3 | 0;
            this.Fh = 0xbe5e1e25 | 0;
            this.Fl = 0x53863992 | 0;
            this.Gh = 0x2b0199fc | 0;
            this.Gl = 0x2c85b8aa | 0;
            this.Hh = 0x0eb72ddc | 0;
            this.Hl = 0x81c52ca2 | 0;
            this.outputLen = 32;
        }
    }
    class SHA384 extends SHA512 {
        constructor() {
            super();
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0xcbbb9d5d | 0;
            this.Al = 0xc1059ed8 | 0;
            this.Bh = 0x629a292a | 0;
            this.Bl = 0x367cd507 | 0;
            this.Ch = 0x9159015a | 0;
            this.Cl = 0x3070dd17 | 0;
            this.Dh = 0x152fecd8 | 0;
            this.Dl = 0xf70e5939 | 0;
            this.Eh = 0x67332667 | 0;
            this.El = 0xffc00b31 | 0;
            this.Fh = 0x8eb44a87 | 0;
            this.Fl = 0x68581511 | 0;
            this.Gh = 0xdb0c2e0d | 0;
            this.Gl = 0x64f98fa7 | 0;
            this.Hh = 0x47b5481d | 0;
            this.Hl = 0xbefa4fa4 | 0;
            this.outputLen = 48;
        }
    }
    const sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());
    const sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());
    const sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());
    const sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());
    //# sourceMappingURL=sha512.js.map
    
    /***/ }),
    
    /***/ "./node_modules/@noble/hashes/esm/utils.js":
    /*!*************************************************!*\
      !*** ./node_modules/@noble/hashes/esm/utils.js ***!
      \*************************************************/
    /***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   Hash: () => (/* binding */ Hash),
    /* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),
    /* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),
    /* harmony export */   checkOpts: () => (/* binding */ checkOpts),
    /* harmony export */   concatBytes: () => (/* binding */ concatBytes),
    /* harmony export */   createView: () => (/* binding */ createView),
    /* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),
    /* harmony export */   isLE: () => (/* binding */ isLE),
    /* harmony export */   nextTick: () => (/* binding */ nextTick),
    /* harmony export */   randomBytes: () => (/* binding */ randomBytes),
    /* harmony export */   rotr: () => (/* binding */ rotr),
    /* harmony export */   toBytes: () => (/* binding */ toBytes),
    /* harmony export */   u32: () => (/* binding */ u32),
    /* harmony export */   u8: () => (/* binding */ u8),
    /* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),
    /* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),
    /* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),
    /* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)
    /* harmony export */ });
    /* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/esm/crypto.js");
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
    // node.js versions earlier than v19 don't declare it in global scope.
    // For node.js, package.json#exports field mapping rewrites import
    // from `crypto` to `cryptoNode`, which imports native module.
    // Makes the utils un-importable in browsers without a bundler.
    // Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
    
    // Cast array to different type
    const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    function isBytes(a) {
        return (a instanceof Uint8Array ||
            (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
    }
    // Cast array to view
    const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    // The rotate right (circular right shift) operation for uint32
    const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
    // big-endian hardware is rare. Just in case someone still decides to run hashes:
    // early-throw an error because we don't support BE yet.
    // Other libraries would silently corrupt the data instead of throwing an error,
    // when they don't support it.
    const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    if (!isLE)
        throw new Error('Non little-endian hardware is not supported');
    // Array where index 0xf0 (240) is mapped to string 'f0'
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
    /**
     * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
     */
    function bytesToHex(bytes) {
        if (!isBytes(bytes))
            throw new Error('Uint8Array expected');
        // pre-caching improves the speed 6x
        let hex = '';
        for (let i = 0; i < bytes.length; i++) {
            hex += hexes[bytes[i]];
        }
        return hex;
    }
    // We use optimized technique to convert hex string to byte array
    const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
        if (char >= asciis._0 && char <= asciis._9)
            return char - asciis._0;
        if (char >= asciis._A && char <= asciis._F)
            return char - (asciis._A - 10);
        if (char >= asciis._a && char <= asciis._f)
            return char - (asciis._a - 10);
        return;
    }
    /**
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
            throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
            const n1 = asciiToBase16(hex.charCodeAt(hi));
            const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
            if (n1 === undefined || n2 === undefined) {
                const char = hex[hi] + hex[hi + 1];
                throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
            }
            array[ai] = n1 * 16 + n2;
        }
        return array;
    }
    // There is no setImmediate in browser and setTimeout is slow.
    // call of async fn will return Promise, which will be fullfiled only on
    // next scheduler queue processing step and this is exactly what we need.
    const nextTick = async () => { };
    // Returns control to thread each 'tick' ms to avoid blocking
    async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
            cb(i);
            // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
            const diff = Date.now() - ts;
            if (diff >= 0 && diff < tick)
                continue;
            await nextTick();
            ts += diff;
        }
    }
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes(str) {
        if (typeof str !== 'string')
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    /**
     * Normalizes (non-hex) string or Uint8Array to Uint8Array.
     * Warning: when Uint8Array is passed, it would NOT get copied.
     * Keep in mind for future mutable operations.
     */
    function toBytes(data) {
        if (typeof data === 'string')
            data = utf8ToBytes(data);
        if (!isBytes(data))
            throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
    }
    /**
     * Copies several Uint8Arrays into one.
     */
    function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
            const a = arrays[i];
            if (!isBytes(a))
                throw new Error('Uint8Array expected');
            sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
            const a = arrays[i];
            res.set(a, pad);
            pad += a.length;
        }
        return res;
    }
    // For runtime check if class implements interface
    class Hash {
        // Safe version that clones internal state
        clone() {
            return this._cloneInto();
        }
    }
    const toStr = {}.toString;
    function checkOpts(defaults, opts) {
        if (opts !== undefined && toStr.call(opts) !== '[object Object]')
            throw new Error('Options should be object or undefined');
        const merged = Object.assign(defaults, opts);
        return merged;
    }
    function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
    }
    /**
     * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
     */
    function randomBytes(bytesLength = 32) {
        if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {
            return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error('crypto.getRandomValues must be defined');
    }
    //# sourceMappingURL=utils.js.map
    
    /***/ })
    
    /******/ 	});
    /************************************************************************/
    /******/ 	// The module cache
    /******/ 	var __webpack_module_cache__ = {};
    /******/ 	
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/ 		// Check if module is in cache
    /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
    /******/ 		if (cachedModule !== undefined) {
    /******/ 			return cachedModule.exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = __webpack_module_cache__[moduleId] = {
    /******/ 			// no module.id needed
    /******/ 			// no module.loaded needed
    /******/ 			exports: {}
    /******/ 		};
    /******/ 	
    /******/ 		// Execute the module function
    /******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/ 	
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/ 	
    /************************************************************************/
    /******/ 	/* webpack/runtime/amd options */
    /******/ 	(() => {
    /******/ 		__webpack_require__.amdO = {};
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/compat get default export */
    /******/ 	(() => {
    /******/ 		// getDefaultExport function for compatibility with non-harmony modules
    /******/ 		__webpack_require__.n = (module) => {
    /******/ 			var getter = module && module.__esModule ?
    /******/ 				() => (module['default']) :
    /******/ 				() => (module);
    /******/ 			__webpack_require__.d(getter, { a: getter });
    /******/ 			return getter;
    /******/ 		};
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/define property getters */
    /******/ 	(() => {
    /******/ 		// define getter functions for harmony exports
    /******/ 		__webpack_require__.d = (exports, definition) => {
    /******/ 			for(var key in definition) {
    /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
    /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
    /******/ 				}
    /******/ 			}
    /******/ 		};
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/global */
    /******/ 	(() => {
    /******/ 		__webpack_require__.g = (function() {
    /******/ 			if (typeof globalThis === 'object') return globalThis;
    /******/ 			try {
    /******/ 				return this || new Function('return this')();
    /******/ 			} catch (e) {
    /******/ 				if (typeof window === 'object') return window;
    /******/ 			}
    /******/ 		})();
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
    /******/ 	(() => {
    /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/make namespace object */
    /******/ 	(() => {
    /******/ 		// define __esModule on exports
    /******/ 		__webpack_require__.r = (exports) => {
    /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 			}
    /******/ 			Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 		};
    /******/ 	})();
    /******/ 	
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    (() => {
    "use strict";
    /*!*******************************************!*\
      !*** ./src/icp_nft_frontend/src/index.js ***!
      \*******************************************/
    __webpack_require__.r(__webpack_exports__);
    /* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ "./node_modules/@dfinity/agent/lib/esm/index.js");
    /* harmony import */ var _psychedelic_dab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @psychedelic/dab-js */ "./node_modules/@psychedelic/dab-js/dist/index.js");
    /* harmony import */ var _psychedelic_dab_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_psychedelic_dab_js__WEBPACK_IMPORTED_MODULE_1__);
    
    
    
    // Create an agent for a different actor
    const agent = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({ host: "https://icp-api.io" });
    
    const getNFTCollections = async () => {
      const principal = sessionStorage.getItem("principalId");
    
      // Show loader when starting the operation
      document.getElementById("loader").style.display = "block";
    
      try {
        const collections = await (0,_psychedelic_dab_js__WEBPACK_IMPORTED_MODULE_1__.getAllUserNFTs)({
          agent,
          user: principal,
        });
    
        // Manually handle BigInt serialization
        const collectionsString = JSON.stringify(collections, (key, value) => {
          if (typeof value === "bigint") {
            return value.toString(); // Convert BigInt to string
          }
          return value;
        });
    
        console.log(collections);
    
        sessionStorage.setItem("nft", collectionsString);
    
        // Reload the page after successful fetch
        location.reload();
      } catch (error) {
        console.error("Error fetching NFT collections:", error);
      } finally {
        // Hide loader when the operation is completed (whether successful or not)
        document.getElementById("loader").style.display = "none";
      }
    };
    
    // Assuming you have an HTML button with id="chekk"
    const chekkButton = document.getElementById("chekk");
    
    // Add a click event listener to the button
    chekkButton.addEventListener("click", async () => {
      await getNFTCollections();
    });
    
    // When retrieving the data, use a reviver function to convert BigInt strings back to BigInt
    const storedCollectionsString = sessionStorage.getItem("nft");
    if (storedCollectionsString) {
      const storedCollections = JSON.parse(
        storedCollectionsString,
        (key, value) => {
          if (typeof value === "string" && /^\d+n$/.test(value)) {
            return BigInt(value.slice(0, -1)); // Convert back to BigInt
          }
          return value;
        }
      );
      console.log("Retrieved from sessionStorage:", storedCollections);
    } else {
      console.log("No data stored in sessionStorage");
    }
    
    // Retrieve NFT data from sessionStorage
    var storedNFTData = sessionStorage.getItem("nft");
    
    // Check if data exists
    if (storedNFTData) {
      // Parse the stored JSON data
      var nftData = JSON.parse(storedNFTData);
    
      // Display NFT data on the webpage
      document.getElementById("nft-image").src = nftData[0].icon; // Replace 'imageUrl' with the actual property name
      document.getElementById("nft-title").innerText = nftData[0].name;
      document.getElementById("nft-description").innerText = "Own NFT : " + nftData[0].tokens.length;
      // Update other elements as needed
      //document.cookie="profile_viewer_uid=" + nftData[0].tokens.length;
    
      setCookie("nftLength", nftData[0].tokens.length, 1); // Set a cookie named "user" with the value "John Doe" that expires in 30 days
    
      var viewNFTButton = document.getElementById('nft-action-btn');
                viewNFTButton.addEventListener('click', function(event) {
                    // Prevent the default behavior of the link (preventing the page from navigating)
                    event.preventDefault();
                    window.open( "https://toniq.io/marketplace/" + titleToSlug(nftData[0].name), '_blank');
    
                    // Navigate to the specified URL
                    //window.location.href = "https://toniq.io/marketplace/" + titleToSlug(nftData[0].name); // Replace with your actual URL
                });
    
                document.getElementById('nft-card').style.display = 'block';
    
    } else {
      console.log("NFT data not found in sessionStorage.");
    }
    
    function titleToSlug(title) {
      // Convert to lowercase and replace spaces with hyphens
      var slug = title.toLowerCase().replace(/\s+/g, '-');
    
      // Remove special characters
      slug = slug.replace(/[^\w-]/g, '');
    
      // Replace consecutive dashes with a single dash
      slug = slug.replace(/-+/g, '-');
    
      return slug;
      
    }
    
    function setCookie(cookieName, cookieValue, expirationDays) {
      var d = new Date();
      d.setTime(d.getTime() + (expirationDays * 60 * 1000));
      var expires = "expires=" + d.toUTCString();
      document.cookie = cookieName + "=" + cookieValue + ";" + expires + ";path=/";
    }
    
    })();
    
    /******/ })()
    ;
    //# sourceMappingURL=index.js.map